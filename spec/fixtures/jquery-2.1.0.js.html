<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/code/vim-javascript/spec/fixtures/jquery-2.1.0.js.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="javascript">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Statement { color: #af5f00; }
.Type { color: #008000; }
.Todo { color: #000000; background-color: #ffff00; padding-bottom: 1px; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Identifier { color: #008080; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*!</span>
<span class="Comment"> * jQuery JavaScript Library v2.1.0</span>
<span class="Comment"> * <a href="http://jquery.com/">http://jquery.com/</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Includes Sizzle.js</span>
<span class="Comment"> * <a href="http://sizzlejs.com/">http://sizzlejs.com/</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors</span>
<span class="Comment"> * Released under the MIT license</span>
<span class="Comment"> * <a href="http://jquery.org/license">http://jquery.org/license</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Date: 2014-01-23T21:10Z</span>
<span class="Comment"> */</span>

(<span class="Type">function</span>( global, factory ) {

	<span class="Statement">if</span> ( <span class="Statement">typeof</span> module <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> module.exports <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
<span class="Comment">		// For CommonJS and CommonJS-like environments where a proper window is present,</span>
<span class="Comment">		// execute the factory and get jQuery</span>
<span class="Comment">		// For environments that do not inherently posses a window with a document</span>
<span class="Comment">		// (such as Node.js), expose a jQuery-making factory as module.exports</span>
<span class="Comment">		// This accentuates the need for the creation of a real window</span>
<span class="Comment">		// e.g. var jQuery = require(&quot;jquery&quot;)(window);</span>
<span class="Comment">		// See ticket #14549 for more info</span>
		module.exports <span class="Statement">=</span> global.<span class="Special">document</span> <span class="Statement">?</span>
			factory( global, <span class="Constant">true</span> ) <span class="Statement">:</span>
			<span class="Type">function</span>( w ) {
				<span class="Statement">if</span> ( <span class="Statement">!</span>w.<span class="Special">document</span> ) {
					<span class="Statement">throw</span> <span class="Statement">new</span> <span class="Special">Error</span>( <span class="Constant">&quot;jQuery requires a window with a document&quot;</span> );
				}
				<span class="Statement">return</span> factory( w );
			};
	} <span class="Statement">else</span> {
		factory( global );
	}

<span class="Comment">// Pass this if window is not defined yet</span>
}(<span class="Statement">typeof</span> <span class="Special">window</span> <span class="Statement">!==</span> <span class="Constant">&quot;undefined&quot;</span> <span class="Statement">?</span> <span class="Special">window</span> <span class="Statement">:</span> <span class="Special">this</span>, <span class="Type">function</span>( window, noGlobal ) {

<span class="Comment">// Can't do this because several apps including ASP.NET trace</span>
<span class="Comment">// the stack via arguments.caller.callee and Firefox dies if</span>
<span class="Comment">// you try to trace through &quot;use strict&quot; call chains. (#13335)</span>
<span class="Comment">// Support: Firefox 18+</span>
<span class="Comment">//</span>

<span class="Type">var</span> arr <span class="Statement">=</span> [];

<span class="Type">var</span> slice <span class="Statement">=</span> arr.slice;

<span class="Type">var</span> concat <span class="Statement">=</span> arr.concat;

<span class="Type">var</span> push <span class="Statement">=</span> arr.push;

<span class="Type">var</span> indexOf <span class="Statement">=</span> arr.indexOf;

<span class="Type">var</span> class2type <span class="Statement">=</span> {};

<span class="Type">var</span> toString <span class="Statement">=</span> class2type.toString;

<span class="Type">var</span> hasOwn <span class="Statement">=</span> class2type.hasOwnProperty;

<span class="Type">var</span> trim <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>.trim;

<span class="Type">var</span> support <span class="Statement">=</span> {};



<span class="Type">var</span>
<span class="Comment">	// Use the correct document accordingly with window argument (sandbox)</span>
	<span class="Special">document</span> <span class="Statement">=</span> <span class="Special">window</span>.<span class="Special">document</span>,

	version <span class="Statement">=</span> <span class="Constant">&quot;2.1.0&quot;</span>,

<span class="Comment">	// Define a local copy of jQuery</span>
	jQuery <span class="Statement">=</span> <span class="Type">function</span>( selector, context ) {
<span class="Comment">		// The jQuery object is actually just the init constructor 'enhanced'</span>
<span class="Comment">		// Need init if jQuery is called (just allow error to be thrown if not included)</span>
		<span class="Statement">return</span> <span class="Statement">new</span> jQuery.fn.init( selector, context );
	},

<span class="Comment">	// Matches dashed string for camelizing</span>
	rmsPrefix <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">-ms-/</span>,
	rdashAlpha <span class="Statement">=</span> <span class="Constant">/-</span><span class="Constant">(</span><span class="Constant">[\da-z]</span><span class="Constant">)</span><span class="Constant">/gi</span>,

<span class="Comment">	// Used by jQuery.camelCase as callback to replace()</span>
	fcamelCase <span class="Statement">=</span> <span class="Type">function</span>( all, letter ) {
		<span class="Statement">return</span> letter.toUpperCase();
	};

jQuery.fn <span class="Statement">=</span> jQuery.<span class="Special">prototype</span> <span class="Statement">=</span> {
<span class="Comment">	// The current version of jQuery being used</span>
	jquery: version,

	constructor: jQuery,

<span class="Comment">	// Start with an empty selector</span>
	selector: <span class="Constant">&quot;&quot;</span>,

<span class="Comment">	// The default length of a jQuery object is 0</span>
	length: <span class="Constant">0</span>,

	toArray: <span class="Type">function</span>() {
		<span class="Statement">return</span> slice.call( <span class="Special">this</span> );
	},

<span class="Comment">	// Get the Nth element in the matched element set OR</span>
<span class="Comment">	// Get the whole matched element set as a clean array</span>
	get: <span class="Type">function</span>( num ) {
		<span class="Statement">return</span> num <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">?</span>

<span class="Comment">			// Return a 'clean' array</span>
			( num <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span> <span class="Special">this</span>[ num <span class="Statement">+</span> <span class="Special">this</span>.length ] <span class="Statement">:</span> <span class="Special">this</span>[ num ] ) <span class="Statement">:</span>

<span class="Comment">			// Return just the object</span>
			slice.call( <span class="Special">this</span> );
	},

<span class="Comment">	// Take an array of elements and push it onto the stack</span>
<span class="Comment">	// (returning the new matched element set)</span>
	pushStack: <span class="Type">function</span>( elems ) {

<span class="Comment">		// Build a new jQuery matched element set</span>
		<span class="Type">var</span> ret <span class="Statement">=</span> jQuery.merge( <span class="Special">this</span>.constructor(), elems );

<span class="Comment">		// Add the old object onto the stack (as a reference)</span>
		ret.prevObject <span class="Statement">=</span> <span class="Special">this</span>;
		ret.context <span class="Statement">=</span> <span class="Special">this</span>.context;

<span class="Comment">		// Return the newly-formed element set</span>
		<span class="Statement">return</span> ret;
	},

<span class="Comment">	// Execute a callback for every element in the matched set.</span>
<span class="Comment">	// (You can seed the arguments with an array of args, but this is</span>
<span class="Comment">	// only used internally.)</span>
	each: <span class="Type">function</span>( callback, args ) {
		<span class="Statement">return</span> jQuery.each( <span class="Special">this</span>, callback, args );
	},

	map: <span class="Type">function</span>( callback ) {
		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( jQuery.map(<span class="Special">this</span>, <span class="Type">function</span>( elem, i ) {
			<span class="Statement">return</span> callback.call( elem, i, elem );
		}));
	},

	slice: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( slice.apply( <span class="Special">this</span>, arguments ) );
	},

	first: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.eq( <span class="Constant">0</span> );
	},

	last: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.eq( <span class="Statement">-</span><span class="Constant">1</span> );
	},

	eq: <span class="Type">function</span>( i ) {
		<span class="Type">var</span> len <span class="Statement">=</span> <span class="Special">this</span>.length,
			j <span class="Statement">=</span> <span class="Statement">+</span>i <span class="Statement">+</span> ( i <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span> len <span class="Statement">:</span> <span class="Constant">0</span> );
		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( j <span class="Statement">&gt;=</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span> j <span class="Statement">&lt;</span> len <span class="Statement">?</span> [ <span class="Special">this</span>[j] ] <span class="Statement">:</span> [] );
	},

	end: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.prevObject <span class="Statement">||</span> <span class="Special">this</span>.constructor(<span class="Type">null</span>);
	},

<span class="Comment">	// For internal use only.</span>
<span class="Comment">	// Behaves like an Array's method, not like a jQuery method.</span>
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend <span class="Statement">=</span> jQuery.fn.extend <span class="Statement">=</span> <span class="Type">function</span>() {
	<span class="Type">var</span> options, name, src, copy, copyIsArray, clone,
		target <span class="Statement">=</span> <span class="Special">arguments</span>[<span class="Constant">0</span>] <span class="Statement">||</span> {},
		i <span class="Statement">=</span> <span class="Constant">1</span>,
		length <span class="Statement">=</span> <span class="Special">arguments</span>.length,
		deep <span class="Statement">=</span> <span class="Constant">false</span>;

<span class="Comment">	// Handle a deep copy situation</span>
	<span class="Statement">if</span> ( <span class="Statement">typeof</span> target <span class="Statement">===</span> <span class="Constant">&quot;boolean&quot;</span> ) {
		deep <span class="Statement">=</span> target;

<span class="Comment">		// skip the boolean and the target</span>
		target <span class="Statement">=</span> arguments[ i ] <span class="Statement">||</span> {};
		i<span class="Statement">++</span>;
	}

<span class="Comment">	// Handle case when target is a string or something (possible in deep copy)</span>
	<span class="Statement">if</span> ( <span class="Statement">typeof</span> target <span class="Statement">!==</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.isFunction(target) ) {
		target <span class="Statement">=</span> {};
	}

<span class="Comment">	// extend jQuery itself if only one argument is passed</span>
	<span class="Statement">if</span> ( i <span class="Statement">===</span> length ) {
		target <span class="Statement">=</span> <span class="Special">this</span>;
		i<span class="Statement">--</span>;
	}

	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i<span class="Statement">++</span> ) {
<span class="Comment">		// Only deal with non-null/undefined values</span>
		<span class="Statement">if</span> ( (options <span class="Statement">=</span> arguments[ i ]) <span class="Statement">!=</span> <span class="Type">null</span> ) {
<span class="Comment">			// Extend the base object</span>
			<span class="Statement">for</span> ( name <span class="Statement">in</span> options ) {
				src <span class="Statement">=</span> target[ name ];
				copy <span class="Statement">=</span> options[ name ];

<span class="Comment">				// Prevent never-ending loop</span>
				<span class="Statement">if</span> ( target <span class="Statement">===</span> copy ) {
					<span class="Statement">continue</span>;
				}

<span class="Comment">				// Recurse if we're merging plain objects or arrays</span>
				<span class="Statement">if</span> ( deep <span class="Statement">&amp;&amp;</span> copy <span class="Statement">&amp;&amp;</span> ( jQuery.isPlainObject(copy) <span class="Statement">||</span> (copyIsArray <span class="Statement">=</span> jQuery.isArray(copy)) ) ) {
					<span class="Statement">if</span> ( copyIsArray ) {
						copyIsArray <span class="Statement">=</span> <span class="Constant">false</span>;
						clone <span class="Statement">=</span> src <span class="Statement">&amp;&amp;</span> jQuery.isArray(src) <span class="Statement">?</span> src <span class="Statement">:</span> [];

					} <span class="Statement">else</span> {
						clone <span class="Statement">=</span> src <span class="Statement">&amp;&amp;</span> jQuery.isPlainObject(src) <span class="Statement">?</span> src <span class="Statement">:</span> {};
					}

<span class="Comment">					// Never move original objects, clone them</span>
					target[ name ] <span class="Statement">=</span> jQuery.extend( deep, clone, copy );

<span class="Comment">				// Don't bring in undefined values</span>
				} <span class="Statement">else</span> <span class="Statement">if</span> ( copy <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					target[ name ] <span class="Statement">=</span> copy;
				}
			}
		}
	}

<span class="Comment">	// Return the modified object</span>
	<span class="Statement">return</span> target;
};

jQuery.extend({
<span class="Comment">	// Unique for each copy of jQuery on the page</span>
	expando: <span class="Constant">&quot;jQuery&quot;</span> <span class="Statement">+</span> ( version <span class="Statement">+</span> <span class="Special">Math</span>.random() ).replace( <span class="Constant">/</span><span class="Special">\D</span><span class="Constant">/g</span>, <span class="Constant">&quot;&quot;</span> ),

<span class="Comment">	// Assume jQuery is ready without the ready module</span>
	isReady: <span class="Constant">true</span>,

	error: <span class="Type">function</span>( msg ) {
		<span class="Statement">throw</span> <span class="Statement">new</span> <span class="Special">Error</span>( msg );
	},

	noop: <span class="Type">function</span>() {},

<span class="Comment">	// See test/unit/core.js for details concerning isFunction.</span>
<span class="Comment">	// Since version 1.3, DOM methods and functions like alert</span>
<span class="Comment">	// aren't supported. They return false on IE (#2968).</span>
	isFunction: <span class="Type">function</span>( obj ) {
		<span class="Statement">return</span> jQuery.type(obj) <span class="Statement">===</span> <span class="Constant">&quot;function&quot;</span>;
	},

	isArray: <span class="Special">Array</span>.isArray,

	isWindow: <span class="Type">function</span>( obj ) {
		<span class="Statement">return</span> obj <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">&amp;&amp;</span> obj <span class="Statement">===</span> obj.<span class="Special">window</span>;
	},

	isNumeric: <span class="Type">function</span>( obj ) {
<span class="Comment">		// parseFloat NaNs numeric-cast false positives (null|true|false|&quot;&quot;)</span>
<span class="Comment">		// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)</span>
<span class="Comment">		// subtraction forces infinities to NaN</span>
		<span class="Statement">return</span> obj <span class="Statement">-</span> <span class="Special">parseFloat</span>( obj ) <span class="Statement">&gt;=</span> <span class="Constant">0</span>;
	},

	isPlainObject: <span class="Type">function</span>( obj ) {
<span class="Comment">		// Not plain objects:</span>
<span class="Comment">		// - Any object or value whose internal [[Class]] property is not &quot;[object Object]&quot;</span>
<span class="Comment">		// - DOM nodes</span>
<span class="Comment">		// - window</span>
		<span class="Statement">if</span> ( jQuery.type( obj ) <span class="Statement">!==</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">||</span> obj.nodeType <span class="Statement">||</span> jQuery.isWindow( obj ) ) {
			<span class="Statement">return</span> <span class="Constant">false</span>;
		}

<span class="Comment">		// Support: Firefox &lt;20</span>
<span class="Comment">		// The try/catch suppresses exceptions thrown when attempting to access</span>
<span class="Comment">		// the &quot;constructor&quot; property of certain host objects, ie. |window.location|</span>
<span class="Comment">		// <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=814622">https://bugzilla.mozilla.org/show_bug.cgi?id=814622</a></span>
		<span class="Statement">try</span> {
			<span class="Statement">if</span> ( obj.constructor <span class="Statement">&amp;&amp;</span>
					<span class="Statement">!</span>hasOwn.call( obj.constructor.<span class="Special">prototype</span>, <span class="Constant">&quot;isPrototypeOf&quot;</span> ) ) {
				<span class="Statement">return</span> <span class="Constant">false</span>;
			}
		} <span class="Statement">catch</span> ( e ) {
			<span class="Statement">return</span> <span class="Constant">false</span>;
		}

<span class="Comment">		// If the function hasn't returned already, we're confident that</span>
<span class="Comment">		// |obj| is a plain object, created by {} or constructed with new Object</span>
		<span class="Statement">return</span> <span class="Constant">true</span>;
	},

	isEmptyObject: <span class="Type">function</span>( obj ) {
		<span class="Type">var</span> name;
		<span class="Statement">for</span> ( name <span class="Statement">in</span> obj ) {
			<span class="Statement">return</span> <span class="Constant">false</span>;
		}
		<span class="Statement">return</span> <span class="Constant">true</span>;
	},

	type: <span class="Type">function</span>( obj ) {
		<span class="Statement">if</span> ( obj <span class="Statement">==</span> <span class="Type">null</span> ) {
			<span class="Statement">return</span> obj <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span>;
		}
<span class="Comment">		// Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)</span>
		<span class="Statement">return</span> <span class="Statement">typeof</span> obj <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">||</span> <span class="Statement">typeof</span> obj <span class="Statement">===</span> <span class="Constant">&quot;function&quot;</span> <span class="Statement">?</span>
			class2type[ toString.call(obj) ] <span class="Statement">||</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">:</span>
			<span class="Statement">typeof</span> obj;
	},

<span class="Comment">	// Evaluates a script in a global context</span>
	globalEval: <span class="Type">function</span>( code ) {
		<span class="Type">var</span> script,
			indirect <span class="Statement">=</span> <span class="Special">eval</span>;

		code <span class="Statement">=</span> jQuery.trim( code );

		<span class="Statement">if</span> ( code ) {
<span class="Comment">			// If the code includes a valid, prologue position</span>
<span class="Comment">			// strict mode pragma, execute code by injecting a</span>
<span class="Comment">			// script tag into the document.</span>
			<span class="Statement">if</span> ( code.indexOf(<span class="Constant">&quot;use strict&quot;</span>) <span class="Statement">===</span> <span class="Constant">1</span> ) {
				script <span class="Statement">=</span> <span class="Special">document</span>.createElement(<span class="Constant">&quot;script&quot;</span>);
				script.text <span class="Statement">=</span> code;
				<span class="Special">document</span>.head.appendChild( script ).parentNode.removeChild( script );
			} <span class="Statement">else</span> {
<span class="Comment">			// Otherwise, avoid the DOM node creation, insertion</span>
<span class="Comment">			// and removal by using an indirect global eval</span>
				indirect( code );
			}
		}
	},

<span class="Comment">	// Convert dashed to camelCase; used by the css and data modules</span>
<span class="Comment">	// Microsoft forgot to hump their vendor prefix (#9572)</span>
	camelCase: <span class="Type">function</span>( string ) {
		<span class="Statement">return</span> string.replace( rmsPrefix, <span class="Constant">&quot;ms-&quot;</span> ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: <span class="Type">function</span>( elem, name ) {
		<span class="Statement">return</span> elem.nodeName <span class="Statement">&amp;&amp;</span> elem.nodeName.toLowerCase() <span class="Statement">===</span> name.toLowerCase();
	},

<span class="Comment">	// args is for internal usage only</span>
	each: <span class="Type">function</span>( obj, callback, args ) {
		<span class="Type">var</span> value,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			length <span class="Statement">=</span> obj.length,
			isArray <span class="Statement">=</span> isArraylike( obj );

		<span class="Statement">if</span> ( args ) {
			<span class="Statement">if</span> ( isArray ) {
				<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i<span class="Statement">++</span> ) {
					value <span class="Statement">=</span> callback.apply( obj[ i ], args );

					<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Constant">false</span> ) {
						<span class="Statement">break</span>;
					}
				}
			} <span class="Statement">else</span> {
				<span class="Statement">for</span> ( i <span class="Statement">in</span> obj ) {
					value <span class="Statement">=</span> callback.apply( obj[ i ], args );

					<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Constant">false</span> ) {
						<span class="Statement">break</span>;
					}
				}
			}

<span class="Comment">		// A special, fast, case for the most common use of each</span>
		} <span class="Statement">else</span> {
			<span class="Statement">if</span> ( isArray ) {
				<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i<span class="Statement">++</span> ) {
					value <span class="Statement">=</span> callback.call( obj[ i ], i, obj[ i ] );

					<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Constant">false</span> ) {
						<span class="Statement">break</span>;
					}
				}
			} <span class="Statement">else</span> {
				<span class="Statement">for</span> ( i <span class="Statement">in</span> obj ) {
					value <span class="Statement">=</span> callback.call( obj[ i ], i, obj[ i ] );

					<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Constant">false</span> ) {
						<span class="Statement">break</span>;
					}
				}
			}
		}

		<span class="Statement">return</span> obj;
	},

	trim: <span class="Type">function</span>( text ) {
		<span class="Statement">return</span> text <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> trim.call( text );
	},

<span class="Comment">	// results is for internal usage only</span>
	makeArray: <span class="Type">function</span>( arr, results ) {
		<span class="Type">var</span> ret <span class="Statement">=</span> results <span class="Statement">||</span> [];

		<span class="Statement">if</span> ( arr <span class="Statement">!=</span> <span class="Type">null</span> ) {
			<span class="Statement">if</span> ( isArraylike( <span class="Special">Object</span>(arr) ) ) {
				jQuery.merge( ret,
					<span class="Statement">typeof</span> arr <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">?</span>
					[ arr ] <span class="Statement">:</span> arr
				);
			} <span class="Statement">else</span> {
				push.call( ret, arr );
			}
		}

		<span class="Statement">return</span> ret;
	},

	inArray: <span class="Type">function</span>( elem, arr, i ) {
		<span class="Statement">return</span> arr <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span> indexOf.call( arr, elem, i );
	},

	merge: <span class="Type">function</span>( first, second ) {
		<span class="Type">var</span> len <span class="Statement">=</span> <span class="Statement">+</span>second.length,
			j <span class="Statement">=</span> <span class="Constant">0</span>,
			i <span class="Statement">=</span> first.length;

		<span class="Statement">for</span> ( ; j <span class="Statement">&lt;</span> len; j<span class="Statement">++</span> ) {
			first[ i<span class="Statement">++</span> ] <span class="Statement">=</span> second[ j ];
		}

		first.length <span class="Statement">=</span> i;

		<span class="Statement">return</span> first;
	},

	grep: <span class="Type">function</span>( elems, callback, invert ) {
		<span class="Type">var</span> callbackInverse,
			matches <span class="Statement">=</span> [],
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			length <span class="Statement">=</span> elems.length,
			callbackExpect <span class="Statement">=</span> <span class="Statement">!</span>invert;

<span class="Comment">		// Go through the array, only saving the items</span>
<span class="Comment">		// that pass the validator function</span>
		<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i<span class="Statement">++</span> ) {
			callbackInverse <span class="Statement">=</span> <span class="Statement">!</span>callback( elems[ i ], i );
			<span class="Statement">if</span> ( callbackInverse <span class="Statement">!==</span> callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		<span class="Statement">return</span> matches;
	},

<span class="Comment">	// arg is for internal usage only</span>
	map: <span class="Type">function</span>( elems, callback, arg ) {
		<span class="Type">var</span> value,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			length <span class="Statement">=</span> elems.length,
			isArray <span class="Statement">=</span> isArraylike( elems ),
			ret <span class="Statement">=</span> [];

<span class="Comment">		// Go through the array, translating each of the items to their new values</span>
		<span class="Statement">if</span> ( isArray ) {
			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i<span class="Statement">++</span> ) {
				value <span class="Statement">=</span> callback( elems[ i ], i, arg );

				<span class="Statement">if</span> ( value <span class="Statement">!=</span> <span class="Type">null</span> ) {
					ret.push( value );
				}
			}

<span class="Comment">		// Go through every key on the object,</span>
		} <span class="Statement">else</span> {
			<span class="Statement">for</span> ( i <span class="Statement">in</span> elems ) {
				value <span class="Statement">=</span> callback( elems[ i ], i, arg );

				<span class="Statement">if</span> ( value <span class="Statement">!=</span> <span class="Type">null</span> ) {
					ret.push( value );
				}
			}
		}

<span class="Comment">		// Flatten any nested arrays</span>
		<span class="Statement">return</span> concat.apply( [], ret );
	},

<span class="Comment">	// A global GUID counter for objects</span>
	guid: <span class="Constant">1</span>,

<span class="Comment">	// Bind a function to a context, optionally partially applying any</span>
<span class="Comment">	// arguments.</span>
	proxy: <span class="Type">function</span>( fn, context ) {
		<span class="Type">var</span> tmp, args, proxy;

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> context <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			tmp <span class="Statement">=</span> fn[ context ];
			context <span class="Statement">=</span> fn;
			fn <span class="Statement">=</span> tmp;
		}

<span class="Comment">		// Quick check to determine if target is callable, in the spec</span>
<span class="Comment">		// this throws a TypeError, but we will just return undefined.</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.isFunction( fn ) ) {
			<span class="Statement">return</span> <span class="Type">undefined</span>;
		}

<span class="Comment">		// Simulated bind</span>
		args <span class="Statement">=</span> slice.call( arguments, <span class="Constant">2</span> );
		proxy <span class="Statement">=</span> <span class="Type">function</span>() {
			<span class="Statement">return</span> fn.apply( context <span class="Statement">||</span> <span class="Special">this</span>, args.concat( slice.call( arguments ) ) );
		};

<span class="Comment">		// Set the guid of unique handler to the same of original handler, so it can be removed</span>
		proxy.guid <span class="Statement">=</span> fn.guid <span class="Statement">=</span> fn.guid <span class="Statement">||</span> jQuery.guid<span class="Statement">++</span>;

		<span class="Statement">return</span> proxy;
	},

	now: <span class="Special">Date</span>.now,

<span class="Comment">	// jQuery.support is not used in Core but other projects attach their</span>
<span class="Comment">	// properties to it so it needs to exist.</span>
	support: support
});

<span class="Comment">// Populate the class2type map</span>
jQuery.each(<span class="Constant">&quot;Boolean Number String Function Array Date RegExp Object Error&quot;</span>.split(<span class="Constant">&quot; &quot;</span>), <span class="Type">function</span>(i, name) {
	class2type[ <span class="Constant">&quot;[object &quot;</span> <span class="Statement">+</span> name <span class="Statement">+</span> <span class="Constant">&quot;]&quot;</span> ] <span class="Statement">=</span> name.toLowerCase();
});

<span class="Type">function</span> <span class="Identifier">isArraylike</span>( obj ) {
	<span class="Type">var</span> length <span class="Statement">=</span> obj.length,
		type <span class="Statement">=</span> jQuery.type( obj );

	<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;function&quot;</span> <span class="Statement">||</span> jQuery.isWindow( obj ) ) {
		<span class="Statement">return</span> <span class="Constant">false</span>;
	}

	<span class="Statement">if</span> ( obj.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> length ) {
		<span class="Statement">return</span> <span class="Constant">true</span>;
	}

	<span class="Statement">return</span> type <span class="Statement">===</span> <span class="Constant">&quot;array&quot;</span> <span class="Statement">||</span> length <span class="Statement">===</span> <span class="Constant">0</span> <span class="Statement">||</span>
		<span class="Statement">typeof</span> length <span class="Statement">===</span> <span class="Constant">&quot;number&quot;</span> <span class="Statement">&amp;&amp;</span> length <span class="Statement">&gt;</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span> ( length <span class="Statement">-</span> <span class="Constant">1</span> ) <span class="Statement">in</span> obj;
}
<span class="Type">var</span> Sizzle <span class="Statement">=</span>
<span class="Comment">/*!</span>
<span class="Comment"> * Sizzle CSS Selector Engine v1.10.16</span>
<span class="Comment"> * <a href="http://sizzlejs.com/">http://sizzlejs.com/</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Copyright 2013 jQuery Foundation, Inc. and other contributors</span>
<span class="Comment"> * Released under the MIT license</span>
<span class="Comment"> * <a href="http://jquery.org/license">http://jquery.org/license</a></span>
<span class="Comment"> *</span>
<span class="Comment"> * Date: 2014-01-13</span>
<span class="Comment"> */</span>
(<span class="Type">function</span>( window ) {

<span class="Type">var</span> i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,
	hasDuplicate,

<span class="Comment">	// Local document vars</span>
	setDocument,
	<span class="Special">document</span>,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

<span class="Comment">	// Instance-specific data</span>
	expando <span class="Statement">=</span> <span class="Constant">&quot;sizzle&quot;</span> <span class="Statement">+</span> <span class="Statement">-</span>(<span class="Statement">new</span> <span class="Special">Date</span>()),
	preferredDoc <span class="Statement">=</span> <span class="Special">window</span>.<span class="Special">document</span>,
	dirruns <span class="Statement">=</span> <span class="Constant">0</span>,
	done <span class="Statement">=</span> <span class="Constant">0</span>,
	classCache <span class="Statement">=</span> createCache(),
	tokenCache <span class="Statement">=</span> createCache(),
	compilerCache <span class="Statement">=</span> createCache(),
	sortOrder <span class="Statement">=</span> <span class="Type">function</span>( a, b ) {
		<span class="Statement">if</span> ( a <span class="Statement">===</span> b ) {
			hasDuplicate <span class="Statement">=</span> <span class="Constant">true</span>;
		}
		<span class="Statement">return</span> <span class="Constant">0</span>;
	},

<span class="Comment">	// General-purpose constants</span>
	strundefined <span class="Statement">=</span> <span class="Statement">typeof</span> <span class="Type">undefined</span>,
	MAX_NEGATIVE <span class="Statement">=</span> <span class="Constant">1</span> <span class="Statement">&lt;&lt;</span> <span class="Constant">31</span>,

<span class="Comment">	// Instance methods</span>
	hasOwn <span class="Statement">=</span> ({}).hasOwnProperty,
	arr <span class="Statement">=</span> [],
	pop <span class="Statement">=</span> arr.pop,
	push_native <span class="Statement">=</span> arr.push,
	push <span class="Statement">=</span> arr.push,
	slice <span class="Statement">=</span> arr.slice,
<span class="Comment">	// Use a stripped-down indexOf if we can't use a native one</span>
	indexOf <span class="Statement">=</span> arr.indexOf <span class="Statement">||</span> <span class="Type">function</span>( elem ) {
		<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
			len <span class="Statement">=</span> <span class="Special">this</span>.length;
		<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>[i] <span class="Statement">===</span> elem ) {
				<span class="Statement">return</span> i;
			}
		}
		<span class="Statement">return</span> <span class="Statement">-</span><span class="Constant">1</span>;
	},

	booleans <span class="Statement">=</span> <span class="Constant">&quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;</span>,

<span class="Comment">	// Regular expressions</span>

<span class="Comment">	// Whitespace characters <a href="http://www.w3.org/TR/css3-selectors/#whitespace">http://www.w3.org/TR/css3-selectors/#whitespace</a></span>
	whitespace <span class="Statement">=</span> <span class="Constant">&quot;[</span><span class="Special">\\</span><span class="Constant">x20</span><span class="Special">\\</span><span class="Constant">t</span><span class="Special">\\</span><span class="Constant">r</span><span class="Special">\\</span><span class="Constant">n</span><span class="Special">\\</span><span class="Constant">f]&quot;</span>,
<span class="Comment">	// <a href="http://www.w3.org/TR/css3-syntax/#characters">http://www.w3.org/TR/css3-syntax/#characters</a></span>
	characterEncoding <span class="Statement">=</span> <span class="Constant">&quot;(?:</span><span class="Special">\\\\</span><span class="Constant">.|[</span><span class="Special">\\</span><span class="Constant">w-]|[^</span><span class="Special">\\</span><span class="Constant">x00-</span><span class="Special">\\</span><span class="Constant">xa0])+&quot;</span>,

<span class="Comment">	// Loosely modeled on CSS identifier characters</span>
<span class="Comment">	// An unquoted value should be a CSS identifier <a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">http://www.w3.org/TR/css3-selectors/#attribute-selectors</a></span>
<span class="Comment">	// Proper syntax: <a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</a></span>
	identifier <span class="Statement">=</span> characterEncoding.replace( <span class="Constant">&quot;w&quot;</span>, <span class="Constant">&quot;w#&quot;</span> ),

<span class="Comment">	// Acceptable operators <a href="http://www.w3.org/TR/selectors/#attribute-selectors">http://www.w3.org/TR/selectors/#attribute-selectors</a></span>
	attributes <span class="Statement">=</span> <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">[&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*(&quot;</span> <span class="Statement">+</span> characterEncoding <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span>
		<span class="Constant">&quot;*(?:([*^$|!~]?=)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*(?:(['</span><span class="Special">\&quot;</span><span class="Constant">])((?:</span><span class="Special">\\\\</span><span class="Constant">.|[^</span><span class="Special">\\\\</span><span class="Constant">])*?)</span><span class="Special">\\</span><span class="Constant">3|(&quot;</span> <span class="Statement">+</span> identifier <span class="Statement">+</span> <span class="Constant">&quot;)|)|)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*</span><span class="Special">\\</span><span class="Constant">]&quot;</span>,

<span class="Comment">	// Prefer arguments quoted,</span>
<span class="Comment">	//   then not containing pseudos/brackets,</span>
<span class="Comment">	//   then attribute selectors/non-parenthetical expressions,</span>
<span class="Comment">	//   then anything else</span>
<span class="Comment">	// These preferences are here to reduce the number of selectors</span>
<span class="Comment">	//   needing tokenize in the PSEUDO preFilter</span>
	pseudos <span class="Statement">=</span> <span class="Constant">&quot;:(&quot;</span> <span class="Statement">+</span> characterEncoding <span class="Statement">+</span> <span class="Constant">&quot;)(?:</span><span class="Special">\\</span><span class="Constant">(((['</span><span class="Special">\&quot;</span><span class="Constant">])((?:</span><span class="Special">\\\\</span><span class="Constant">.|[^</span><span class="Special">\\\\</span><span class="Constant">])*?)</span><span class="Special">\\</span><span class="Constant">3|((?:</span><span class="Special">\\\\</span><span class="Constant">.|[^</span><span class="Special">\\\\</span><span class="Constant">()[</span><span class="Special">\\</span><span class="Constant">]]|&quot;</span> <span class="Statement">+</span> attributes.replace( <span class="Constant">3</span>, <span class="Constant">8</span> ) <span class="Statement">+</span> <span class="Constant">&quot;)*)|.*)</span><span class="Special">\\</span><span class="Constant">)|)&quot;</span>,

<span class="Comment">	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</span>
	rtrim <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;+|((?:^|[^</span><span class="Special">\\\\</span><span class="Constant">])(?:</span><span class="Special">\\\\</span><span class="Constant">.)*)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;+$&quot;</span>, <span class="Constant">&quot;g&quot;</span> ),

	rcomma <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*,&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*&quot;</span> ),
	rcombinators <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*([&gt;+~]|&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*&quot;</span> ),

	rattributeQuotes <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;=&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*([^</span><span class="Special">\\</span><span class="Constant">]'</span><span class="Special">\&quot;</span><span class="Constant">]*?)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*</span><span class="Special">\\</span><span class="Constant">]&quot;</span>, <span class="Constant">&quot;g&quot;</span> ),

	rpseudo <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( pseudos ),
	ridentifier <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> identifier <span class="Statement">+</span> <span class="Constant">&quot;$&quot;</span> ),

	matchExpr <span class="Statement">=</span> {
		<span class="Constant">&quot;ID&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^#(&quot;</span> <span class="Statement">+</span> characterEncoding <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> ),
		<span class="Constant">&quot;CLASS&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^</span><span class="Special">\\</span><span class="Constant">.(&quot;</span> <span class="Statement">+</span> characterEncoding <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> ),
		<span class="Constant">&quot;TAG&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^(&quot;</span> <span class="Statement">+</span> characterEncoding.replace( <span class="Constant">&quot;w&quot;</span>, <span class="Constant">&quot;w*&quot;</span> ) <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> ),
		<span class="Constant">&quot;ATTR&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> attributes ),
		<span class="Constant">&quot;PSEUDO&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> pseudos ),
		<span class="Constant">&quot;CHILD&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:</span><span class="Special">\\</span><span class="Constant">(&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span>
			<span class="Constant">&quot;*(even|odd|(([+-]|)(</span><span class="Special">\\</span><span class="Constant">d*)n|)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*(?:([+-]|)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span>
			<span class="Constant">&quot;*(</span><span class="Special">\\</span><span class="Constant">d+)|))&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*</span><span class="Special">\\</span><span class="Constant">)|)&quot;</span>, <span class="Constant">&quot;i&quot;</span> ),
		<span class="Constant">&quot;bool&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^(?:&quot;</span> <span class="Statement">+</span> booleans <span class="Statement">+</span> <span class="Constant">&quot;)$&quot;</span>, <span class="Constant">&quot;i&quot;</span> ),
<span class="Comment">		// For use in libraries implementing .is()</span>
<span class="Comment">		// We use this for POS matching in `select`</span>
		<span class="Constant">&quot;needsContext&quot;</span>: <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:</span><span class="Special">\\</span><span class="Constant">(&quot;</span> <span class="Statement">+</span>
			whitespace <span class="Statement">+</span> <span class="Constant">&quot;*((?:-</span><span class="Special">\\</span><span class="Constant">d)?</span><span class="Special">\\</span><span class="Constant">d*)&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*</span><span class="Special">\\</span><span class="Constant">)|)(?=[^-]|$)&quot;</span>, <span class="Constant">&quot;i&quot;</span> )
	},

	rinputs <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">input</span><span class="Statement">|</span><span class="Constant">select</span><span class="Statement">|</span><span class="Constant">textarea</span><span class="Statement">|</span><span class="Constant">button)</span><span class="Special">$</span><span class="Constant">/i</span>,
	rheader <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">h</span><span class="Special">\d</span><span class="Special">$</span><span class="Constant">/i</span>,

	rnative <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">[^{]</span><span class="Special">+</span><span class="Special">\{\s</span><span class="Special">*</span><span class="Special">\[</span><span class="Constant">native </span><span class="Special">\w</span><span class="Constant">/</span>,

<span class="Comment">	// Easily-parseable/retrievable ID or TAG or CLASS selectors</span>
	rquickExpr <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">#(</span><span class="Constant">[\w-]</span><span class="Special">+</span><span class="Constant">)</span><span class="Statement">|</span><span class="Constant">(</span><span class="Special">\w</span><span class="Special">+</span><span class="Constant">)</span><span class="Statement">|</span><span class="Special">\.</span><span class="Constant">(</span><span class="Constant">[\w-]</span><span class="Special">+</span><span class="Constant">)</span><span class="Constant">)</span><span class="Special">$</span><span class="Constant">/</span>,

	rsibling <span class="Statement">=</span> <span class="Constant">/</span><span class="Constant">[+~]</span><span class="Constant">/</span>,
	rescape <span class="Statement">=</span> <span class="Constant">/'</span><span class="Statement">|</span><span class="Special">\\</span><span class="Constant">/g</span>,

<span class="Comment">	// CSS escapes <a href="http://www.w3.org/TR/CSS21/syndata.html#escaped-characters">http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</a></span>
	runescape <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;</span><span class="Special">\\\\</span><span class="Constant">([</span><span class="Special">\\</span><span class="Constant">da-f]{1,6}&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;?|(&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;)|.)&quot;</span>, <span class="Constant">&quot;ig&quot;</span> ),
	funescape <span class="Statement">=</span> <span class="Type">function</span>( _, escaped, escapedWhitespace ) {
		<span class="Type">var</span> high <span class="Statement">=</span> <span class="Constant">&quot;0x&quot;</span> <span class="Statement">+</span> escaped <span class="Statement">-</span> <span class="Constant">0x10000</span>;
<span class="Comment">		// NaN means non-codepoint</span>
<span class="Comment">		// Support: Firefox</span>
<span class="Comment">		// Workaround erroneous numeric interpretation of +&quot;0x&quot;</span>
		<span class="Statement">return</span> high <span class="Statement">!==</span> high <span class="Statement">||</span> escapedWhitespace <span class="Statement">?</span>
			escaped <span class="Statement">:</span>
			high <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span>
<span class="Comment">				// BMP codepoint</span>
				<span class="Special">String</span>.fromCharCode( high <span class="Statement">+</span> <span class="Constant">0x10000</span> ) <span class="Statement">:</span>
<span class="Comment">				// Supplemental Plane codepoint (surrogate pair)</span>
				<span class="Special">String</span>.fromCharCode( high <span class="Statement">&gt;&gt;</span> <span class="Constant">10</span> <span class="Statement">|</span> <span class="Constant">0xD800</span>, high <span class="Statement">&amp;</span> <span class="Constant">0x3FF</span> <span class="Statement">|</span> <span class="Constant">0xDC00</span> );
	};

<span class="Comment">// Optimize for push.apply( _, NodeList )</span>
<span class="Statement">try</span> {
	push.apply(
		(arr <span class="Statement">=</span> slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
<span class="Comment">	// Support: Android&lt;4.0</span>
<span class="Comment">	// Detect silently failing push.apply</span>
	arr[ preferredDoc.childNodes.length ].nodeType;
} <span class="Statement">catch</span> ( e ) {
	push <span class="Statement">=</span> { apply: arr.length <span class="Statement">?</span>

<span class="Comment">		// Leverage slice if possible</span>
		<span class="Type">function</span>( target, els ) {
			push_native.apply( target, slice.call(els) );
		} <span class="Statement">:</span>

<span class="Comment">		// Support: IE&lt;9</span>
<span class="Comment">		// Otherwise append directly</span>
		<span class="Type">function</span>( target, els ) {
			<span class="Type">var</span> j <span class="Statement">=</span> target.length,
				i <span class="Statement">=</span> <span class="Constant">0</span>;
<span class="Comment">			// Can't trust NodeList.length</span>
			<span class="Statement">while</span> ( (target[j<span class="Statement">++</span>] <span class="Statement">=</span> els[i<span class="Statement">++</span>]) ) {}
			target.length <span class="Statement">=</span> j <span class="Statement">-</span> <span class="Constant">1</span>;
		}
	};
}

<span class="Type">function</span> <span class="Identifier">Sizzle</span>( selector, context, results, seed ) {
	<span class="Type">var</span> match, elem, m, nodeType,
<span class="Comment">		// QSA vars</span>
		i, groups, old, nid, newContext, newSelector;

	<span class="Statement">if</span> ( ( context <span class="Statement">?</span> context.ownerDocument <span class="Statement">||</span> context <span class="Statement">:</span> preferredDoc ) <span class="Statement">!==</span> <span class="Special">document</span> ) {
		setDocument( context );
	}

	context <span class="Statement">=</span> context <span class="Statement">||</span> <span class="Special">document</span>;
	results <span class="Statement">=</span> results <span class="Statement">||</span> [];

	<span class="Statement">if</span> ( <span class="Statement">!</span>selector <span class="Statement">||</span> <span class="Statement">typeof</span> selector <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
		<span class="Statement">return</span> results;
	}

	<span class="Statement">if</span> ( (nodeType <span class="Statement">=</span> context.nodeType) <span class="Statement">!==</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> nodeType <span class="Statement">!==</span> <span class="Constant">9</span> ) {
		<span class="Statement">return</span> [];
	}

	<span class="Statement">if</span> ( documentIsHTML <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>seed ) {

<span class="Comment">		// Shortcuts</span>
		<span class="Statement">if</span> ( (match <span class="Statement">=</span> rquickExpr.exec( selector )) ) {
<span class="Comment">			// Speed-up: Sizzle(&quot;#ID&quot;)</span>
			<span class="Statement">if</span> ( (m <span class="Statement">=</span> match[<span class="Constant">1</span>]) ) {
				<span class="Statement">if</span> ( nodeType <span class="Statement">===</span> <span class="Constant">9</span> ) {
					elem <span class="Statement">=</span> context.getElementById( m );
<span class="Comment">					// Check parentNode to catch when Blackberry 4.6 returns</span>
<span class="Comment">					// nodes that are no longer in the document (jQuery #6963)</span>
					<span class="Statement">if</span> ( elem <span class="Statement">&amp;&amp;</span> elem.parentNode ) {
<span class="Comment">						// Handle the case where IE, Opera, and Webkit return items</span>
<span class="Comment">						// by name instead of ID</span>
						<span class="Statement">if</span> ( elem.id <span class="Statement">===</span> m ) {
							results.push( elem );
							<span class="Statement">return</span> results;
						}
					} <span class="Statement">else</span> {
						<span class="Statement">return</span> results;
					}
				} <span class="Statement">else</span> {
<span class="Comment">					// Context is not a document</span>
					<span class="Statement">if</span> ( context.ownerDocument <span class="Statement">&amp;&amp;</span> (elem <span class="Statement">=</span> context.ownerDocument.getElementById( m )) <span class="Statement">&amp;&amp;</span>
						contains( context, elem ) <span class="Statement">&amp;&amp;</span> elem.id <span class="Statement">===</span> m ) {
						results.push( elem );
						<span class="Statement">return</span> results;
					}
				}

<span class="Comment">			// Speed-up: Sizzle(&quot;TAG&quot;)</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( match[<span class="Constant">2</span>] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				<span class="Statement">return</span> results;

<span class="Comment">			// Speed-up: Sizzle(&quot;.CLASS&quot;)</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( (m <span class="Statement">=</span> match[<span class="Constant">3</span>]) <span class="Statement">&amp;&amp;</span> support.getElementsByClassName <span class="Statement">&amp;&amp;</span> context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				<span class="Statement">return</span> results;
			}
		}

<span class="Comment">		// QSA path</span>
		<span class="Statement">if</span> ( support.qsa <span class="Statement">&amp;&amp;</span> (<span class="Statement">!</span>rbuggyQSA <span class="Statement">||</span> <span class="Statement">!</span>rbuggyQSA.test( selector )) ) {
			nid <span class="Statement">=</span> old <span class="Statement">=</span> expando;
			newContext <span class="Statement">=</span> context;
			newSelector <span class="Statement">=</span> nodeType <span class="Statement">===</span> <span class="Constant">9</span> <span class="Statement">&amp;&amp;</span> selector;

<span class="Comment">			// qSA works strangely on Element-rooted queries</span>
<span class="Comment">			// We can work around this by specifying an extra ID on the root</span>
<span class="Comment">			// and working up from there (Thanks to Andrew Dupont for the technique)</span>
<span class="Comment">			// IE 8 doesn't work on object elements</span>
			<span class="Statement">if</span> ( nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> context.nodeName.toLowerCase() <span class="Statement">!==</span> <span class="Constant">&quot;object&quot;</span> ) {
				groups <span class="Statement">=</span> tokenize( selector );

				<span class="Statement">if</span> ( (old <span class="Statement">=</span> context.getAttribute(<span class="Constant">&quot;id&quot;</span>)) ) {
					nid <span class="Statement">=</span> old.replace( rescape, <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">$&amp;&quot;</span> );
				} <span class="Statement">else</span> {
					context.setAttribute( <span class="Constant">&quot;id&quot;</span>, nid );
				}
				nid <span class="Statement">=</span> <span class="Constant">&quot;[id='&quot;</span> <span class="Statement">+</span> nid <span class="Statement">+</span> <span class="Constant">&quot;'] &quot;</span>;

				i <span class="Statement">=</span> groups.length;
				<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
					groups[i] <span class="Statement">=</span> nid <span class="Statement">+</span> toSelector( groups[i] );
				}
				newContext <span class="Statement">=</span> rsibling.test( selector ) <span class="Statement">&amp;&amp;</span> testContext( context.parentNode ) <span class="Statement">||</span> context;
				newSelector <span class="Statement">=</span> groups.join(<span class="Constant">&quot;,&quot;</span>);
			}

			<span class="Statement">if</span> ( newSelector ) {
				<span class="Statement">try</span> {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					<span class="Statement">return</span> results;
				} <span class="Statement">catch</span>(qsaError) {
				} <span class="Statement">finally</span> {
					<span class="Statement">if</span> ( <span class="Statement">!</span>old ) {
						context.removeAttribute(<span class="Constant">&quot;id&quot;</span>);
					}
				}
			}
		}
	}

<span class="Comment">	// All others</span>
	<span class="Statement">return</span> select( selector.replace( rtrim, <span class="Constant">&quot;$1&quot;</span> ), context, results, seed );
}

<span class="Comment">/**</span>
<span class="Comment"> * Create key-value caches of limited size</span>
<span class="Comment"> * </span><span class="Special">@returns</span><span class="Comment"> </span><span class="Type">{Function(string, Object)}</span><span class="Comment"> Returns the Object data after storing it on itself with</span>
<span class="Comment"> *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)</span>
<span class="Comment"> *	deleting the oldest entry</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">createCache</span>() {
	<span class="Type">var</span> keys <span class="Statement">=</span> [];

	<span class="Type">function</span> <span class="Identifier">cache</span>( key, value ) {
<span class="Comment">		// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)</span>
		<span class="Statement">if</span> ( keys.push( key <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ) <span class="Statement">&gt;</span> Expr.cacheLength ) {
<span class="Comment">			// Only keep the most recent entries</span>
			<span class="Statement">delete</span> cache[ keys.shift() ];
		}
		<span class="Statement">return</span> (cache[ key <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ] <span class="Statement">=</span> value);
	}
	<span class="Statement">return</span> cache;
}

<span class="Comment">/**</span>
<span class="Comment"> * Mark a function for special use by Sizzle</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Function}</span><span class="Comment"> </span><span class="Statement">fn</span><span class="Comment"> The function to mark</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">markFunction</span>( fn ) {
	fn[ expando ] <span class="Statement">=</span> <span class="Constant">true</span>;
	<span class="Statement">return</span> fn;
}

<span class="Comment">/**</span>
<span class="Comment"> * Support testing using an element</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Function}</span><span class="Comment"> </span><span class="Statement">fn</span><span class="Comment"> Passed the created div and expects a boolean result</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">assert</span>( fn ) {
	<span class="Type">var</span> div <span class="Statement">=</span> <span class="Special">document</span>.createElement(<span class="Constant">&quot;div&quot;</span>);

	<span class="Statement">try</span> {
		<span class="Statement">return</span> <span class="Statement">!!</span>fn( div );
	} <span class="Statement">catch</span> (e) {
		<span class="Statement">return</span> <span class="Constant">false</span>;
	} <span class="Statement">finally</span> {
<span class="Comment">		// Remove from its parent by default</span>
		<span class="Statement">if</span> ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
<span class="Comment">		// release memory in IE</span>
		div <span class="Statement">=</span> <span class="Type">null</span>;
	}
}

<span class="Comment">/**</span>
<span class="Comment"> * Adds the same handler for all of the specified attrs</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{String}</span><span class="Comment"> </span><span class="Statement">attrs</span><span class="Comment"> Pipe-separated list of attributes</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Function}</span><span class="Comment"> </span><span class="Statement">handler</span><span class="Comment"> The method that will be applied</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">addHandle</span>( attrs, handler ) {
	<span class="Type">var</span> arr <span class="Statement">=</span> attrs.split(<span class="Constant">&quot;|&quot;</span>),
		i <span class="Statement">=</span> attrs.length;

	<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
		Expr.attrHandle[ arr[i] ] <span class="Statement">=</span> handler;
	}
}

<span class="Comment">/**</span>
<span class="Comment"> * Checks document order of two siblings</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Element}</span><span class="Comment"> </span><span class="Statement">a</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Element}</span><span class="Comment"> </span><span class="Statement">b</span>
<span class="Comment"> * </span><span class="Special">@returns</span><span class="Comment"> </span><span class="Type">{Number}</span><span class="Comment"> Returns less than 0 if a precedes b, greater than 0 if a follows b</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">siblingCheck</span>( a, b ) {
	<span class="Type">var</span> cur <span class="Statement">=</span> b <span class="Statement">&amp;&amp;</span> a,
		diff <span class="Statement">=</span> cur <span class="Statement">&amp;&amp;</span> a.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> b.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span>
			( <span class="Statement">~</span>b.sourceIndex <span class="Statement">||</span> MAX_NEGATIVE ) <span class="Statement">-</span>
			( <span class="Statement">~</span>a.sourceIndex <span class="Statement">||</span> MAX_NEGATIVE );

<span class="Comment">	// Use IE sourceIndex if available on both nodes</span>
	<span class="Statement">if</span> ( diff ) {
		<span class="Statement">return</span> diff;
	}

<span class="Comment">	// Check if b follows a</span>
	<span class="Statement">if</span> ( cur ) {
		<span class="Statement">while</span> ( (cur <span class="Statement">=</span> cur.nextSibling) ) {
			<span class="Statement">if</span> ( cur <span class="Statement">===</span> b ) {
				<span class="Statement">return</span> <span class="Statement">-</span><span class="Constant">1</span>;
			}
		}
	}

	<span class="Statement">return</span> a <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Statement">-</span><span class="Constant">1</span>;
}

<span class="Comment">/**</span>
<span class="Comment"> * Returns a function to use in pseudos for input types</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{String}</span><span class="Comment"> </span><span class="Statement">type</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">createInputPseudo</span>( type ) {
	<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
		<span class="Type">var</span> name <span class="Statement">=</span> elem.nodeName.toLowerCase();
		<span class="Statement">return</span> name <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">&amp;&amp;</span> elem.type <span class="Statement">===</span> type;
	};
}

<span class="Comment">/**</span>
<span class="Comment"> * Returns a function to use in pseudos for buttons</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{String}</span><span class="Comment"> </span><span class="Statement">type</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">createButtonPseudo</span>( type ) {
	<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
		<span class="Type">var</span> name <span class="Statement">=</span> elem.nodeName.toLowerCase();
		<span class="Statement">return</span> (name <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">||</span> name <span class="Statement">===</span> <span class="Constant">&quot;button&quot;</span>) <span class="Statement">&amp;&amp;</span> elem.type <span class="Statement">===</span> type;
	};
}

<span class="Comment">/**</span>
<span class="Comment"> * Returns a function to use in pseudos for positionals</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Function}</span><span class="Comment"> </span><span class="Statement">fn</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">createPositionalPseudo</span>( fn ) {
	<span class="Statement">return</span> markFunction(<span class="Type">function</span>( argument ) {
		argument <span class="Statement">=</span> <span class="Statement">+</span>argument;
		<span class="Statement">return</span> markFunction(<span class="Type">function</span>( seed, matches ) {
			<span class="Type">var</span> j,
				matchIndexes <span class="Statement">=</span> fn( [], seed.length, argument ),
				i <span class="Statement">=</span> matchIndexes.length;

<span class="Comment">			// Match elements found at the specified indexes</span>
			<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
				<span class="Statement">if</span> ( seed[ (j <span class="Statement">=</span> matchIndexes[i]) ] ) {
					seed[j] <span class="Statement">=</span> <span class="Statement">!</span>(matches[j] <span class="Statement">=</span> seed[j]);
				}
			}
		});
	});
}

<span class="Comment">/**</span>
<span class="Comment"> * Checks a node for validity as a Sizzle context</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Element|Object=}</span><span class="Comment"> </span><span class="Statement">context</span>
<span class="Comment"> * </span><span class="Special">@returns</span><span class="Comment"> </span><span class="Type">{Element|Object|Boolean}</span><span class="Comment"> The input node if acceptable, otherwise a falsy value</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">testContext</span>( context ) {
	<span class="Statement">return</span> context <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> context.getElementsByTagName <span class="Statement">!==</span> strundefined <span class="Statement">&amp;&amp;</span> context;
}

<span class="Comment">// Expose support vars for convenience</span>
support <span class="Statement">=</span> Sizzle.support <span class="Statement">=</span> {};

<span class="Comment">/**</span>
<span class="Comment"> * Detects XML nodes</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Element|Object}</span><span class="Comment"> </span><span class="Statement">elem</span><span class="Comment"> An element or a document</span>
<span class="Comment"> * </span><span class="Special">@returns</span><span class="Comment"> </span><span class="Type">{Boolean}</span><span class="Comment"> True iff elem is a non-HTML XML node</span>
<span class="Comment"> </span><span class="Comment">*/</span>
isXML <span class="Statement">=</span> Sizzle.isXML <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
<span class="Comment">	// documentElement is verified for cases where it doesn't yet exist</span>
<span class="Comment">	// (such as loading iframes in IE - #4833)</span>
	<span class="Type">var</span> documentElement <span class="Statement">=</span> elem <span class="Statement">&amp;&amp;</span> (elem.ownerDocument <span class="Statement">||</span> elem).documentElement;
	<span class="Statement">return</span> documentElement <span class="Statement">?</span> documentElement.nodeName <span class="Statement">!==</span> <span class="Constant">&quot;HTML&quot;</span> <span class="Statement">:</span> <span class="Constant">false</span>;
};

<span class="Comment">/**</span>
<span class="Comment"> * Sets document-related variables once based on the current document</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Element|Object}</span><span class="Comment"> [doc] An element or document object to use to set the document</span>
<span class="Comment"> * </span><span class="Special">@returns</span><span class="Comment"> </span><span class="Type">{Object}</span><span class="Comment"> Returns the current document</span>
<span class="Comment"> </span><span class="Comment">*/</span>
setDocument <span class="Statement">=</span> Sizzle.setDocument <span class="Statement">=</span> <span class="Type">function</span>( node ) {
	<span class="Type">var</span> hasCompare,
		doc <span class="Statement">=</span> node <span class="Statement">?</span> node.ownerDocument <span class="Statement">||</span> node <span class="Statement">:</span> preferredDoc,
		parent <span class="Statement">=</span> doc.defaultView;

<span class="Comment">	// If no document and documentElement is available, return</span>
	<span class="Statement">if</span> ( doc <span class="Statement">===</span> <span class="Special">document</span> <span class="Statement">||</span> doc.nodeType <span class="Statement">!==</span> <span class="Constant">9</span> <span class="Statement">||</span> <span class="Statement">!</span>doc.documentElement ) {
		<span class="Statement">return</span> <span class="Special">document</span>;
	}

<span class="Comment">	// Set our document</span>
	<span class="Special">document</span> <span class="Statement">=</span> doc;
	docElem <span class="Statement">=</span> doc.documentElement;

<span class="Comment">	// Support tests</span>
	documentIsHTML <span class="Statement">=</span> <span class="Statement">!</span>isXML( doc );

<span class="Comment">	// Support: IE&gt;8</span>
<span class="Comment">	// If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,</span>
<span class="Comment">	// IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936</span>
<span class="Comment">	// IE6-8 do not support the defaultView property so parent will be undefined</span>
	<span class="Statement">if</span> ( parent <span class="Statement">&amp;&amp;</span> parent <span class="Statement">!==</span> parent.top ) {
<span class="Comment">		// IE11 does not have attachEvent, so all must suffer</span>
		<span class="Statement">if</span> ( parent.addEventListener ) {
			parent.addEventListener( <span class="Constant">&quot;unload&quot;</span>, <span class="Type">function</span>() {
				setDocument();
			}, <span class="Constant">false</span> );
		} <span class="Statement">else</span> <span class="Statement">if</span> ( parent.attachEvent ) {
			parent.attachEvent( <span class="Constant">&quot;onunload&quot;</span>, <span class="Type">function</span>() {
				setDocument();
			});
		}
	}

	<span class="Comment">/* Attributes</span>
<span class="Comment">	---------------------------------------------------------------------- */</span>

<span class="Comment">	// Support: IE&lt;8</span>
<span class="Comment">	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)</span>
	support.attributes <span class="Statement">=</span> assert(<span class="Type">function</span>( div ) {
		div.className <span class="Statement">=</span> <span class="Constant">&quot;i&quot;</span>;
		<span class="Statement">return</span> <span class="Statement">!</span>div.getAttribute(<span class="Constant">&quot;className&quot;</span>);
	});

	<span class="Comment">/* getElement(s)By*</span>
<span class="Comment">	---------------------------------------------------------------------- */</span>

<span class="Comment">	// Check if getElementsByTagName(&quot;*&quot;) returns only elements</span>
	support.getElementsByTagName <span class="Statement">=</span> assert(<span class="Type">function</span>( div ) {
		div.appendChild( doc.createComment(<span class="Constant">&quot;&quot;</span>) );
		<span class="Statement">return</span> <span class="Statement">!</span>div.getElementsByTagName(<span class="Constant">&quot;*&quot;</span>).length;
	});

<span class="Comment">	// Check if getElementsByClassName can be trusted</span>
	support.getElementsByClassName <span class="Statement">=</span> rnative.test( doc.getElementsByClassName ) <span class="Statement">&amp;&amp;</span> assert(<span class="Type">function</span>( div ) {
		div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&lt;div class='a'&gt;&lt;/div&gt;&lt;div class='a i'&gt;&lt;/div&gt;&quot;</span>;

<span class="Comment">		// Support: Safari&lt;4</span>
<span class="Comment">		// Catch class over-caching</span>
		div.firstChild.className <span class="Statement">=</span> <span class="Constant">&quot;i&quot;</span>;
<span class="Comment">		// Support: Opera&lt;10</span>
<span class="Comment">		// Catch gEBCN failure to find non-leading classes</span>
		<span class="Statement">return</span> div.getElementsByClassName(<span class="Constant">&quot;i&quot;</span>).length <span class="Statement">===</span> <span class="Constant">2</span>;
	});

<span class="Comment">	// Support: IE&lt;10</span>
<span class="Comment">	// Check if getElementById returns elements by name</span>
<span class="Comment">	// The broken getElementById methods don't pick up programatically-set names,</span>
<span class="Comment">	// so use a roundabout getElementsByName test</span>
	support.getById <span class="Statement">=</span> assert(<span class="Type">function</span>( div ) {
		docElem.appendChild( div ).id <span class="Statement">=</span> expando;
		<span class="Statement">return</span> <span class="Statement">!</span>doc.getElementsByName <span class="Statement">||</span> <span class="Statement">!</span>doc.getElementsByName( expando ).length;
	});

<span class="Comment">	// ID find and filter</span>
	<span class="Statement">if</span> ( support.getById ) {
		Expr.find[<span class="Constant">&quot;ID&quot;</span>] <span class="Statement">=</span> <span class="Type">function</span>( id, context ) {
			<span class="Statement">if</span> ( <span class="Statement">typeof</span> context.getElementById <span class="Statement">!==</span> strundefined <span class="Statement">&amp;&amp;</span> documentIsHTML ) {
				<span class="Type">var</span> m <span class="Statement">=</span> context.getElementById( id );
<span class="Comment">				// Check parentNode to catch when Blackberry 4.6 returns</span>
<span class="Comment">				// nodes that are no longer in the document #6963</span>
				<span class="Statement">return</span> m <span class="Statement">&amp;&amp;</span> m.parentNode <span class="Statement">?</span> [m] <span class="Statement">:</span> [];
			}
		};
		Expr.filter[<span class="Constant">&quot;ID&quot;</span>] <span class="Statement">=</span> <span class="Type">function</span>( id ) {
			<span class="Type">var</span> attrId <span class="Statement">=</span> id.replace( runescape, funescape );
			<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
				<span class="Statement">return</span> elem.getAttribute(<span class="Constant">&quot;id&quot;</span>) <span class="Statement">===</span> attrId;
			};
		};
	} <span class="Statement">else</span> {
<span class="Comment">		// Support: IE6/7</span>
<span class="Comment">		// getElementById is not reliable as a find shortcut</span>
		<span class="Statement">delete</span> Expr.find[<span class="Constant">&quot;ID&quot;</span>];

		Expr.filter[<span class="Constant">&quot;ID&quot;</span>] <span class="Statement">=</span>  <span class="Type">function</span>( id ) {
			<span class="Type">var</span> attrId <span class="Statement">=</span> id.replace( runescape, funescape );
			<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
				<span class="Type">var</span> node <span class="Statement">=</span> <span class="Statement">typeof</span> elem.getAttributeNode <span class="Statement">!==</span> strundefined <span class="Statement">&amp;&amp;</span> elem.getAttributeNode(<span class="Constant">&quot;id&quot;</span>);
				<span class="Statement">return</span> node <span class="Statement">&amp;&amp;</span> node.value <span class="Statement">===</span> attrId;
			};
		};
	}

<span class="Comment">	// Tag</span>
	Expr.find[<span class="Constant">&quot;TAG&quot;</span>] <span class="Statement">=</span> support.getElementsByTagName <span class="Statement">?</span>
		<span class="Type">function</span>( tag, context ) {
			<span class="Statement">if</span> ( <span class="Statement">typeof</span> context.getElementsByTagName <span class="Statement">!==</span> strundefined ) {
				<span class="Statement">return</span> context.getElementsByTagName( tag );
			}
		} <span class="Statement">:</span>
		<span class="Type">function</span>( tag, context ) {
			<span class="Type">var</span> elem,
				tmp <span class="Statement">=</span> [],
				i <span class="Statement">=</span> <span class="Constant">0</span>,
				results <span class="Statement">=</span> context.getElementsByTagName( tag );

<span class="Comment">			// Filter out possible comments</span>
			<span class="Statement">if</span> ( tag <span class="Statement">===</span> <span class="Constant">&quot;*&quot;</span> ) {
				<span class="Statement">while</span> ( (elem <span class="Statement">=</span> results[i<span class="Statement">++</span>]) ) {
					<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
						tmp.push( elem );
					}
				}

				<span class="Statement">return</span> tmp;
			}
			<span class="Statement">return</span> results;
		};

<span class="Comment">	// Class</span>
	Expr.find[<span class="Constant">&quot;CLASS&quot;</span>] <span class="Statement">=</span> support.getElementsByClassName <span class="Statement">&amp;&amp;</span> <span class="Type">function</span>( className, context ) {
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> context.getElementsByClassName <span class="Statement">!==</span> strundefined <span class="Statement">&amp;&amp;</span> documentIsHTML ) {
			<span class="Statement">return</span> context.getElementsByClassName( className );
		}
	};

	<span class="Comment">/* QSA/matchesSelector</span>
<span class="Comment">	---------------------------------------------------------------------- */</span>

<span class="Comment">	// QSA and matchesSelector support</span>

<span class="Comment">	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)</span>
	rbuggyMatches <span class="Statement">=</span> [];

<span class="Comment">	// qSa(:focus) reports false when true (Chrome 21)</span>
<span class="Comment">	// We allow this because of a bug in IE8/9 that throws an error</span>
<span class="Comment">	// whenever `document.activeElement` is accessed on an iframe</span>
<span class="Comment">	// So, we allow :focus to pass through QSA all the time to avoid the IE error</span>
<span class="Comment">	// See <a href="http://bugs.jquery.com/ticket/13378">http://bugs.jquery.com/ticket/13378</a></span>
	rbuggyQSA <span class="Statement">=</span> [];

	<span class="Statement">if</span> ( (support.qsa <span class="Statement">=</span> rnative.test( doc.querySelectorAll )) ) {
<span class="Comment">		// Build QSA regex</span>
<span class="Comment">		// Regex strategy adopted from Diego Perini</span>
		assert(<span class="Type">function</span>( div ) {
<span class="Comment">			// Select is set to empty string on purpose</span>
<span class="Comment">			// This is to test IE's treatment of not explicitly</span>
<span class="Comment">			// setting a boolean content attribute,</span>
<span class="Comment">			// since its presence should be enough</span>
<span class="Comment">			// <a href="http://bugs.jquery.com/ticket/12359">http://bugs.jquery.com/ticket/12359</a></span>
			div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&lt;select t=''&gt;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;&quot;</span>;

<span class="Comment">			// Support: IE8, Opera 10-12</span>
<span class="Comment">			// Nothing should be selected when empty strings follow ^= or $= or *=</span>
			<span class="Statement">if</span> ( div.querySelectorAll(<span class="Constant">&quot;[t^='']&quot;</span>).length ) {
				rbuggyQSA.push( <span class="Constant">&quot;[*^$]=&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*(?:''|</span><span class="Special">\&quot;\&quot;</span><span class="Constant">)&quot;</span> );
			}

<span class="Comment">			// Support: IE8</span>
<span class="Comment">			// Boolean attributes and &quot;value&quot; are not treated correctly</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>div.querySelectorAll(<span class="Constant">&quot;[selected]&quot;</span>).length ) {
				rbuggyQSA.push( <span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">[&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*(?:value|&quot;</span> <span class="Statement">+</span> booleans <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> );
			}

<span class="Comment">			// Webkit/Opera - :checked should return selected option elements</span>
<span class="Comment">			// <a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a></span>
<span class="Comment">			// IE8 throws error here and will not see later tests</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>div.querySelectorAll(<span class="Constant">&quot;:checked&quot;</span>).length ) {
				rbuggyQSA.push(<span class="Constant">&quot;:checked&quot;</span>);
			}
		});

		assert(<span class="Type">function</span>( div ) {
<span class="Comment">			// Support: Windows 8 Native Apps</span>
<span class="Comment">			// The type and name attributes are restricted during .innerHTML assignment</span>
			<span class="Type">var</span> input <span class="Statement">=</span> doc.createElement(<span class="Constant">&quot;input&quot;</span>);
			input.setAttribute( <span class="Constant">&quot;type&quot;</span>, <span class="Constant">&quot;hidden&quot;</span> );
			div.appendChild( input ).setAttribute( <span class="Constant">&quot;name&quot;</span>, <span class="Constant">&quot;D&quot;</span> );

<span class="Comment">			// Support: IE8</span>
<span class="Comment">			// Enforce case-sensitivity of name attribute</span>
			<span class="Statement">if</span> ( div.querySelectorAll(<span class="Constant">&quot;[name=d]&quot;</span>).length ) {
				rbuggyQSA.push( <span class="Constant">&quot;name&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;*[*^$|!~]?=&quot;</span> );
			}

<span class="Comment">			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)</span>
<span class="Comment">			// IE8 throws error here and will not see later tests</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>div.querySelectorAll(<span class="Constant">&quot;:enabled&quot;</span>).length ) {
				rbuggyQSA.push( <span class="Constant">&quot;:enabled&quot;</span>, <span class="Constant">&quot;:disabled&quot;</span> );
			}

<span class="Comment">			// Opera 10-11 does not throw on post-comma invalid pseudos</span>
			div.querySelectorAll(<span class="Constant">&quot;*,:x&quot;</span>);
			rbuggyQSA.push(<span class="Constant">&quot;,.*:&quot;</span>);
		});
	}

	<span class="Statement">if</span> ( (support.matchesSelector <span class="Statement">=</span> rnative.test( (matches <span class="Statement">=</span> docElem.webkitMatchesSelector <span class="Statement">||</span>
		docElem.mozMatchesSelector <span class="Statement">||</span>
		docElem.oMatchesSelector <span class="Statement">||</span>
		docElem.msMatchesSelector) )) ) {

		assert(<span class="Type">function</span>( div ) {
<span class="Comment">			// Check to see if it's possible to do matchesSelector</span>
<span class="Comment">			// on a disconnected node (IE 9)</span>
			support.disconnectedMatch <span class="Statement">=</span> matches.call( div, <span class="Constant">&quot;div&quot;</span> );

<span class="Comment">			// This should fail with an exception</span>
<span class="Comment">			// Gecko does not error, returns false instead</span>
			matches.call( div, <span class="Constant">&quot;[s!='']:x&quot;</span> );
			rbuggyMatches.push( <span class="Constant">&quot;!=&quot;</span>, pseudos );
		});
	}

	rbuggyQSA <span class="Statement">=</span> rbuggyQSA.length <span class="Statement">&amp;&amp;</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( rbuggyQSA.join(<span class="Constant">&quot;|&quot;</span>) );
	rbuggyMatches <span class="Statement">=</span> rbuggyMatches.length <span class="Statement">&amp;&amp;</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( rbuggyMatches.join(<span class="Constant">&quot;|&quot;</span>) );

	<span class="Comment">/* Contains</span>
<span class="Comment">	---------------------------------------------------------------------- */</span>
	hasCompare <span class="Statement">=</span> rnative.test( docElem.compareDocumentPosition );

<span class="Comment">	// Element contains another</span>
<span class="Comment">	// Purposefully does not implement inclusive descendent</span>
<span class="Comment">	// As in, an element does not contain itself</span>
	contains <span class="Statement">=</span> hasCompare <span class="Statement">||</span> rnative.test( docElem.contains ) <span class="Statement">?</span>
		<span class="Type">function</span>( a, b ) {
			<span class="Type">var</span> adown <span class="Statement">=</span> a.nodeType <span class="Statement">===</span> <span class="Constant">9</span> <span class="Statement">?</span> a.documentElement <span class="Statement">:</span> a,
				bup <span class="Statement">=</span> b <span class="Statement">&amp;&amp;</span> b.parentNode;
			<span class="Statement">return</span> a <span class="Statement">===</span> bup <span class="Statement">||</span> <span class="Statement">!!</span>( bup <span class="Statement">&amp;&amp;</span> bup.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> (
				adown.contains <span class="Statement">?</span>
					adown.contains( bup ) <span class="Statement">:</span>
					a.compareDocumentPosition <span class="Statement">&amp;&amp;</span> a.compareDocumentPosition( bup ) <span class="Statement">&amp;</span> <span class="Constant">16</span>
			));
		} <span class="Statement">:</span>
		<span class="Type">function</span>( a, b ) {
			<span class="Statement">if</span> ( b ) {
				<span class="Statement">while</span> ( (b <span class="Statement">=</span> b.parentNode) ) {
					<span class="Statement">if</span> ( b <span class="Statement">===</span> a ) {
						<span class="Statement">return</span> <span class="Constant">true</span>;
					}
				}
			}
			<span class="Statement">return</span> <span class="Constant">false</span>;
		};

	<span class="Comment">/* Sorting</span>
<span class="Comment">	---------------------------------------------------------------------- */</span>

<span class="Comment">	// Document order sorting</span>
	sortOrder <span class="Statement">=</span> hasCompare <span class="Statement">?</span>
	<span class="Type">function</span>( a, b ) {

<span class="Comment">		// Flag for duplicate removal</span>
		<span class="Statement">if</span> ( a <span class="Statement">===</span> b ) {
			hasDuplicate <span class="Statement">=</span> <span class="Constant">true</span>;
			<span class="Statement">return</span> <span class="Constant">0</span>;
		}

<span class="Comment">		// Sort on method existence if only one input has compareDocumentPosition</span>
		<span class="Type">var</span> compare <span class="Statement">=</span> <span class="Statement">!</span>a.compareDocumentPosition <span class="Statement">-</span> <span class="Statement">!</span>b.compareDocumentPosition;
		<span class="Statement">if</span> ( compare ) {
			<span class="Statement">return</span> compare;
		}

<span class="Comment">		// Calculate position if both inputs belong to the same document</span>
		compare <span class="Statement">=</span> ( a.ownerDocument <span class="Statement">||</span> a ) <span class="Statement">===</span> ( b.ownerDocument <span class="Statement">||</span> b ) <span class="Statement">?</span>
			a.compareDocumentPosition( b ) <span class="Statement">:</span>

<span class="Comment">			// Otherwise we know they are disconnected</span>
			<span class="Constant">1</span>;

<span class="Comment">		// Disconnected nodes</span>
		<span class="Statement">if</span> ( compare <span class="Statement">&amp;</span> <span class="Constant">1</span> <span class="Statement">||</span>
			(<span class="Statement">!</span>support.sortDetached <span class="Statement">&amp;&amp;</span> b.compareDocumentPosition( a ) <span class="Statement">===</span> compare) ) {

<span class="Comment">			// Choose the first element that is related to our preferred document</span>
			<span class="Statement">if</span> ( a <span class="Statement">===</span> doc <span class="Statement">||</span> a.ownerDocument <span class="Statement">===</span> preferredDoc <span class="Statement">&amp;&amp;</span> contains(preferredDoc, a) ) {
				<span class="Statement">return</span> <span class="Statement">-</span><span class="Constant">1</span>;
			}
			<span class="Statement">if</span> ( b <span class="Statement">===</span> doc <span class="Statement">||</span> b.ownerDocument <span class="Statement">===</span> preferredDoc <span class="Statement">&amp;&amp;</span> contains(preferredDoc, b) ) {
				<span class="Statement">return</span> <span class="Constant">1</span>;
			}

<span class="Comment">			// Maintain original order</span>
			<span class="Statement">return</span> sortInput <span class="Statement">?</span>
				( indexOf.call( sortInput, a ) <span class="Statement">-</span> indexOf.call( sortInput, b ) ) <span class="Statement">:</span>
				<span class="Constant">0</span>;
		}

		<span class="Statement">return</span> compare <span class="Statement">&amp;</span> <span class="Constant">4</span> <span class="Statement">?</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span> <span class="Constant">1</span>;
	} <span class="Statement">:</span>
	<span class="Type">function</span>( a, b ) {
<span class="Comment">		// Exit early if the nodes are identical</span>
		<span class="Statement">if</span> ( a <span class="Statement">===</span> b ) {
			hasDuplicate <span class="Statement">=</span> <span class="Constant">true</span>;
			<span class="Statement">return</span> <span class="Constant">0</span>;
		}

		<span class="Type">var</span> cur,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			aup <span class="Statement">=</span> a.parentNode,
			bup <span class="Statement">=</span> b.parentNode,
			ap <span class="Statement">=</span> [ a ],
			bp <span class="Statement">=</span> [ b ];

<span class="Comment">		// Parentless nodes are either documents or disconnected</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>aup <span class="Statement">||</span> <span class="Statement">!</span>bup ) {
			<span class="Statement">return</span> a <span class="Statement">===</span> doc <span class="Statement">?</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span>
				b <span class="Statement">===</span> doc <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span>
				aup <span class="Statement">?</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span>
				bup <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span>
				sortInput <span class="Statement">?</span>
				( indexOf.call( sortInput, a ) <span class="Statement">-</span> indexOf.call( sortInput, b ) ) <span class="Statement">:</span>
				<span class="Constant">0</span>;

<span class="Comment">		// If the nodes are siblings, we can do a quick check</span>
		} <span class="Statement">else</span> <span class="Statement">if</span> ( aup <span class="Statement">===</span> bup ) {
			<span class="Statement">return</span> siblingCheck( a, b );
		}

<span class="Comment">		// Otherwise we need full lists of their ancestors for comparison</span>
		cur <span class="Statement">=</span> a;
		<span class="Statement">while</span> ( (cur <span class="Statement">=</span> cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur <span class="Statement">=</span> b;
		<span class="Statement">while</span> ( (cur <span class="Statement">=</span> cur.parentNode) ) {
			bp.unshift( cur );
		}

<span class="Comment">		// Walk down the tree looking for a discrepancy</span>
		<span class="Statement">while</span> ( ap[i] <span class="Statement">===</span> bp[i] ) {
			i<span class="Statement">++</span>;
		}

		<span class="Statement">return</span> i <span class="Statement">?</span>
<span class="Comment">			// Do a sibling check if the nodes have a common ancestor</span>
			siblingCheck( ap[i], bp[i] ) <span class="Statement">:</span>

<span class="Comment">			// Otherwise nodes in our document sort first</span>
			ap[i] <span class="Statement">===</span> preferredDoc <span class="Statement">?</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span>
			bp[i] <span class="Statement">===</span> preferredDoc <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span>
			<span class="Constant">0</span>;
	};

	<span class="Statement">return</span> doc;
};

Sizzle.matches <span class="Statement">=</span> <span class="Type">function</span>( expr, elements ) {
	<span class="Statement">return</span> Sizzle( expr, <span class="Type">null</span>, <span class="Type">null</span>, elements );
};

Sizzle.matchesSelector <span class="Statement">=</span> <span class="Type">function</span>( elem, expr ) {
<span class="Comment">	// Set document vars if needed</span>
	<span class="Statement">if</span> ( ( elem.ownerDocument <span class="Statement">||</span> elem ) <span class="Statement">!==</span> <span class="Special">document</span> ) {
		setDocument( elem );
	}

<span class="Comment">	// Make sure that attribute selectors are quoted</span>
	expr <span class="Statement">=</span> expr.replace( rattributeQuotes, <span class="Constant">&quot;='$1']&quot;</span> );

	<span class="Statement">if</span> ( support.matchesSelector <span class="Statement">&amp;&amp;</span> documentIsHTML <span class="Statement">&amp;&amp;</span>
		( <span class="Statement">!</span>rbuggyMatches <span class="Statement">||</span> <span class="Statement">!</span>rbuggyMatches.test( expr ) ) <span class="Statement">&amp;&amp;</span>
		( <span class="Statement">!</span>rbuggyQSA     <span class="Statement">||</span> <span class="Statement">!</span>rbuggyQSA.test( expr ) ) ) {

		<span class="Statement">try</span> {
			<span class="Type">var</span> ret <span class="Statement">=</span> matches.call( elem, expr );

<span class="Comment">			// IE 9's matchesSelector returns false on disconnected nodes</span>
			<span class="Statement">if</span> ( ret <span class="Statement">||</span> support.disconnectedMatch <span class="Statement">||</span>
<span class="Comment">					// As well, disconnected nodes are said to be in a document</span>
<span class="Comment">					// fragment in IE 9</span>
					elem.<span class="Special">document</span> <span class="Statement">&amp;&amp;</span> elem.<span class="Special">document</span>.nodeType <span class="Statement">!==</span> <span class="Constant">11</span> ) {
				<span class="Statement">return</span> ret;
			}
		} <span class="Statement">catch</span>(e) {}
	}

	<span class="Statement">return</span> Sizzle( expr, <span class="Special">document</span>, <span class="Type">null</span>, [elem] ).length <span class="Statement">&gt;</span> <span class="Constant">0</span>;
};

Sizzle.contains <span class="Statement">=</span> <span class="Type">function</span>( context, elem ) {
<span class="Comment">	// Set document vars if needed</span>
	<span class="Statement">if</span> ( ( context.ownerDocument <span class="Statement">||</span> context ) <span class="Statement">!==</span> <span class="Special">document</span> ) {
		setDocument( context );
	}
	<span class="Statement">return</span> contains( context, elem );
};

Sizzle.attr <span class="Statement">=</span> <span class="Type">function</span>( elem, name ) {
<span class="Comment">	// Set document vars if needed</span>
	<span class="Statement">if</span> ( ( elem.ownerDocument <span class="Statement">||</span> elem ) <span class="Statement">!==</span> <span class="Special">document</span> ) {
		setDocument( elem );
	}

	<span class="Type">var</span> fn <span class="Statement">=</span> Expr.attrHandle[ name.toLowerCase() ],
<span class="Comment">		// Don't get fooled by Object.prototype properties (jQuery #13807)</span>
		val <span class="Statement">=</span> fn <span class="Statement">&amp;&amp;</span> hasOwn.call( Expr.attrHandle, name.toLowerCase() ) <span class="Statement">?</span>
			fn( elem, name, <span class="Statement">!</span>documentIsHTML ) <span class="Statement">:</span>
			<span class="Type">undefined</span>;

	<span class="Statement">return</span> val <span class="Statement">!==</span> <span class="Type">undefined</span> <span class="Statement">?</span>
		val <span class="Statement">:</span>
		support.attributes <span class="Statement">||</span> <span class="Statement">!</span>documentIsHTML <span class="Statement">?</span>
			elem.getAttribute( name ) <span class="Statement">:</span>
			(val <span class="Statement">=</span> elem.getAttributeNode(name)) <span class="Statement">&amp;&amp;</span> val.specified <span class="Statement">?</span>
				val.value <span class="Statement">:</span>
				<span class="Type">null</span>;
};

Sizzle.error <span class="Statement">=</span> <span class="Type">function</span>( msg ) {
	<span class="Statement">throw</span> <span class="Statement">new</span> <span class="Special">Error</span>( <span class="Constant">&quot;Syntax error, unrecognized expression: &quot;</span> <span class="Statement">+</span> msg );
};

<span class="Comment">/**</span>
<span class="Comment"> * Document sorting and removing duplicates</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{ArrayLike}</span><span class="Comment"> </span><span class="Statement">results</span>
<span class="Comment"> </span><span class="Comment">*/</span>
Sizzle.uniqueSort <span class="Statement">=</span> <span class="Type">function</span>( results ) {
	<span class="Type">var</span> elem,
		duplicates <span class="Statement">=</span> [],
		j <span class="Statement">=</span> <span class="Constant">0</span>,
		i <span class="Statement">=</span> <span class="Constant">0</span>;

<span class="Comment">	// Unless we *know* we can detect duplicates, assume their presence</span>
	hasDuplicate <span class="Statement">=</span> <span class="Statement">!</span>support.detectDuplicates;
	sortInput <span class="Statement">=</span> <span class="Statement">!</span>support.sortStable <span class="Statement">&amp;&amp;</span> results.slice( <span class="Constant">0</span> );
	results.sort( sortOrder );

	<span class="Statement">if</span> ( hasDuplicate ) {
		<span class="Statement">while</span> ( (elem <span class="Statement">=</span> results[i<span class="Statement">++</span>]) ) {
			<span class="Statement">if</span> ( elem <span class="Statement">===</span> results[ i ] ) {
				j <span class="Statement">=</span> duplicates.push( i );
			}
		}
		<span class="Statement">while</span> ( j<span class="Statement">--</span> ) {
			results.splice( duplicates[ j ], <span class="Constant">1</span> );
		}
	}

<span class="Comment">	// Clear input after sorting to release objects</span>
<span class="Comment">	// See <a href="https://github.com/jquery/sizzle/pull/225">https://github.com/jquery/sizzle/pull/225</a></span>
	sortInput <span class="Statement">=</span> <span class="Type">null</span>;

	<span class="Statement">return</span> results;
};

<span class="Comment">/**</span>
<span class="Comment"> * Utility function for retrieving the text value of an array of DOM nodes</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Array|Element}</span><span class="Comment"> </span><span class="Statement">elem</span>
<span class="Comment"> </span><span class="Comment">*/</span>
getText <span class="Statement">=</span> Sizzle.getText <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
	<span class="Type">var</span> node,
		ret <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>,
		i <span class="Statement">=</span> <span class="Constant">0</span>,
		nodeType <span class="Statement">=</span> elem.nodeType;

	<span class="Statement">if</span> ( <span class="Statement">!</span>nodeType ) {
<span class="Comment">		// If no nodeType, this is expected to be an array</span>
		<span class="Statement">while</span> ( (node <span class="Statement">=</span> elem[i<span class="Statement">++</span>]) ) {
<span class="Comment">			// Do not traverse comment nodes</span>
			ret <span class="Statement">+=</span> getText( node );
		}
	} <span class="Statement">else</span> <span class="Statement">if</span> ( nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> nodeType <span class="Statement">===</span> <span class="Constant">9</span> <span class="Statement">||</span> nodeType <span class="Statement">===</span> <span class="Constant">11</span> ) {
<span class="Comment">		// Use textContent for elements</span>
<span class="Comment">		// innerText usage removed for consistency of new lines (jQuery #11153)</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> elem.textContent <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			<span class="Statement">return</span> elem.textContent;
		} <span class="Statement">else</span> {
<span class="Comment">			// Traverse its children</span>
			<span class="Statement">for</span> ( elem <span class="Statement">=</span> elem.firstChild; elem; elem <span class="Statement">=</span> elem.nextSibling ) {
				ret <span class="Statement">+=</span> getText( elem );
			}
		}
	} <span class="Statement">else</span> <span class="Statement">if</span> ( nodeType <span class="Statement">===</span> <span class="Constant">3</span> <span class="Statement">||</span> nodeType <span class="Statement">===</span> <span class="Constant">4</span> ) {
		<span class="Statement">return</span> elem.nodeValue;
	}
<span class="Comment">	// Do not include comment or processing instruction nodes</span>

	<span class="Statement">return</span> ret;
};

Expr <span class="Statement">=</span> Sizzle.selectors <span class="Statement">=</span> {

<span class="Comment">	// Can be adjusted by the user</span>
	cacheLength: <span class="Constant">50</span>,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		<span class="Constant">&quot;&gt;&quot;</span>: { dir: <span class="Constant">&quot;parentNode&quot;</span>, first: <span class="Constant">true</span> },
		<span class="Constant">&quot; &quot;</span>: { dir: <span class="Constant">&quot;parentNode&quot;</span> },
		<span class="Constant">&quot;+&quot;</span>: { dir: <span class="Constant">&quot;previousSibling&quot;</span>, first: <span class="Constant">true</span> },
		<span class="Constant">&quot;~&quot;</span>: { dir: <span class="Constant">&quot;previousSibling&quot;</span> }
	},

	preFilter: {
		<span class="Constant">&quot;ATTR&quot;</span>: <span class="Type">function</span>( match ) {
			match[<span class="Constant">1</span>] <span class="Statement">=</span> match[<span class="Constant">1</span>].replace( runescape, funescape );

<span class="Comment">			// Move the given value to match[3] whether quoted or unquoted</span>
			match[<span class="Constant">3</span>] <span class="Statement">=</span> ( match[<span class="Constant">4</span>] <span class="Statement">||</span> match[<span class="Constant">5</span>] <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).replace( runescape, funescape );

			<span class="Statement">if</span> ( match[<span class="Constant">2</span>] <span class="Statement">===</span> <span class="Constant">&quot;~=&quot;</span> ) {
				match[<span class="Constant">3</span>] <span class="Statement">=</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> match[<span class="Constant">3</span>] <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span>;
			}

			<span class="Statement">return</span> match.slice( <span class="Constant">0</span>, <span class="Constant">4</span> );
		},

		<span class="Constant">&quot;CHILD&quot;</span>: <span class="Type">function</span>( match ) {
			<span class="Comment">/* matches from matchExpr[&quot;CHILD&quot;]</span>
<span class="Comment">				1 type (only|nth|...)</span>
<span class="Comment">				2 what (child|of-type)</span>
<span class="Comment">				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)</span>
<span class="Comment">				4 xn-component of xn+y argument ([+-]?\d*n|)</span>
<span class="Comment">				5 sign of xn-component</span>
<span class="Comment">				6 x of xn-component</span>
<span class="Comment">				7 sign of y-component</span>
<span class="Comment">				8 y of y-component</span>
<span class="Comment">			*/</span>
			match[<span class="Constant">1</span>] <span class="Statement">=</span> match[<span class="Constant">1</span>].toLowerCase();

			<span class="Statement">if</span> ( match[<span class="Constant">1</span>].slice( <span class="Constant">0</span>, <span class="Constant">3</span> ) <span class="Statement">===</span> <span class="Constant">&quot;nth&quot;</span> ) {
<span class="Comment">				// nth-* requires argument</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>match[<span class="Constant">3</span>] ) {
					Sizzle.error( match[<span class="Constant">0</span>] );
				}

<span class="Comment">				// numeric x and y parameters for Expr.filter.CHILD</span>
<span class="Comment">				// remember that false/true cast respectively to 0/1</span>
				match[<span class="Constant">4</span>] <span class="Statement">=</span> <span class="Statement">+</span>( match[<span class="Constant">4</span>] <span class="Statement">?</span> match[<span class="Constant">5</span>] <span class="Statement">+</span> (match[<span class="Constant">6</span>] <span class="Statement">||</span> <span class="Constant">1</span>) <span class="Statement">:</span> <span class="Constant">2</span> <span class="Statement">*</span> ( match[<span class="Constant">3</span>] <span class="Statement">===</span> <span class="Constant">&quot;even&quot;</span> <span class="Statement">||</span> match[<span class="Constant">3</span>] <span class="Statement">===</span> <span class="Constant">&quot;odd&quot;</span> ) );
				match[<span class="Constant">5</span>] <span class="Statement">=</span> <span class="Statement">+</span>( ( match[<span class="Constant">7</span>] <span class="Statement">+</span> match[<span class="Constant">8</span>] ) <span class="Statement">||</span> match[<span class="Constant">3</span>] <span class="Statement">===</span> <span class="Constant">&quot;odd&quot;</span> );

<span class="Comment">			// other types prohibit arguments</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( match[<span class="Constant">3</span>] ) {
				Sizzle.error( match[<span class="Constant">0</span>] );
			}

			<span class="Statement">return</span> match;
		},

		<span class="Constant">&quot;PSEUDO&quot;</span>: <span class="Type">function</span>( match ) {
			<span class="Type">var</span> excess,
				unquoted <span class="Statement">=</span> <span class="Statement">!</span>match[<span class="Constant">5</span>] <span class="Statement">&amp;&amp;</span> match[<span class="Constant">2</span>];

			<span class="Statement">if</span> ( matchExpr[<span class="Constant">&quot;CHILD&quot;</span>].test( match[<span class="Constant">0</span>] ) ) {
				<span class="Statement">return</span> <span class="Type">null</span>;
			}

<span class="Comment">			// Accept quoted arguments as-is</span>
			<span class="Statement">if</span> ( match[<span class="Constant">3</span>] <span class="Statement">&amp;&amp;</span> match[<span class="Constant">4</span>] <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
				match[<span class="Constant">2</span>] <span class="Statement">=</span> match[<span class="Constant">4</span>];

<span class="Comment">			// Strip excess characters from unquoted arguments</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( unquoted <span class="Statement">&amp;&amp;</span> rpseudo.test( unquoted ) <span class="Statement">&amp;&amp;</span>
<span class="Comment">				// Get excess from tokenize (recursively)</span>
				(excess <span class="Statement">=</span> tokenize( unquoted, <span class="Constant">true</span> )) <span class="Statement">&amp;&amp;</span>
<span class="Comment">				// advance to the next closing parenthesis</span>
				(excess <span class="Statement">=</span> unquoted.indexOf( <span class="Constant">&quot;)&quot;</span>, unquoted.length <span class="Statement">-</span> excess ) <span class="Statement">-</span> unquoted.length) ) {

<span class="Comment">				// excess is a negative index</span>
				match[<span class="Constant">0</span>] <span class="Statement">=</span> match[<span class="Constant">0</span>].slice( <span class="Constant">0</span>, excess );
				match[<span class="Constant">2</span>] <span class="Statement">=</span> unquoted.slice( <span class="Constant">0</span>, excess );
			}

<span class="Comment">			// Return only captures needed by the pseudo filter method (type and argument)</span>
			<span class="Statement">return</span> match.slice( <span class="Constant">0</span>, <span class="Constant">3</span> );
		}
	},

	filter: {

		<span class="Constant">&quot;TAG&quot;</span>: <span class="Type">function</span>( nodeNameSelector ) {
			<span class="Type">var</span> nodeName <span class="Statement">=</span> nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			<span class="Statement">return</span> nodeNameSelector <span class="Statement">===</span> <span class="Constant">&quot;*&quot;</span> <span class="Statement">?</span>
				<span class="Type">function</span>() { <span class="Statement">return</span> <span class="Constant">true</span>; } <span class="Statement">:</span>
				<span class="Type">function</span>( elem ) {
					<span class="Statement">return</span> elem.nodeName <span class="Statement">&amp;&amp;</span> elem.nodeName.toLowerCase() <span class="Statement">===</span> nodeName;
				};
		},

		<span class="Constant">&quot;CLASS&quot;</span>: <span class="Type">function</span>( className ) {
			<span class="Type">var</span> pattern <span class="Statement">=</span> classCache[ className <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ];

			<span class="Statement">return</span> pattern <span class="Statement">||</span>
				(pattern <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;(^|&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span> <span class="Statement">+</span> className <span class="Statement">+</span> <span class="Constant">&quot;(&quot;</span> <span class="Statement">+</span> whitespace <span class="Statement">+</span> <span class="Constant">&quot;|$)&quot;</span> )) <span class="Statement">&amp;&amp;</span>
				classCache( className, <span class="Type">function</span>( elem ) {
					<span class="Statement">return</span> pattern.test( <span class="Statement">typeof</span> elem.className <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> elem.className <span class="Statement">||</span> <span class="Statement">typeof</span> elem.getAttribute <span class="Statement">!==</span> strundefined <span class="Statement">&amp;&amp;</span> elem.getAttribute(<span class="Constant">&quot;class&quot;</span>) <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> );
				});
		},

		<span class="Constant">&quot;ATTR&quot;</span>: <span class="Type">function</span>( name, operator, check ) {
			<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
				<span class="Type">var</span> result <span class="Statement">=</span> Sizzle.attr( elem, name );

				<span class="Statement">if</span> ( result <span class="Statement">==</span> <span class="Type">null</span> ) {
					<span class="Statement">return</span> operator <span class="Statement">===</span> <span class="Constant">&quot;!=&quot;</span>;
				}
				<span class="Statement">if</span> ( <span class="Statement">!</span>operator ) {
					<span class="Statement">return</span> <span class="Constant">true</span>;
				}

				result <span class="Statement">+=</span> <span class="Constant">&quot;&quot;</span>;

				<span class="Statement">return</span> operator <span class="Statement">===</span> <span class="Constant">&quot;=&quot;</span> <span class="Statement">?</span> result <span class="Statement">===</span> check <span class="Statement">:</span>
					operator <span class="Statement">===</span> <span class="Constant">&quot;!=&quot;</span> <span class="Statement">?</span> result <span class="Statement">!==</span> check <span class="Statement">:</span>
					operator <span class="Statement">===</span> <span class="Constant">&quot;^=&quot;</span> <span class="Statement">?</span> check <span class="Statement">&amp;&amp;</span> result.indexOf( check ) <span class="Statement">===</span> <span class="Constant">0</span> <span class="Statement">:</span>
					operator <span class="Statement">===</span> <span class="Constant">&quot;*=&quot;</span> <span class="Statement">?</span> check <span class="Statement">&amp;&amp;</span> result.indexOf( check ) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span>
					operator <span class="Statement">===</span> <span class="Constant">&quot;$=&quot;</span> <span class="Statement">?</span> check <span class="Statement">&amp;&amp;</span> result.slice( <span class="Statement">-</span>check.length ) <span class="Statement">===</span> check <span class="Statement">:</span>
					operator <span class="Statement">===</span> <span class="Constant">&quot;~=&quot;</span> <span class="Statement">?</span> ( <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> result <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ).indexOf( check ) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span>
					operator <span class="Statement">===</span> <span class="Constant">&quot;|=&quot;</span> <span class="Statement">?</span> result <span class="Statement">===</span> check <span class="Statement">||</span> result.slice( <span class="Constant">0</span>, check.length <span class="Statement">+</span> <span class="Constant">1</span> ) <span class="Statement">===</span> check <span class="Statement">+</span> <span class="Constant">&quot;-&quot;</span> <span class="Statement">:</span>
					<span class="Constant">false</span>;
			};
		},

		<span class="Constant">&quot;CHILD&quot;</span>: <span class="Type">function</span>( type, what, argument, first, last ) {
			<span class="Type">var</span> simple <span class="Statement">=</span> type.slice( <span class="Constant">0</span>, <span class="Constant">3</span> ) <span class="Statement">!==</span> <span class="Constant">&quot;nth&quot;</span>,
				forward <span class="Statement">=</span> type.slice( <span class="Statement">-</span><span class="Constant">4</span> ) <span class="Statement">!==</span> <span class="Constant">&quot;last&quot;</span>,
				ofType <span class="Statement">=</span> what <span class="Statement">===</span> <span class="Constant">&quot;of-type&quot;</span>;

			<span class="Statement">return</span> first <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> last <span class="Statement">===</span> <span class="Constant">0</span> <span class="Statement">?</span>

<span class="Comment">				// Shortcut for :nth-*(n)</span>
				<span class="Type">function</span>( elem ) {
					<span class="Statement">return</span> <span class="Statement">!!</span>elem.parentNode;
				} <span class="Statement">:</span>

				<span class="Type">function</span>( elem, context, xml ) {
					<span class="Type">var</span> cache, outerCache, node, diff, nodeIndex, start,
						dir <span class="Statement">=</span> simple <span class="Statement">!==</span> forward <span class="Statement">?</span> <span class="Constant">&quot;nextSibling&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;previousSibling&quot;</span>,
						parent <span class="Statement">=</span> elem.parentNode,
						name <span class="Statement">=</span> ofType <span class="Statement">&amp;&amp;</span> elem.nodeName.toLowerCase(),
						useCache <span class="Statement">=</span> <span class="Statement">!</span>xml <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>ofType;

					<span class="Statement">if</span> ( parent ) {

<span class="Comment">						// :(first|last|only)-(child|of-type)</span>
						<span class="Statement">if</span> ( simple ) {
							<span class="Statement">while</span> ( dir ) {
								node <span class="Statement">=</span> elem;
								<span class="Statement">while</span> ( (node <span class="Statement">=</span> node[ dir ]) ) {
									<span class="Statement">if</span> ( ofType <span class="Statement">?</span> node.nodeName.toLowerCase() <span class="Statement">===</span> name <span class="Statement">:</span> node.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
										<span class="Statement">return</span> <span class="Constant">false</span>;
									}
								}
<span class="Comment">								// Reverse direction for :only-* (if we haven't yet done so)</span>
								start <span class="Statement">=</span> dir <span class="Statement">=</span> type <span class="Statement">===</span> <span class="Constant">&quot;only&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>start <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;nextSibling&quot;</span>;
							}
							<span class="Statement">return</span> <span class="Constant">true</span>;
						}

						start <span class="Statement">=</span> [ forward <span class="Statement">?</span> parent.firstChild <span class="Statement">:</span> parent.lastChild ];

<span class="Comment">						// non-xml :nth-child(...) stores cache data on `parent`</span>
						<span class="Statement">if</span> ( forward <span class="Statement">&amp;&amp;</span> useCache ) {
<span class="Comment">							// Seek `elem` from a previously-cached index</span>
							outerCache <span class="Statement">=</span> parent[ expando ] <span class="Statement">||</span> (parent[ expando ] <span class="Statement">=</span> {});
							cache <span class="Statement">=</span> outerCache[ type ] <span class="Statement">||</span> [];
							nodeIndex <span class="Statement">=</span> cache[<span class="Constant">0</span>] <span class="Statement">===</span> dirruns <span class="Statement">&amp;&amp;</span> cache[<span class="Constant">1</span>];
							diff <span class="Statement">=</span> cache[<span class="Constant">0</span>] <span class="Statement">===</span> dirruns <span class="Statement">&amp;&amp;</span> cache[<span class="Constant">2</span>];
							node <span class="Statement">=</span> nodeIndex <span class="Statement">&amp;&amp;</span> parent.childNodes[ nodeIndex ];

							<span class="Statement">while</span> ( (node <span class="Statement">=</span> <span class="Statement">++</span>nodeIndex <span class="Statement">&amp;&amp;</span> node <span class="Statement">&amp;&amp;</span> node[ dir ] <span class="Statement">||</span>

<span class="Comment">								// Fallback to seeking `elem` from the start</span>
								(diff <span class="Statement">=</span> nodeIndex <span class="Statement">=</span> <span class="Constant">0</span>) <span class="Statement">||</span> start.pop()) ) {

<span class="Comment">								// When found, cache indexes on `parent` and break</span>
								<span class="Statement">if</span> ( node.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">++</span>diff <span class="Statement">&amp;&amp;</span> node <span class="Statement">===</span> elem ) {
									outerCache[ type ] <span class="Statement">=</span> [ dirruns, nodeIndex, diff ];
									<span class="Statement">break</span>;
								}
							}

<span class="Comment">						// Use previously-cached element index if available</span>
						} <span class="Statement">else</span> <span class="Statement">if</span> ( useCache <span class="Statement">&amp;&amp;</span> (cache <span class="Statement">=</span> (elem[ expando ] <span class="Statement">||</span> (elem[ expando ] <span class="Statement">=</span> {}))[ type ]) <span class="Statement">&amp;&amp;</span> cache[<span class="Constant">0</span>] <span class="Statement">===</span> dirruns ) {
							diff <span class="Statement">=</span> cache[<span class="Constant">1</span>];

<span class="Comment">						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)</span>
						} <span class="Statement">else</span> {
<span class="Comment">							// Use the same loop as above to seek `elem` from the start</span>
							<span class="Statement">while</span> ( (node <span class="Statement">=</span> <span class="Statement">++</span>nodeIndex <span class="Statement">&amp;&amp;</span> node <span class="Statement">&amp;&amp;</span> node[ dir ] <span class="Statement">||</span>
								(diff <span class="Statement">=</span> nodeIndex <span class="Statement">=</span> <span class="Constant">0</span>) <span class="Statement">||</span> start.pop()) ) {

								<span class="Statement">if</span> ( ( ofType <span class="Statement">?</span> node.nodeName.toLowerCase() <span class="Statement">===</span> name <span class="Statement">:</span> node.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) <span class="Statement">&amp;&amp;</span> <span class="Statement">++</span>diff ) {
<span class="Comment">									// Cache the index of each encountered element</span>
									<span class="Statement">if</span> ( useCache ) {
										(node[ expando ] <span class="Statement">||</span> (node[ expando ] <span class="Statement">=</span> {}))[ type ] <span class="Statement">=</span> [ dirruns, diff ];
									}

									<span class="Statement">if</span> ( node <span class="Statement">===</span> elem ) {
										<span class="Statement">break</span>;
									}
								}
							}
						}

<span class="Comment">						// Incorporate the offset, then check against cycle size</span>
						diff <span class="Statement">-=</span> last;
						<span class="Statement">return</span> diff <span class="Statement">===</span> first <span class="Statement">||</span> ( diff <span class="Statement">%</span> first <span class="Statement">===</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span> diff <span class="Statement">/</span> first <span class="Statement">&gt;=</span> <span class="Constant">0</span> );
					}
				};
		},

		<span class="Constant">&quot;PSEUDO&quot;</span>: <span class="Type">function</span>( pseudo, argument ) {
<span class="Comment">			// pseudo-class names are case-insensitive</span>
<span class="Comment">			// <a href="http://www.w3.org/TR/selectors/#pseudo-classes">http://www.w3.org/TR/selectors/#pseudo-classes</a></span>
<span class="Comment">			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters</span>
<span class="Comment">			// Remember that setFilters inherits from pseudos</span>
			<span class="Type">var</span> args,
				fn <span class="Statement">=</span> Expr.pseudos[ pseudo ] <span class="Statement">||</span> Expr.setFilters[ pseudo.toLowerCase() ] <span class="Statement">||</span>
					Sizzle.error( <span class="Constant">&quot;unsupported pseudo: &quot;</span> <span class="Statement">+</span> pseudo );

<span class="Comment">			// The user may use createPseudo to indicate that</span>
<span class="Comment">			// arguments are needed to create the filter function</span>
<span class="Comment">			// just as Sizzle does</span>
			<span class="Statement">if</span> ( fn[ expando ] ) {
				<span class="Statement">return</span> fn( argument );
			}

<span class="Comment">			// But maintain support for old signatures</span>
			<span class="Statement">if</span> ( fn.length <span class="Statement">&gt;</span> <span class="Constant">1</span> ) {
				args <span class="Statement">=</span> [ pseudo, pseudo, <span class="Constant">&quot;&quot;</span>, argument ];
				<span class="Statement">return</span> Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) <span class="Statement">?</span>
					markFunction(<span class="Type">function</span>( seed, matches ) {
						<span class="Type">var</span> idx,
							matched <span class="Statement">=</span> fn( seed, argument ),
							i <span class="Statement">=</span> matched.length;
						<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
							idx <span class="Statement">=</span> indexOf.call( seed, matched[i] );
							seed[ idx ] <span class="Statement">=</span> <span class="Statement">!</span>( matches[ idx ] <span class="Statement">=</span> matched[i] );
						}
					}) <span class="Statement">:</span>
					<span class="Type">function</span>( elem ) {
						<span class="Statement">return</span> fn( elem, <span class="Constant">0</span>, args );
					};
			}

			<span class="Statement">return</span> fn;
		}
	},

	pseudos: {
<span class="Comment">		// Potentially complex pseudos</span>
		<span class="Constant">&quot;not&quot;</span>: markFunction(<span class="Type">function</span>( selector ) {
<span class="Comment">			// Trim the selector passed to compile</span>
<span class="Comment">			// to avoid treating leading and trailing</span>
<span class="Comment">			// spaces as combinators</span>
			<span class="Type">var</span> input <span class="Statement">=</span> [],
				results <span class="Statement">=</span> [],
				matcher <span class="Statement">=</span> compile( selector.replace( rtrim, <span class="Constant">&quot;$1&quot;</span> ) );

			<span class="Statement">return</span> matcher[ expando ] <span class="Statement">?</span>
				markFunction(<span class="Type">function</span>( seed, matches, context, xml ) {
					<span class="Type">var</span> elem,
						unmatched <span class="Statement">=</span> matcher( seed, <span class="Type">null</span>, xml, [] ),
						i <span class="Statement">=</span> seed.length;

<span class="Comment">					// Match elements unmatched by `matcher`</span>
					<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
						<span class="Statement">if</span> ( (elem <span class="Statement">=</span> unmatched[i]) ) {
							seed[i] <span class="Statement">=</span> <span class="Statement">!</span>(matches[i] <span class="Statement">=</span> elem);
						}
					}
				}) <span class="Statement">:</span>
				<span class="Type">function</span>( elem, context, xml ) {
					input[<span class="Constant">0</span>] <span class="Statement">=</span> elem;
					matcher( input, <span class="Type">null</span>, xml, results );
					<span class="Statement">return</span> <span class="Statement">!</span>results.pop();
				};
		}),

		<span class="Constant">&quot;has&quot;</span>: markFunction(<span class="Type">function</span>( selector ) {
			<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
				<span class="Statement">return</span> Sizzle( selector, elem ).length <span class="Statement">&gt;</span> <span class="Constant">0</span>;
			};
		}),

		<span class="Constant">&quot;contains&quot;</span>: markFunction(<span class="Type">function</span>( text ) {
			<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
				<span class="Statement">return</span> ( elem.textContent <span class="Statement">||</span> elem.innerText <span class="Statement">||</span> getText( elem ) ).indexOf( text ) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span>;
			};
		}),

<span class="Comment">		// &quot;Whether an element is represented by a :lang() selector</span>
<span class="Comment">		// is based solely on the element's language value</span>
<span class="Comment">		// being equal to the identifier C,</span>
<span class="Comment">		// or beginning with the identifier C immediately followed by &quot;-&quot;.</span>
<span class="Comment">		// The matching of C against the element's language value is performed case-insensitively.</span>
<span class="Comment">		// The identifier C does not have to be a valid language name.&quot;</span>
<span class="Comment">		// <a href="http://www.w3.org/TR/selectors/#lang-pseudo">http://www.w3.org/TR/selectors/#lang-pseudo</a></span>
		<span class="Constant">&quot;lang&quot;</span>: markFunction( <span class="Type">function</span>( lang ) {
<span class="Comment">			// lang value must be a valid identifier</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>ridentifier.test(lang <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span>) ) {
				Sizzle.error( <span class="Constant">&quot;unsupported lang: &quot;</span> <span class="Statement">+</span> lang );
			}
			lang <span class="Statement">=</span> lang.replace( runescape, funescape ).toLowerCase();
			<span class="Statement">return</span> <span class="Type">function</span>( elem ) {
				<span class="Type">var</span> elemLang;
				<span class="Statement">do</span> {
					<span class="Statement">if</span> ( (elemLang <span class="Statement">=</span> documentIsHTML <span class="Statement">?</span>
						elem.lang <span class="Statement">:</span>
						elem.getAttribute(<span class="Constant">&quot;xml:lang&quot;</span>) <span class="Statement">||</span> elem.getAttribute(<span class="Constant">&quot;lang&quot;</span>)) ) {

						elemLang <span class="Statement">=</span> elemLang.toLowerCase();
						<span class="Statement">return</span> elemLang <span class="Statement">===</span> lang <span class="Statement">||</span> elemLang.indexOf( lang <span class="Statement">+</span> <span class="Constant">&quot;-&quot;</span> ) <span class="Statement">===</span> <span class="Constant">0</span>;
					}
				} <span class="Statement">while</span> ( (elem <span class="Statement">=</span> elem.parentNode) <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> );
				<span class="Statement">return</span> <span class="Constant">false</span>;
			};
		}),

<span class="Comment">		// Miscellaneous</span>
		<span class="Constant">&quot;target&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Type">var</span> hash <span class="Statement">=</span> <span class="Special">window</span>.location <span class="Statement">&amp;&amp;</span> <span class="Special">window</span>.location.hash;
			<span class="Statement">return</span> hash <span class="Statement">&amp;&amp;</span> hash.slice( <span class="Constant">1</span> ) <span class="Statement">===</span> elem.id;
		},

		<span class="Constant">&quot;root&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> elem <span class="Statement">===</span> docElem;
		},

		<span class="Constant">&quot;focus&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> elem <span class="Statement">===</span> <span class="Special">document</span>.activeElement <span class="Statement">&amp;&amp;</span> (<span class="Statement">!</span><span class="Special">document</span>.hasFocus <span class="Statement">||</span> <span class="Special">document</span>.hasFocus()) <span class="Statement">&amp;&amp;</span> <span class="Statement">!!</span>(elem.type <span class="Statement">||</span> elem.href <span class="Statement">||</span> <span class="Statement">~</span>elem.tabIndex);
		},

<span class="Comment">		// Boolean properties</span>
		<span class="Constant">&quot;enabled&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> elem.disabled <span class="Statement">===</span> <span class="Constant">false</span>;
		},

		<span class="Constant">&quot;disabled&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> elem.disabled <span class="Statement">===</span> <span class="Constant">true</span>;
		},

		<span class="Constant">&quot;checked&quot;</span>: <span class="Type">function</span>( elem ) {
<span class="Comment">			// In CSS3, :checked should return both checked and selected elements</span>
<span class="Comment">			// <a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a></span>
			<span class="Type">var</span> nodeName <span class="Statement">=</span> elem.nodeName.toLowerCase();
			<span class="Statement">return</span> (nodeName <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!!</span>elem.checked) <span class="Statement">||</span> (nodeName <span class="Statement">===</span> <span class="Constant">&quot;option&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!!</span>elem.selected);
		},

		<span class="Constant">&quot;selected&quot;</span>: <span class="Type">function</span>( elem ) {
<span class="Comment">			// Accessing this property makes selected-by-default</span>
<span class="Comment">			// options in Safari work properly</span>
			<span class="Statement">if</span> ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			<span class="Statement">return</span> elem.selected <span class="Statement">===</span> <span class="Constant">true</span>;
		},

<span class="Comment">		// Contents</span>
		<span class="Constant">&quot;empty&quot;</span>: <span class="Type">function</span>( elem ) {
<span class="Comment">			// <a href="http://www.w3.org/TR/selectors/#empty-pseudo">http://www.w3.org/TR/selectors/#empty-pseudo</a></span>
<span class="Comment">			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),</span>
<span class="Comment">			//   but not by others (comment: 8; processing instruction: 7; etc.)</span>
<span class="Comment">			// nodeType &lt; 6 works because attributes (2) do not appear as children</span>
			<span class="Statement">for</span> ( elem <span class="Statement">=</span> elem.firstChild; elem; elem <span class="Statement">=</span> elem.nextSibling ) {
				<span class="Statement">if</span> ( elem.nodeType <span class="Statement">&lt;</span> <span class="Constant">6</span> ) {
					<span class="Statement">return</span> <span class="Constant">false</span>;
				}
			}
			<span class="Statement">return</span> <span class="Constant">true</span>;
		},

		<span class="Constant">&quot;parent&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> <span class="Statement">!</span>Expr.pseudos[<span class="Constant">&quot;empty&quot;</span>]( elem );
		},

<span class="Comment">		// Element/input types</span>
		<span class="Constant">&quot;header&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> rheader.test( elem.nodeName );
		},

		<span class="Constant">&quot;input&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> rinputs.test( elem.nodeName );
		},

		<span class="Constant">&quot;button&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Type">var</span> name <span class="Statement">=</span> elem.nodeName.toLowerCase();
			<span class="Statement">return</span> name <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">&amp;&amp;</span> elem.type <span class="Statement">===</span> <span class="Constant">&quot;button&quot;</span> <span class="Statement">||</span> name <span class="Statement">===</span> <span class="Constant">&quot;button&quot;</span>;
		},

		<span class="Constant">&quot;text&quot;</span>: <span class="Type">function</span>( elem ) {
			<span class="Type">var</span> attr;
			<span class="Statement">return</span> elem.nodeName.toLowerCase() <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">&amp;&amp;</span>
				elem.type <span class="Statement">===</span> <span class="Constant">&quot;text&quot;</span> <span class="Statement">&amp;&amp;</span>

<span class="Comment">				// Support: IE&lt;8</span>
<span class="Comment">				// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;</span>
				( (attr <span class="Statement">=</span> elem.getAttribute(<span class="Constant">&quot;type&quot;</span>)) <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">||</span> attr.toLowerCase() <span class="Statement">===</span> <span class="Constant">&quot;text&quot;</span> );
		},

<span class="Comment">		// Position-in-collection</span>
		<span class="Constant">&quot;first&quot;</span>: createPositionalPseudo(<span class="Type">function</span>() {
			<span class="Statement">return</span> [ <span class="Constant">0</span> ];
		}),

		<span class="Constant">&quot;last&quot;</span>: createPositionalPseudo(<span class="Type">function</span>( matchIndexes, length ) {
			<span class="Statement">return</span> [ length <span class="Statement">-</span> <span class="Constant">1</span> ];
		}),

		<span class="Constant">&quot;eq&quot;</span>: createPositionalPseudo(<span class="Type">function</span>( matchIndexes, length, argument ) {
			<span class="Statement">return</span> [ argument <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span> argument <span class="Statement">+</span> length <span class="Statement">:</span> argument ];
		}),

		<span class="Constant">&quot;even&quot;</span>: createPositionalPseudo(<span class="Type">function</span>( matchIndexes, length ) {
			<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>;
			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i <span class="Statement">+=</span> <span class="Constant">2</span> ) {
				matchIndexes.push( i );
			}
			<span class="Statement">return</span> matchIndexes;
		}),

		<span class="Constant">&quot;odd&quot;</span>: createPositionalPseudo(<span class="Type">function</span>( matchIndexes, length ) {
			<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">1</span>;
			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i <span class="Statement">+=</span> <span class="Constant">2</span> ) {
				matchIndexes.push( i );
			}
			<span class="Statement">return</span> matchIndexes;
		}),

		<span class="Constant">&quot;lt&quot;</span>: createPositionalPseudo(<span class="Type">function</span>( matchIndexes, length, argument ) {
			<span class="Type">var</span> i <span class="Statement">=</span> argument <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span> argument <span class="Statement">+</span> length <span class="Statement">:</span> argument;
			<span class="Statement">for</span> ( ; <span class="Statement">--</span>i <span class="Statement">&gt;=</span> <span class="Constant">0</span>; ) {
				matchIndexes.push( i );
			}
			<span class="Statement">return</span> matchIndexes;
		}),

		<span class="Constant">&quot;gt&quot;</span>: createPositionalPseudo(<span class="Type">function</span>( matchIndexes, length, argument ) {
			<span class="Type">var</span> i <span class="Statement">=</span> argument <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span> argument <span class="Statement">+</span> length <span class="Statement">:</span> argument;
			<span class="Statement">for</span> ( ; <span class="Statement">++</span>i <span class="Statement">&lt;</span> length; ) {
				matchIndexes.push( i );
			}
			<span class="Statement">return</span> matchIndexes;
		})
	}
};

Expr.pseudos[<span class="Constant">&quot;nth&quot;</span>] <span class="Statement">=</span> Expr.pseudos[<span class="Constant">&quot;eq&quot;</span>];

<span class="Comment">// Add button/input type pseudos</span>
<span class="Statement">for</span> ( i <span class="Statement">in</span> { radio: <span class="Constant">true</span>, checkbox: <span class="Constant">true</span>, file: <span class="Constant">true</span>, password: <span class="Constant">true</span>, image: <span class="Constant">true</span> } ) {
	Expr.pseudos[ i ] <span class="Statement">=</span> createInputPseudo( i );
}
<span class="Statement">for</span> ( i <span class="Statement">in</span> { submit: <span class="Constant">true</span>, reset: <span class="Constant">true</span> } ) {
	Expr.pseudos[ i ] <span class="Statement">=</span> createButtonPseudo( i );
}

<span class="Comment">// Easy API for creating new setFilters</span>
<span class="Type">function</span> <span class="Identifier">setFilters</span>() {}
setFilters.<span class="Special">prototype</span> <span class="Statement">=</span> Expr.filters <span class="Statement">=</span> Expr.pseudos;
Expr.setFilters <span class="Statement">=</span> <span class="Statement">new</span> setFilters();

<span class="Type">function</span> <span class="Identifier">tokenize</span>( selector, parseOnly ) {
	<span class="Type">var</span> matched, match, tokens, type,
		soFar, groups, preFilters,
		cached <span class="Statement">=</span> tokenCache[ selector <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ];

	<span class="Statement">if</span> ( cached ) {
		<span class="Statement">return</span> parseOnly <span class="Statement">?</span> <span class="Constant">0</span> <span class="Statement">:</span> cached.slice( <span class="Constant">0</span> );
	}

	soFar <span class="Statement">=</span> selector;
	groups <span class="Statement">=</span> [];
	preFilters <span class="Statement">=</span> Expr.preFilter;

	<span class="Statement">while</span> ( soFar ) {

<span class="Comment">		// Comma and first run</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>matched <span class="Statement">||</span> (match <span class="Statement">=</span> rcomma.exec( soFar )) ) {
			<span class="Statement">if</span> ( match ) {
<span class="Comment">				// Don't consume trailing commas as valid</span>
				soFar <span class="Statement">=</span> soFar.slice( match[<span class="Constant">0</span>].length ) <span class="Statement">||</span> soFar;
			}
			groups.push( (tokens <span class="Statement">=</span> []) );
		}

		matched <span class="Statement">=</span> <span class="Constant">false</span>;

<span class="Comment">		// Combinators</span>
		<span class="Statement">if</span> ( (match <span class="Statement">=</span> rcombinators.exec( soFar )) ) {
			matched <span class="Statement">=</span> match.shift();
			tokens.push({
				value: matched,
<span class="Comment">				// Cast descendant combinators to space</span>
				type: match[<span class="Constant">0</span>].replace( rtrim, <span class="Constant">&quot; &quot;</span> )
			});
			soFar <span class="Statement">=</span> soFar.slice( matched.length );
		}

<span class="Comment">		// Filters</span>
		<span class="Statement">for</span> ( type <span class="Statement">in</span> Expr.filter ) {
			<span class="Statement">if</span> ( (match <span class="Statement">=</span> matchExpr[ type ].exec( soFar )) <span class="Statement">&amp;&amp;</span> (<span class="Statement">!</span>preFilters[ type ] <span class="Statement">||</span>
				(match <span class="Statement">=</span> preFilters[ type ]( match ))) ) {
				matched <span class="Statement">=</span> match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar <span class="Statement">=</span> soFar.slice( matched.length );
			}
		}

		<span class="Statement">if</span> ( <span class="Statement">!</span>matched ) {
			<span class="Statement">break</span>;
		}
	}

<span class="Comment">	// Return the length of the invalid excess</span>
<span class="Comment">	// if we're just parsing</span>
<span class="Comment">	// Otherwise, throw an error or return tokens</span>
	<span class="Statement">return</span> parseOnly <span class="Statement">?</span>
		soFar.length <span class="Statement">:</span>
		soFar <span class="Statement">?</span>
			Sizzle.error( selector ) <span class="Statement">:</span>
<span class="Comment">			// Cache the tokens</span>
			tokenCache( selector, groups ).slice( <span class="Constant">0</span> );
}

<span class="Type">function</span> <span class="Identifier">toSelector</span>( tokens ) {
	<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
		len <span class="Statement">=</span> tokens.length,
		selector <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
		selector <span class="Statement">+=</span> tokens[i].value;
	}
	<span class="Statement">return</span> selector;
}

<span class="Type">function</span> <span class="Identifier">addCombinator</span>( matcher, combinator, base ) {
	<span class="Type">var</span> dir <span class="Statement">=</span> combinator.dir,
		checkNonElements <span class="Statement">=</span> base <span class="Statement">&amp;&amp;</span> dir <span class="Statement">===</span> <span class="Constant">&quot;parentNode&quot;</span>,
		doneName <span class="Statement">=</span> done<span class="Statement">++</span>;

	<span class="Statement">return</span> combinator.first <span class="Statement">?</span>
<span class="Comment">		// Check against closest ancestor/preceding element</span>
		<span class="Type">function</span>( elem, context, xml ) {
			<span class="Statement">while</span> ( (elem <span class="Statement">=</span> elem[ dir ]) ) {
				<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> checkNonElements ) {
					<span class="Statement">return</span> matcher( elem, context, xml );
				}
			}
		} <span class="Statement">:</span>

<span class="Comment">		// Check against all ancestor/preceding elements</span>
		<span class="Type">function</span>( elem, context, xml ) {
			<span class="Type">var</span> oldCache, outerCache,
				newCache <span class="Statement">=</span> [ dirruns, doneName ];

<span class="Comment">			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching</span>
			<span class="Statement">if</span> ( xml ) {
				<span class="Statement">while</span> ( (elem <span class="Statement">=</span> elem[ dir ]) ) {
					<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> checkNonElements ) {
						<span class="Statement">if</span> ( matcher( elem, context, xml ) ) {
							<span class="Statement">return</span> <span class="Constant">true</span>;
						}
					}
				}
			} <span class="Statement">else</span> {
				<span class="Statement">while</span> ( (elem <span class="Statement">=</span> elem[ dir ]) ) {
					<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> checkNonElements ) {
						outerCache <span class="Statement">=</span> elem[ expando ] <span class="Statement">||</span> (elem[ expando ] <span class="Statement">=</span> {});
						<span class="Statement">if</span> ( (oldCache <span class="Statement">=</span> outerCache[ dir ]) <span class="Statement">&amp;&amp;</span>
							oldCache[ <span class="Constant">0</span> ] <span class="Statement">===</span> dirruns <span class="Statement">&amp;&amp;</span> oldCache[ <span class="Constant">1</span> ] <span class="Statement">===</span> doneName ) {

<span class="Comment">							// Assign to newCache so results back-propagate to previous elements</span>
							<span class="Statement">return</span> (newCache[ <span class="Constant">2</span> ] <span class="Statement">=</span> oldCache[ <span class="Constant">2</span> ]);
						} <span class="Statement">else</span> {
<span class="Comment">							// Reuse newcache so results back-propagate to previous elements</span>
							outerCache[ dir ] <span class="Statement">=</span> newCache;

<span class="Comment">							// A match means we're done; a fail means we have to keep checking</span>
							<span class="Statement">if</span> ( (newCache[ <span class="Constant">2</span> ] <span class="Statement">=</span> matcher( elem, context, xml )) ) {
								<span class="Statement">return</span> <span class="Constant">true</span>;
							}
						}
					}
				}
			}
		};
}

<span class="Type">function</span> <span class="Identifier">elementMatcher</span>( matchers ) {
	<span class="Statement">return</span> matchers.length <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">?</span>
		<span class="Type">function</span>( elem, context, xml ) {
			<span class="Type">var</span> i <span class="Statement">=</span> matchers.length;
			<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
				<span class="Statement">if</span> ( <span class="Statement">!</span>matchers[i]( elem, context, xml ) ) {
					<span class="Statement">return</span> <span class="Constant">false</span>;
				}
			}
			<span class="Statement">return</span> <span class="Constant">true</span>;
		} <span class="Statement">:</span>
		matchers[<span class="Constant">0</span>];
}

<span class="Type">function</span> <span class="Identifier">condense</span>( unmatched, map, filter, context, xml ) {
	<span class="Type">var</span> elem,
		newUnmatched <span class="Statement">=</span> [],
		i <span class="Statement">=</span> <span class="Constant">0</span>,
		len <span class="Statement">=</span> unmatched.length,
		mapped <span class="Statement">=</span> map <span class="Statement">!=</span> <span class="Type">null</span>;

	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
		<span class="Statement">if</span> ( (elem <span class="Statement">=</span> unmatched[i]) ) {
			<span class="Statement">if</span> ( <span class="Statement">!</span>filter <span class="Statement">||</span> filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				<span class="Statement">if</span> ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	<span class="Statement">return</span> newUnmatched;
}

<span class="Type">function</span> <span class="Identifier">setMatcher</span>( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	<span class="Statement">if</span> ( postFilter <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>postFilter[ expando ] ) {
		postFilter <span class="Statement">=</span> setMatcher( postFilter );
	}
	<span class="Statement">if</span> ( postFinder <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>postFinder[ expando ] ) {
		postFinder <span class="Statement">=</span> setMatcher( postFinder, postSelector );
	}
	<span class="Statement">return</span> markFunction(<span class="Type">function</span>( seed, results, context, xml ) {
		<span class="Type">var</span> temp, i, elem,
			preMap <span class="Statement">=</span> [],
			postMap <span class="Statement">=</span> [],
			preexisting <span class="Statement">=</span> results.length,

<span class="Comment">			// Get initial elements from seed or context</span>
			elems <span class="Statement">=</span> seed <span class="Statement">||</span> multipleContexts( selector <span class="Statement">||</span> <span class="Constant">&quot;*&quot;</span>, context.nodeType <span class="Statement">?</span> [ context ] <span class="Statement">:</span> context, [] ),

<span class="Comment">			// Prefilter to get matcher input, preserving a map for seed-results synchronization</span>
			matcherIn <span class="Statement">=</span> preFilter <span class="Statement">&amp;&amp;</span> ( seed <span class="Statement">||</span> <span class="Statement">!</span>selector ) <span class="Statement">?</span>
				condense( elems, preMap, preFilter, context, xml ) <span class="Statement">:</span>
				elems,

			matcherOut <span class="Statement">=</span> matcher <span class="Statement">?</span>
<span class="Comment">				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</span>
				postFinder <span class="Statement">||</span> ( seed <span class="Statement">?</span> preFilter <span class="Statement">:</span> preexisting <span class="Statement">||</span> postFilter ) <span class="Statement">?</span>

<span class="Comment">					// ...intermediate processing is necessary</span>
					[] <span class="Statement">:</span>

<span class="Comment">					// ...otherwise use results directly</span>
					results <span class="Statement">:</span>
				matcherIn;

<span class="Comment">		// Find primary matches</span>
		<span class="Statement">if</span> ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

<span class="Comment">		// Apply postFilter</span>
		<span class="Statement">if</span> ( postFilter ) {
			temp <span class="Statement">=</span> condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

<span class="Comment">			// Un-match failing elements by moving them back to matcherIn</span>
			i <span class="Statement">=</span> temp.length;
			<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
				<span class="Statement">if</span> ( (elem <span class="Statement">=</span> temp[i]) ) {
					matcherOut[ postMap[i] ] <span class="Statement">=</span> <span class="Statement">!</span>(matcherIn[ postMap[i] ] <span class="Statement">=</span> elem);
				}
			}
		}

		<span class="Statement">if</span> ( seed ) {
			<span class="Statement">if</span> ( postFinder <span class="Statement">||</span> preFilter ) {
				<span class="Statement">if</span> ( postFinder ) {
<span class="Comment">					// Get the final matcherOut by condensing this intermediate into postFinder contexts</span>
					temp <span class="Statement">=</span> [];
					i <span class="Statement">=</span> matcherOut.length;
					<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
						<span class="Statement">if</span> ( (elem <span class="Statement">=</span> matcherOut[i]) ) {
<span class="Comment">							// Restore matcherIn since elem is not yet a final match</span>
							temp.push( (matcherIn[i] <span class="Statement">=</span> elem) );
						}
					}
					postFinder( <span class="Type">null</span>, (matcherOut <span class="Statement">=</span> []), temp, xml );
				}

<span class="Comment">				// Move matched elements from seed to results to keep them synchronized</span>
				i <span class="Statement">=</span> matcherOut.length;
				<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
					<span class="Statement">if</span> ( (elem <span class="Statement">=</span> matcherOut[i]) <span class="Statement">&amp;&amp;</span>
						(temp <span class="Statement">=</span> postFinder <span class="Statement">?</span> indexOf.call( seed, elem ) <span class="Statement">:</span> preMap[i]) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span> ) {

						seed[temp] <span class="Statement">=</span> <span class="Statement">!</span>(results[temp] <span class="Statement">=</span> elem);
					}
				}
			}

<span class="Comment">		// Add elements to results, through postFinder if defined</span>
		} <span class="Statement">else</span> {
			matcherOut <span class="Statement">=</span> condense(
				matcherOut <span class="Statement">===</span> results <span class="Statement">?</span>
					matcherOut.splice( preexisting, matcherOut.length ) <span class="Statement">:</span>
					matcherOut
			);
			<span class="Statement">if</span> ( postFinder ) {
				postFinder( <span class="Type">null</span>, results, matcherOut, xml );
			} <span class="Statement">else</span> {
				push.apply( results, matcherOut );
			}
		}
	});
}

<span class="Type">function</span> <span class="Identifier">matcherFromTokens</span>( tokens ) {
	<span class="Type">var</span> checkContext, matcher, j,
		len <span class="Statement">=</span> tokens.length,
		leadingRelative <span class="Statement">=</span> Expr.relative[ tokens[<span class="Constant">0</span>].type ],
		implicitRelative <span class="Statement">=</span> leadingRelative <span class="Statement">||</span> Expr.relative[<span class="Constant">&quot; &quot;</span>],
		i <span class="Statement">=</span> leadingRelative <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Constant">0</span>,

<span class="Comment">		// The foundational matcher ensures that elements are reachable from top-level context(s)</span>
		matchContext <span class="Statement">=</span> addCombinator( <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> elem <span class="Statement">===</span> checkContext;
		}, implicitRelative, <span class="Constant">true</span> ),
		matchAnyContext <span class="Statement">=</span> addCombinator( <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> indexOf.call( checkContext, elem ) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span>;
		}, implicitRelative, <span class="Constant">true</span> ),
		matchers <span class="Statement">=</span> [ <span class="Type">function</span>( elem, context, xml ) {
			<span class="Statement">return</span> ( <span class="Statement">!</span>leadingRelative <span class="Statement">&amp;&amp;</span> ( xml <span class="Statement">||</span> context <span class="Statement">!==</span> outermostContext ) ) <span class="Statement">||</span> (
				(checkContext <span class="Statement">=</span> context).nodeType <span class="Statement">?</span>
					matchContext( elem, context, xml ) <span class="Statement">:</span>
					matchAnyContext( elem, context, xml ) );
		} ];

	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
		<span class="Statement">if</span> ( (matcher <span class="Statement">=</span> Expr.relative[ tokens[i].type ]) ) {
			matchers <span class="Statement">=</span> [ addCombinator(elementMatcher( matchers ), matcher) ];
		} <span class="Statement">else</span> {
			matcher <span class="Statement">=</span> Expr.filter[ tokens[i].type ].apply( <span class="Type">null</span>, tokens[i].matches );

<span class="Comment">			// Return special upon seeing a positional matcher</span>
			<span class="Statement">if</span> ( matcher[ expando ] ) {
<span class="Comment">				// Find the next relative operator (if any) for proper handling</span>
				j <span class="Statement">=</span> <span class="Statement">++</span>i;
				<span class="Statement">for</span> ( ; j <span class="Statement">&lt;</span> len; j<span class="Statement">++</span> ) {
					<span class="Statement">if</span> ( Expr.relative[ tokens[j].type ] ) {
						<span class="Statement">break</span>;
					}
				}
				<span class="Statement">return</span> setMatcher(
					i <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> elementMatcher( matchers ),
					i <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> toSelector(
<span class="Comment">						// If the preceding token was a descendant combinator, insert an implicit any-element `*`</span>
						tokens.slice( <span class="Constant">0</span>, i <span class="Statement">-</span> <span class="Constant">1</span> ).concat({ value: tokens[ i <span class="Statement">-</span> <span class="Constant">2</span> ].type <span class="Statement">===</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">?</span> <span class="Constant">&quot;*&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;&quot;</span> })
					).replace( rtrim, <span class="Constant">&quot;$1&quot;</span> ),
					matcher,
					i <span class="Statement">&lt;</span> j <span class="Statement">&amp;&amp;</span> matcherFromTokens( tokens.slice( i, j ) ),
					j <span class="Statement">&lt;</span> len <span class="Statement">&amp;&amp;</span> matcherFromTokens( (tokens <span class="Statement">=</span> tokens.slice( j )) ),
					j <span class="Statement">&lt;</span> len <span class="Statement">&amp;&amp;</span> toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	<span class="Statement">return</span> elementMatcher( matchers );
}

<span class="Type">function</span> <span class="Identifier">matcherFromGroupMatchers</span>( elementMatchers, setMatchers ) {
	<span class="Type">var</span> bySet <span class="Statement">=</span> setMatchers.length <span class="Statement">&gt;</span> <span class="Constant">0</span>,
		byElement <span class="Statement">=</span> elementMatchers.length <span class="Statement">&gt;</span> <span class="Constant">0</span>,
		superMatcher <span class="Statement">=</span> <span class="Type">function</span>( seed, context, xml, results, outermost ) {
			<span class="Type">var</span> elem, j, matcher,
				matchedCount <span class="Statement">=</span> <span class="Constant">0</span>,
				i <span class="Statement">=</span> <span class="Constant">&quot;0&quot;</span>,
				unmatched <span class="Statement">=</span> seed <span class="Statement">&amp;&amp;</span> [],
				setMatched <span class="Statement">=</span> [],
				contextBackup <span class="Statement">=</span> outermostContext,
<span class="Comment">				// We must always have either seed elements or outermost context</span>
				elems <span class="Statement">=</span> seed <span class="Statement">||</span> byElement <span class="Statement">&amp;&amp;</span> Expr.find[<span class="Constant">&quot;TAG&quot;</span>]( <span class="Constant">&quot;*&quot;</span>, outermost ),
<span class="Comment">				// Use integer dirruns iff this is the outermost matcher</span>
				dirrunsUnique <span class="Statement">=</span> (dirruns <span class="Statement">+=</span> contextBackup <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Special">Math</span>.random() <span class="Statement">||</span> <span class="Constant">0.1</span>),
				len <span class="Statement">=</span> elems.length;

			<span class="Statement">if</span> ( outermost ) {
				outermostContext <span class="Statement">=</span> context <span class="Statement">!==</span> <span class="Special">document</span> <span class="Statement">&amp;&amp;</span> context;
			}

<span class="Comment">			// Add elements passing elementMatchers directly to results</span>
<span class="Comment">			// Keep `i` a string if there are no elements so `matchedCount` will be &quot;00&quot; below</span>
<span class="Comment">			// Support: IE&lt;9, Safari</span>
<span class="Comment">			// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id</span>
			<span class="Statement">for</span> ( ; i <span class="Statement">!==</span> len <span class="Statement">&amp;&amp;</span> (elem <span class="Statement">=</span> elems[i]) <span class="Statement">!=</span> <span class="Type">null</span>; i<span class="Statement">++</span> ) {
				<span class="Statement">if</span> ( byElement <span class="Statement">&amp;&amp;</span> elem ) {
					j <span class="Statement">=</span> <span class="Constant">0</span>;
					<span class="Statement">while</span> ( (matcher <span class="Statement">=</span> elementMatchers[j<span class="Statement">++</span>]) ) {
						<span class="Statement">if</span> ( matcher( elem, context, xml ) ) {
							results.push( elem );
							<span class="Statement">break</span>;
						}
					}
					<span class="Statement">if</span> ( outermost ) {
						dirruns <span class="Statement">=</span> dirrunsUnique;
					}
				}

<span class="Comment">				// Track unmatched elements for set filters</span>
				<span class="Statement">if</span> ( bySet ) {
<span class="Comment">					// They will have gone through all possible matchers</span>
					<span class="Statement">if</span> ( (elem <span class="Statement">=</span> <span class="Statement">!</span>matcher <span class="Statement">&amp;&amp;</span> elem) ) {
						matchedCount<span class="Statement">--</span>;
					}

<span class="Comment">					// Lengthen the array for every element, matched or not</span>
					<span class="Statement">if</span> ( seed ) {
						unmatched.push( elem );
					}
				}
			}

<span class="Comment">			// Apply set filters to unmatched elements</span>
			matchedCount <span class="Statement">+=</span> i;
			<span class="Statement">if</span> ( bySet <span class="Statement">&amp;&amp;</span> i <span class="Statement">!==</span> matchedCount ) {
				j <span class="Statement">=</span> <span class="Constant">0</span>;
				<span class="Statement">while</span> ( (matcher <span class="Statement">=</span> setMatchers[j<span class="Statement">++</span>]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				<span class="Statement">if</span> ( seed ) {
<span class="Comment">					// Reintegrate element matches to eliminate the need for sorting</span>
					<span class="Statement">if</span> ( matchedCount <span class="Statement">&gt;</span> <span class="Constant">0</span> ) {
						<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
							<span class="Statement">if</span> ( <span class="Statement">!</span>(unmatched[i] <span class="Statement">||</span> setMatched[i]) ) {
								setMatched[i] <span class="Statement">=</span> pop.call( results );
							}
						}
					}

<span class="Comment">					// Discard index placeholder values to get only actual matches</span>
					setMatched <span class="Statement">=</span> condense( setMatched );
				}

<span class="Comment">				// Add matches to results</span>
				push.apply( results, setMatched );

<span class="Comment">				// Seedless set matches succeeding multiple successful matchers stipulate sorting</span>
				<span class="Statement">if</span> ( outermost <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>seed <span class="Statement">&amp;&amp;</span> setMatched.length <span class="Statement">&gt;</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span>
					( matchedCount <span class="Statement">+</span> setMatchers.length ) <span class="Statement">&gt;</span> <span class="Constant">1</span> ) {

					Sizzle.uniqueSort( results );
				}
			}

<span class="Comment">			// Override manipulation of globals by nested matchers</span>
			<span class="Statement">if</span> ( outermost ) {
				dirruns <span class="Statement">=</span> dirrunsUnique;
				outermostContext <span class="Statement">=</span> contextBackup;
			}

			<span class="Statement">return</span> unmatched;
		};

	<span class="Statement">return</span> bySet <span class="Statement">?</span>
		markFunction( superMatcher ) <span class="Statement">:</span>
		superMatcher;
}

compile <span class="Statement">=</span> Sizzle.compile <span class="Statement">=</span> <span class="Type">function</span>( selector, group /* Internal Use Only */ ) {
	<span class="Type">var</span> i,
		setMatchers <span class="Statement">=</span> [],
		elementMatchers <span class="Statement">=</span> [],
		cached <span class="Statement">=</span> compilerCache[ selector <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ];

	<span class="Statement">if</span> ( <span class="Statement">!</span>cached ) {
<span class="Comment">		// Generate a function of recursive functions that can be used to check each element</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>group ) {
			group <span class="Statement">=</span> tokenize( selector );
		}
		i <span class="Statement">=</span> group.length;
		<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
			cached <span class="Statement">=</span> matcherFromTokens( group[i] );
			<span class="Statement">if</span> ( cached[ expando ] ) {
				setMatchers.push( cached );
			} <span class="Statement">else</span> {
				elementMatchers.push( cached );
			}
		}

<span class="Comment">		// Cache the compiled function</span>
		cached <span class="Statement">=</span> compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	<span class="Statement">return</span> cached;
};

<span class="Type">function</span> <span class="Identifier">multipleContexts</span>( selector, contexts, results ) {
	<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
		len <span class="Statement">=</span> contexts.length;
	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
		Sizzle( selector, contexts[i], results );
	}
	<span class="Statement">return</span> results;
}

<span class="Type">function</span> <span class="Identifier">select</span>( selector, context, results, seed ) {
	<span class="Type">var</span> i, tokens, token, type, find,
		match <span class="Statement">=</span> tokenize( selector );

	<span class="Statement">if</span> ( <span class="Statement">!</span>seed ) {
<span class="Comment">		// Try to minimize operations if there is only one group</span>
		<span class="Statement">if</span> ( match.length <span class="Statement">===</span> <span class="Constant">1</span> ) {

<span class="Comment">			// Take a shortcut and set the context if the root selector is an ID</span>
			tokens <span class="Statement">=</span> match[<span class="Constant">0</span>] <span class="Statement">=</span> match[<span class="Constant">0</span>].slice( <span class="Constant">0</span> );
			<span class="Statement">if</span> ( tokens.length <span class="Statement">&gt;</span> <span class="Constant">2</span> <span class="Statement">&amp;&amp;</span> (token <span class="Statement">=</span> tokens[<span class="Constant">0</span>]).type <span class="Statement">===</span> <span class="Constant">&quot;ID&quot;</span> <span class="Statement">&amp;&amp;</span>
					support.getById <span class="Statement">&amp;&amp;</span> context.nodeType <span class="Statement">===</span> <span class="Constant">9</span> <span class="Statement">&amp;&amp;</span> documentIsHTML <span class="Statement">&amp;&amp;</span>
					Expr.relative[ tokens[<span class="Constant">1</span>].type ] ) {

				context <span class="Statement">=</span> ( Expr.find[<span class="Constant">&quot;ID&quot;</span>]( token.matches[<span class="Constant">0</span>].replace(runescape, funescape), context ) <span class="Statement">||</span> [] )[<span class="Constant">0</span>];
				<span class="Statement">if</span> ( <span class="Statement">!</span>context ) {
					<span class="Statement">return</span> results;
				}
				selector <span class="Statement">=</span> selector.slice( tokens.shift().value.length );
			}

<span class="Comment">			// Fetch a seed set for right-to-left matching</span>
			i <span class="Statement">=</span> matchExpr[<span class="Constant">&quot;needsContext&quot;</span>].test( selector ) <span class="Statement">?</span> <span class="Constant">0</span> <span class="Statement">:</span> tokens.length;
			<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
				token <span class="Statement">=</span> tokens[i];

<span class="Comment">				// Abort if we hit a combinator</span>
				<span class="Statement">if</span> ( Expr.relative[ (type <span class="Statement">=</span> token.type) ] ) {
					<span class="Statement">break</span>;
				}
				<span class="Statement">if</span> ( (find <span class="Statement">=</span> Expr.find[ type ]) ) {
<span class="Comment">					// Search, expanding context for leading sibling combinators</span>
					<span class="Statement">if</span> ( (seed <span class="Statement">=</span> find(
						token.matches[<span class="Constant">0</span>].replace( runescape, funescape ),
						rsibling.test( tokens[<span class="Constant">0</span>].type ) <span class="Statement">&amp;&amp;</span> testContext( context.parentNode ) <span class="Statement">||</span> context
					)) ) {

<span class="Comment">						// If seed is empty or no tokens remain, we can return early</span>
						tokens.splice( i, <span class="Constant">1</span> );
						selector <span class="Statement">=</span> seed.length <span class="Statement">&amp;&amp;</span> toSelector( tokens );
						<span class="Statement">if</span> ( <span class="Statement">!</span>selector ) {
							push.apply( results, seed );
							<span class="Statement">return</span> results;
						}

						<span class="Statement">break</span>;
					}
				}
			}
		}
	}

<span class="Comment">	// Compile and execute a filtering function</span>
<span class="Comment">	// Provide `match` to avoid retokenization if we modified the selector above</span>
	compile( selector, match )(
		seed,
		context,
		<span class="Statement">!</span>documentIsHTML,
		results,
		rsibling.test( selector ) <span class="Statement">&amp;&amp;</span> testContext( context.parentNode ) <span class="Statement">||</span> context
	);
	<span class="Statement">return</span> results;
}

<span class="Comment">// One-time assignments</span>

<span class="Comment">// Sort stability</span>
support.sortStable <span class="Statement">=</span> expando.split(<span class="Constant">&quot;&quot;</span>).sort( sortOrder ).join(<span class="Constant">&quot;&quot;</span>) <span class="Statement">===</span> expando;

<span class="Comment">// Support: Chrome&lt;14</span>
<span class="Comment">// Always assume duplicates if they aren't passed to the comparison function</span>
support.detectDuplicates <span class="Statement">=</span> <span class="Statement">!!</span>hasDuplicate;

<span class="Comment">// Initialize against the default document</span>
setDocument();

<span class="Comment">// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)</span>
<span class="Comment">// Detached nodes confoundingly follow *each other*</span>
support.sortDetached <span class="Statement">=</span> assert(<span class="Type">function</span>( div1 ) {
<span class="Comment">	// Should return 1, but returns 4 (following)</span>
	<span class="Statement">return</span> div1.compareDocumentPosition( <span class="Special">document</span>.createElement(<span class="Constant">&quot;div&quot;</span>) ) <span class="Statement">&amp;</span> <span class="Constant">1</span>;
});

<span class="Comment">// Support: IE&lt;8</span>
<span class="Comment">// Prevent attribute/property &quot;interpolation&quot;</span>
<span class="Comment">// <a href="http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</a></span>
<span class="Statement">if</span> ( <span class="Statement">!</span>assert(<span class="Type">function</span>( div ) {
	div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&lt;a href='#'&gt;&lt;/a&gt;&quot;</span>;
	<span class="Statement">return</span> div.firstChild.getAttribute(<span class="Constant">&quot;href&quot;</span>) <span class="Statement">===</span> <span class="Constant">&quot;#&quot;</span> ;
}) ) {
	addHandle( <span class="Constant">&quot;type|href|height|width&quot;</span>, <span class="Type">function</span>( elem, name, isXML ) {
		<span class="Statement">if</span> ( <span class="Statement">!</span>isXML ) {
			<span class="Statement">return</span> elem.getAttribute( name, name.toLowerCase() <span class="Statement">===</span> <span class="Constant">&quot;type&quot;</span> <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Constant">2</span> );
		}
	});
}

<span class="Comment">// Support: IE&lt;9</span>
<span class="Comment">// Use defaultValue in place of getAttribute(&quot;value&quot;)</span>
<span class="Statement">if</span> ( <span class="Statement">!</span>support.attributes <span class="Statement">||</span> <span class="Statement">!</span>assert(<span class="Type">function</span>( div ) {
	div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&lt;input/&gt;&quot;</span>;
	div.firstChild.setAttribute( <span class="Constant">&quot;value&quot;</span>, <span class="Constant">&quot;&quot;</span> );
	<span class="Statement">return</span> div.firstChild.getAttribute( <span class="Constant">&quot;value&quot;</span> ) <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span>;
}) ) {
	addHandle( <span class="Constant">&quot;value&quot;</span>, <span class="Type">function</span>( elem, name, isXML ) {
		<span class="Statement">if</span> ( <span class="Statement">!</span>isXML <span class="Statement">&amp;&amp;</span> elem.nodeName.toLowerCase() <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> ) {
			<span class="Statement">return</span> elem.defaultValue;
		}
	});
}

<span class="Comment">// Support: IE&lt;9</span>
<span class="Comment">// Use getAttributeNode to fetch booleans when getAttribute lies</span>
<span class="Statement">if</span> ( <span class="Statement">!</span>assert(<span class="Type">function</span>( div ) {
	<span class="Statement">return</span> div.getAttribute(<span class="Constant">&quot;disabled&quot;</span>) <span class="Statement">==</span> <span class="Type">null</span>;
}) ) {
	addHandle( booleans, <span class="Type">function</span>( elem, name, isXML ) {
		<span class="Type">var</span> val;
		<span class="Statement">if</span> ( <span class="Statement">!</span>isXML ) {
			<span class="Statement">return</span> elem[ name ] <span class="Statement">===</span> <span class="Constant">true</span> <span class="Statement">?</span> name.toLowerCase() <span class="Statement">:</span>
					(val <span class="Statement">=</span> elem.getAttributeNode( name )) <span class="Statement">&amp;&amp;</span> val.specified <span class="Statement">?</span>
					val.value <span class="Statement">:</span>
				<span class="Type">null</span>;
		}
	});
}

<span class="Statement">return</span> Sizzle;

})( <span class="Special">window</span> );



jQuery.find <span class="Statement">=</span> Sizzle;
jQuery.expr <span class="Statement">=</span> Sizzle.selectors;
jQuery.expr[<span class="Constant">&quot;:&quot;</span>] <span class="Statement">=</span> jQuery.expr.pseudos;
jQuery.unique <span class="Statement">=</span> Sizzle.uniqueSort;
jQuery.text <span class="Statement">=</span> Sizzle.getText;
jQuery.isXMLDoc <span class="Statement">=</span> Sizzle.isXML;
jQuery.contains <span class="Statement">=</span> Sizzle.contains;



<span class="Type">var</span> rneedsContext <span class="Statement">=</span> jQuery.expr.match.needsContext;

<span class="Type">var</span> rsingleTag <span class="Statement">=</span> (<span class="Constant">/</span><span class="Special">^</span><span class="Constant">&lt;</span><span class="Constant">(</span><span class="Special">\w</span><span class="Special">+</span><span class="Constant">)</span><span class="Special">\s</span><span class="Special">*</span><span class="Special">\/</span><span class="Special">?</span><span class="Constant">&gt;</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">&lt;</span><span class="Special">\/</span><span class="Special">\1</span><span class="Constant">&gt;</span><span class="Statement">|</span><span class="Constant">)</span><span class="Special">$</span><span class="Constant">/</span>);



<span class="Type">var</span> risSimple <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">.</span><span class="Constant">[^:#\[\.,]</span><span class="Special">*</span><span class="Special">$</span><span class="Constant">/</span>;

<span class="Comment">// Implement the identical functionality for filter and not</span>
<span class="Type">function</span> <span class="Identifier">winnow</span>( elements, qualifier, not ) {
	<span class="Statement">if</span> ( jQuery.isFunction( qualifier ) ) {
		<span class="Statement">return</span> jQuery.grep( elements, <span class="Type">function</span>( elem, i ) {
			<span class="Comment">/* jshint -W018 */</span>
			<span class="Statement">return</span> <span class="Statement">!!</span>qualifier.call( elem, i, elem ) <span class="Statement">!==</span> not;
		});

	}

	<span class="Statement">if</span> ( qualifier.nodeType ) {
		<span class="Statement">return</span> jQuery.grep( elements, <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> ( elem <span class="Statement">===</span> qualifier ) <span class="Statement">!==</span> not;
		});

	}

	<span class="Statement">if</span> ( <span class="Statement">typeof</span> qualifier <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
		<span class="Statement">if</span> ( risSimple.test( qualifier ) ) {
			<span class="Statement">return</span> jQuery.filter( qualifier, elements, not );
		}

		qualifier <span class="Statement">=</span> jQuery.filter( qualifier, elements );
	}

	<span class="Statement">return</span> jQuery.grep( elements, <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> ( indexOf.call( qualifier, elem ) <span class="Statement">&gt;=</span> <span class="Constant">0</span> ) <span class="Statement">!==</span> not;
	});
}

jQuery.filter <span class="Statement">=</span> <span class="Type">function</span>( expr, elems, not ) {
	<span class="Type">var</span> elem <span class="Statement">=</span> elems[ <span class="Constant">0</span> ];

	<span class="Statement">if</span> ( not ) {
		expr <span class="Statement">=</span> <span class="Constant">&quot;:not(&quot;</span> <span class="Statement">+</span> expr <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span>;
	}

	<span class="Statement">return</span> elems.length <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">?</span>
		jQuery.find.matchesSelector( elem, expr ) <span class="Statement">?</span> [ elem ] <span class="Statement">:</span> [] <span class="Statement">:</span>
		jQuery.find.matches( expr, jQuery.grep( elems, <span class="Type">function</span>( elem ) {
			<span class="Statement">return</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span>;
		}));
};

jQuery.fn.extend({
	find: <span class="Type">function</span>( selector ) {
		<span class="Type">var</span> i,
			len <span class="Statement">=</span> <span class="Special">this</span>.length,
			ret <span class="Statement">=</span> [],
			self <span class="Statement">=</span> <span class="Special">this</span>;

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> selector <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
			<span class="Statement">return</span> <span class="Special">this</span>.pushStack( jQuery( selector ).filter(<span class="Type">function</span>() {
				<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
					<span class="Statement">if</span> ( jQuery.contains( self[ i ], <span class="Special">this</span> ) ) {
						<span class="Statement">return</span> <span class="Constant">true</span>;
					}
				}
			}) );
		}

		<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
			jQuery.find( selector, self[ i ], ret );
		}

<span class="Comment">		// Needed because $( selector, context ) becomes $( context ).find( selector )</span>
		ret <span class="Statement">=</span> <span class="Special">this</span>.pushStack( len <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">?</span> jQuery.unique( ret ) <span class="Statement">:</span> ret );
		ret.selector <span class="Statement">=</span> <span class="Special">this</span>.selector <span class="Statement">?</span> <span class="Special">this</span>.selector <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> selector <span class="Statement">:</span> selector;
		<span class="Statement">return</span> ret;
	},
	filter: <span class="Type">function</span>( selector ) {
		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( winnow(<span class="Special">this</span>, selector <span class="Statement">||</span> [], <span class="Constant">false</span>) );
	},
	not: <span class="Type">function</span>( selector ) {
		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( winnow(<span class="Special">this</span>, selector <span class="Statement">||</span> [], <span class="Constant">true</span>) );
	},
	is: <span class="Type">function</span>( selector ) {
		<span class="Statement">return</span> <span class="Statement">!!</span>winnow(
			<span class="Special">this</span>,

<span class="Comment">			// If this is a positional/relative selector, check membership in the returned set</span>
<span class="Comment">			// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won't return true for a doc with two &quot;p&quot;.</span>
			<span class="Statement">typeof</span> selector <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> rneedsContext.test( selector ) <span class="Statement">?</span>
				jQuery( selector ) <span class="Statement">:</span>
				selector <span class="Statement">||</span> [],
			<span class="Constant">false</span>
		).length;
	}
});


<span class="Comment">// Initialize a jQuery object</span>


<span class="Comment">// A central reference to the root jQuery(document)</span>
<span class="Type">var</span> rootjQuery,

<span class="Comment">	// A simple way to check for HTML strings</span>
<span class="Comment">	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span>
<span class="Comment">	// Strict HTML recognition (#11290: must start with &lt;)</span>
	rquickExpr <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Special">\s</span><span class="Special">*</span><span class="Constant">(&lt;</span><span class="Constant">[\w\W]</span><span class="Special">+</span><span class="Constant">&gt;)</span><span class="Constant">[^&gt;]</span><span class="Special">*</span><span class="Statement">|</span><span class="Constant">#</span><span class="Constant">(</span><span class="Constant">[\w-]</span><span class="Special">*</span><span class="Constant">)</span><span class="Constant">)</span><span class="Special">$</span><span class="Constant">/</span>,

	init <span class="Statement">=</span> jQuery.fn.init <span class="Statement">=</span> <span class="Type">function</span>( selector, context ) {
		<span class="Type">var</span> match, elem;

<span class="Comment">		// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>selector ) {
			<span class="Statement">return</span> <span class="Special">this</span>;
		}

<span class="Comment">		// Handle HTML strings</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> selector <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			<span class="Statement">if</span> ( selector[<span class="Constant">0</span>] <span class="Statement">===</span> <span class="Constant">&quot;&lt;&quot;</span> <span class="Statement">&amp;&amp;</span> selector[ selector.length <span class="Statement">-</span> <span class="Constant">1</span> ] <span class="Statement">===</span> <span class="Constant">&quot;&gt;&quot;</span> <span class="Statement">&amp;&amp;</span> selector.length <span class="Statement">&gt;=</span> <span class="Constant">3</span> ) {
<span class="Comment">				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span>
				match <span class="Statement">=</span> [ <span class="Type">null</span>, selector, <span class="Type">null</span> ];

			} <span class="Statement">else</span> {
				match <span class="Statement">=</span> rquickExpr.exec( selector );
			}

<span class="Comment">			// Match html or make sure no context is specified for #id</span>
			<span class="Statement">if</span> ( match <span class="Statement">&amp;&amp;</span> (match[<span class="Constant">1</span>] <span class="Statement">||</span> <span class="Statement">!</span>context) ) {

<span class="Comment">				// HANDLE: $(html) -&gt; $(array)</span>
				<span class="Statement">if</span> ( match[<span class="Constant">1</span>] ) {
					context <span class="Statement">=</span> context <span class="Statement">instanceof</span> jQuery <span class="Statement">?</span> context[<span class="Constant">0</span>] <span class="Statement">:</span> context;

<span class="Comment">					// scripts is true for back-compat</span>
<span class="Comment">					// Intentionally let the error be thrown if parseHTML is not present</span>
					jQuery.merge( <span class="Special">this</span>, jQuery.parseHTML(
						match[<span class="Constant">1</span>],
						context <span class="Statement">&amp;&amp;</span> context.nodeType <span class="Statement">?</span> context.ownerDocument <span class="Statement">||</span> context <span class="Statement">:</span> <span class="Special">document</span>,
						<span class="Constant">true</span>
					) );

<span class="Comment">					// HANDLE: $(html, props)</span>
					<span class="Statement">if</span> ( rsingleTag.test( match[<span class="Constant">1</span>] ) <span class="Statement">&amp;&amp;</span> jQuery.isPlainObject( context ) ) {
						<span class="Statement">for</span> ( match <span class="Statement">in</span> context ) {
<span class="Comment">							// Properties of context are called as methods if possible</span>
							<span class="Statement">if</span> ( jQuery.isFunction( <span class="Special">this</span>[ match ] ) ) {
								<span class="Special">this</span>[ match ]( context[ match ] );

<span class="Comment">							// ...and otherwise set as attributes</span>
							} <span class="Statement">else</span> {
								<span class="Special">this</span>.attr( match, context[ match ] );
							}
						}
					}

					<span class="Statement">return</span> <span class="Special">this</span>;

<span class="Comment">				// HANDLE: $(#id)</span>
				} <span class="Statement">else</span> {
					elem <span class="Statement">=</span> <span class="Special">document</span>.getElementById( match[<span class="Constant">2</span>] );

<span class="Comment">					// Check parentNode to catch when Blackberry 4.6 returns</span>
<span class="Comment">					// nodes that are no longer in the document #6963</span>
					<span class="Statement">if</span> ( elem <span class="Statement">&amp;&amp;</span> elem.parentNode ) {
<span class="Comment">						// Inject the element directly into the jQuery object</span>
						<span class="Special">this</span>.length <span class="Statement">=</span> <span class="Constant">1</span>;
						<span class="Special">this</span>[<span class="Constant">0</span>] <span class="Statement">=</span> elem;
					}

					<span class="Special">this</span>.context <span class="Statement">=</span> <span class="Special">document</span>;
					<span class="Special">this</span>.selector <span class="Statement">=</span> selector;
					<span class="Statement">return</span> <span class="Special">this</span>;
				}

<span class="Comment">			// HANDLE: $(expr, $(...))</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( <span class="Statement">!</span>context <span class="Statement">||</span> context.jquery ) {
				<span class="Statement">return</span> ( context <span class="Statement">||</span> rootjQuery ).find( selector );

<span class="Comment">			// HANDLE: $(expr, context)</span>
<span class="Comment">			// (which is just equivalent to: $(context).find(expr)</span>
			} <span class="Statement">else</span> {
				<span class="Statement">return</span> <span class="Special">this</span>.constructor( context ).find( selector );
			}

<span class="Comment">		// HANDLE: $(DOMElement)</span>
		} <span class="Statement">else</span> <span class="Statement">if</span> ( selector.nodeType ) {
			<span class="Special">this</span>.context <span class="Statement">=</span> <span class="Special">this</span>[<span class="Constant">0</span>] <span class="Statement">=</span> selector;
			<span class="Special">this</span>.length <span class="Statement">=</span> <span class="Constant">1</span>;
			<span class="Statement">return</span> <span class="Special">this</span>;

<span class="Comment">		// HANDLE: $(function)</span>
<span class="Comment">		// Shortcut for document ready</span>
		} <span class="Statement">else</span> <span class="Statement">if</span> ( jQuery.isFunction( selector ) ) {
			<span class="Statement">return</span> <span class="Statement">typeof</span> rootjQuery.ready <span class="Statement">!==</span> <span class="Constant">&quot;undefined&quot;</span> <span class="Statement">?</span>
				rootjQuery.ready( selector ) <span class="Statement">:</span>
<span class="Comment">				// Execute immediately if ready is not present</span>
				selector( jQuery );
		}

		<span class="Statement">if</span> ( selector.selector <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
			<span class="Special">this</span>.selector <span class="Statement">=</span> selector.selector;
			<span class="Special">this</span>.context <span class="Statement">=</span> selector.context;
		}

		<span class="Statement">return</span> jQuery.makeArray( selector, <span class="Special">this</span> );
	};

<span class="Comment">// Give the init function the jQuery prototype for later instantiation</span>
init.<span class="Special">prototype</span> <span class="Statement">=</span> jQuery.fn;

<span class="Comment">// Initialize central reference</span>
rootjQuery <span class="Statement">=</span> jQuery( <span class="Special">document</span> );


<span class="Type">var</span> rparentsprev <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">parents</span><span class="Statement">|</span><span class="Constant">prev(</span><span class="Special">?:</span><span class="Constant">Until</span><span class="Statement">|</span><span class="Constant">All)</span><span class="Constant">)/</span>,
<span class="Comment">	// methods guaranteed to produce a unique set when starting from a unique set</span>
	guaranteedUnique <span class="Statement">=</span> {
		children: <span class="Constant">true</span>,
		contents: <span class="Constant">true</span>,
		next: <span class="Constant">true</span>,
		prev: <span class="Constant">true</span>
	};

jQuery.extend({
	dir: <span class="Type">function</span>( elem, dir, until ) {
		<span class="Type">var</span> matched <span class="Statement">=</span> [],
			truncate <span class="Statement">=</span> until <span class="Statement">!==</span> <span class="Type">undefined</span>;

		<span class="Statement">while</span> ( (elem <span class="Statement">=</span> elem[ dir ]) <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">!==</span> <span class="Constant">9</span> ) {
			<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
				<span class="Statement">if</span> ( truncate <span class="Statement">&amp;&amp;</span> jQuery( elem ).is( until ) ) {
					<span class="Statement">break</span>;
				}
				matched.push( elem );
			}
		}
		<span class="Statement">return</span> matched;
	},

	sibling: <span class="Type">function</span>( n, elem ) {
		<span class="Type">var</span> matched <span class="Statement">=</span> [];

		<span class="Statement">for</span> ( ; n; n <span class="Statement">=</span> n.nextSibling ) {
			<span class="Statement">if</span> ( n.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> n <span class="Statement">!==</span> elem ) {
				matched.push( n );
			}
		}

		<span class="Statement">return</span> matched;
	}
});

jQuery.fn.extend({
	has: <span class="Type">function</span>( target ) {
		<span class="Type">var</span> targets <span class="Statement">=</span> jQuery( target, <span class="Special">this</span> ),
			l <span class="Statement">=</span> targets.length;

		<span class="Statement">return</span> <span class="Special">this</span>.filter(<span class="Type">function</span>() {
			<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>;
			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
				<span class="Statement">if</span> ( jQuery.contains( <span class="Special">this</span>, targets[i] ) ) {
					<span class="Statement">return</span> <span class="Constant">true</span>;
				}
			}
		});
	},

	closest: <span class="Type">function</span>( selectors, context ) {
		<span class="Type">var</span> cur,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			l <span class="Statement">=</span> <span class="Special">this</span>.length,
			matched <span class="Statement">=</span> [],
			pos <span class="Statement">=</span> rneedsContext.test( selectors ) <span class="Statement">||</span> <span class="Statement">typeof</span> selectors <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">?</span>
				jQuery( selectors, context <span class="Statement">||</span> <span class="Special">this</span>.context ) <span class="Statement">:</span>
				<span class="Constant">0</span>;

		<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
			<span class="Statement">for</span> ( cur <span class="Statement">=</span> <span class="Special">this</span>[i]; cur <span class="Statement">&amp;&amp;</span> cur <span class="Statement">!==</span> context; cur <span class="Statement">=</span> cur.parentNode ) {
<span class="Comment">				// Always skip document fragments</span>
				<span class="Statement">if</span> ( cur.nodeType <span class="Statement">&lt;</span> <span class="Constant">11</span> <span class="Statement">&amp;&amp;</span> (pos <span class="Statement">?</span>
					pos.index(cur) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span>

<span class="Comment">					// Don't pass non-elements to Sizzle</span>
					cur.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span>
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					<span class="Statement">break</span>;
				}
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( matched.length <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">?</span> jQuery.unique( matched ) <span class="Statement">:</span> matched );
	},

<span class="Comment">	// Determine the position of an element within</span>
<span class="Comment">	// the matched set of elements</span>
	index: <span class="Type">function</span>( elem ) {

<span class="Comment">		// No argument, return index in parent</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>elem ) {
			<span class="Statement">return</span> ( <span class="Special">this</span>[ <span class="Constant">0</span> ] <span class="Statement">&amp;&amp;</span> <span class="Special">this</span>[ <span class="Constant">0</span> ].parentNode ) <span class="Statement">?</span> <span class="Special">this</span>.first().prevAll().length <span class="Statement">:</span> <span class="Statement">-</span><span class="Constant">1</span>;
		}

<span class="Comment">		// index in selector</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> elem <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			<span class="Statement">return</span> indexOf.call( jQuery( elem ), <span class="Special">this</span>[ <span class="Constant">0</span> ] );
		}

<span class="Comment">		// Locate the position of the desired element</span>
		<span class="Statement">return</span> indexOf.call( <span class="Special">this</span>,

<span class="Comment">			// If it receives a jQuery object, the first element is used</span>
			elem.jquery <span class="Statement">?</span> elem[ <span class="Constant">0</span> ] <span class="Statement">:</span> elem
		);
	},

	add: <span class="Type">function</span>( selector, context ) {
		<span class="Statement">return</span> <span class="Special">this</span>.pushStack(
			jQuery.unique(
				jQuery.merge( <span class="Special">this</span>.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: <span class="Type">function</span>( selector ) {
		<span class="Statement">return</span> <span class="Special">this</span>.add( selector <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span>
			<span class="Special">this</span>.prevObject <span class="Statement">:</span> <span class="Special">this</span>.prevObject.filter(selector)
		);
	}
});

<span class="Type">function</span> <span class="Identifier">sibling</span>( cur, dir ) {
	<span class="Statement">while</span> ( (cur <span class="Statement">=</span> cur[dir]) <span class="Statement">&amp;&amp;</span> cur.nodeType <span class="Statement">!==</span> <span class="Constant">1</span> ) {}
	<span class="Statement">return</span> cur;
}

jQuery.each({
	parent: <span class="Type">function</span>( elem ) {
		<span class="Type">var</span> parent <span class="Statement">=</span> elem.parentNode;
		<span class="Statement">return</span> parent <span class="Statement">&amp;&amp;</span> parent.nodeType <span class="Statement">!==</span> <span class="Constant">11</span> <span class="Statement">?</span> parent <span class="Statement">:</span> <span class="Type">null</span>;
	},
	parents: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> jQuery.dir( elem, <span class="Constant">&quot;parentNode&quot;</span> );
	},
	parentsUntil: <span class="Type">function</span>( elem, i, until ) {
		<span class="Statement">return</span> jQuery.dir( elem, <span class="Constant">&quot;parentNode&quot;</span>, until );
	},
	next: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> sibling( elem, <span class="Constant">&quot;nextSibling&quot;</span> );
	},
	prev: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> sibling( elem, <span class="Constant">&quot;previousSibling&quot;</span> );
	},
	nextAll: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> jQuery.dir( elem, <span class="Constant">&quot;nextSibling&quot;</span> );
	},
	prevAll: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> jQuery.dir( elem, <span class="Constant">&quot;previousSibling&quot;</span> );
	},
	nextUntil: <span class="Type">function</span>( elem, i, until ) {
		<span class="Statement">return</span> jQuery.dir( elem, <span class="Constant">&quot;nextSibling&quot;</span>, until );
	},
	prevUntil: <span class="Type">function</span>( elem, i, until ) {
		<span class="Statement">return</span> jQuery.dir( elem, <span class="Constant">&quot;previousSibling&quot;</span>, until );
	},
	siblings: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> jQuery.sibling( ( elem.parentNode <span class="Statement">||</span> {} ).firstChild, elem );
	},
	children: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> jQuery.sibling( elem.firstChild );
	},
	contents: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> elem.contentDocument <span class="Statement">||</span> jQuery.merge( [], elem.childNodes );
	}
}, <span class="Type">function</span>( name, fn ) {
	jQuery.fn[ name ] <span class="Statement">=</span> <span class="Type">function</span>( until, selector ) {
		<span class="Type">var</span> matched <span class="Statement">=</span> jQuery.map( <span class="Special">this</span>, fn, until );

		<span class="Statement">if</span> ( name.slice( <span class="Statement">-</span><span class="Constant">5</span> ) <span class="Statement">!==</span> <span class="Constant">&quot;Until&quot;</span> ) {
			selector <span class="Statement">=</span> until;
		}

		<span class="Statement">if</span> ( selector <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> selector <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			matched <span class="Statement">=</span> jQuery.filter( selector, matched );
		}

		<span class="Statement">if</span> ( <span class="Special">this</span>.length <span class="Statement">&gt;</span> <span class="Constant">1</span> ) {
<span class="Comment">			// Remove duplicates</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

<span class="Comment">			// Reverse order for parents* and prev-derivatives</span>
			<span class="Statement">if</span> ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( matched );
	};
});
<span class="Type">var</span> rnotwhite <span class="Statement">=</span> (<span class="Constant">/</span><span class="Special">\S</span><span class="Special">+</span><span class="Constant">/g</span>);



<span class="Comment">// String to Object options format cache</span>
<span class="Type">var</span> optionsCache <span class="Statement">=</span> {};

<span class="Comment">// Convert String-formatted options into Object-formatted ones and store in cache</span>
<span class="Type">function</span> <span class="Identifier">createOptions</span>( options ) {
	<span class="Type">var</span> object <span class="Statement">=</span> optionsCache[ options ] <span class="Statement">=</span> {};
	jQuery.each( options.match( rnotwhite ) <span class="Statement">||</span> [], <span class="Type">function</span>( _, flag ) {
		object[ flag ] <span class="Statement">=</span> <span class="Constant">true</span>;
	});
	<span class="Statement">return</span> object;
}

<span class="Comment">/*</span>
<span class="Comment"> * Create a callback list using the following parameters:</span>
<span class="Comment"> *</span>
<span class="Comment"> *	options: an optional list of space-separated options that will change how</span>
<span class="Comment"> *			the callback list behaves or a more traditional option object</span>
<span class="Comment"> *</span>
<span class="Comment"> * By default a callback list will act like an event callback list and can be</span>
<span class="Comment"> * &quot;fired&quot; multiple times.</span>
<span class="Comment"> *</span>
<span class="Comment"> * Possible options:</span>
<span class="Comment"> *</span>
<span class="Comment"> *	once:			will ensure the callback list can only be fired once (like a Deferred)</span>
<span class="Comment"> *</span>
<span class="Comment"> *	memory:			will keep track of previous values and will call any callback added</span>
<span class="Comment"> *					after the list has been fired right away with the latest &quot;memorized&quot;</span>
<span class="Comment"> *					values (like a Deferred)</span>
<span class="Comment"> *</span>
<span class="Comment"> *	unique:			will ensure a callback can only be added once (no duplicate in the list)</span>
<span class="Comment"> *</span>
<span class="Comment"> *	stopOnFalse:	interrupt callings when a callback returns false</span>
<span class="Comment"> *</span>
<span class="Comment"> */</span>
jQuery.Callbacks <span class="Statement">=</span> <span class="Type">function</span>( options ) {

<span class="Comment">	// Convert options from String-formatted to Object-formatted if needed</span>
<span class="Comment">	// (we check in cache first)</span>
	options <span class="Statement">=</span> <span class="Statement">typeof</span> options <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">?</span>
		( optionsCache[ options ] <span class="Statement">||</span> createOptions( options ) ) <span class="Statement">:</span>
		jQuery.extend( {}, options );

	<span class="Type">var</span> <span class="Comment">// Last fire value (for non-forgettable lists)</span>
		memory,
<span class="Comment">		// Flag to know if list was already fired</span>
		fired,
<span class="Comment">		// Flag to know if list is currently firing</span>
		firing,
<span class="Comment">		// First callback to fire (used internally by add and fireWith)</span>
		firingStart,
<span class="Comment">		// End of the loop when firing</span>
		firingLength,
<span class="Comment">		// Index of currently firing callback (modified by remove if needed)</span>
		firingIndex,
<span class="Comment">		// Actual callback list</span>
		list <span class="Statement">=</span> [],
<span class="Comment">		// Stack of fire calls for repeatable lists</span>
		stack <span class="Statement">=</span> <span class="Statement">!</span>options.once <span class="Statement">&amp;&amp;</span> [],
<span class="Comment">		// Fire callbacks</span>
		fire <span class="Statement">=</span> <span class="Type">function</span>( data ) {
			memory <span class="Statement">=</span> options.memory <span class="Statement">&amp;&amp;</span> data;
			fired <span class="Statement">=</span> <span class="Constant">true</span>;
			firingIndex <span class="Statement">=</span> firingStart <span class="Statement">||</span> <span class="Constant">0</span>;
			firingStart <span class="Statement">=</span> <span class="Constant">0</span>;
			firingLength <span class="Statement">=</span> list.length;
			firing <span class="Statement">=</span> <span class="Constant">true</span>;
			<span class="Statement">for</span> ( ; list <span class="Statement">&amp;&amp;</span> firingIndex <span class="Statement">&lt;</span> firingLength; firingIndex<span class="Statement">++</span> ) {
				<span class="Statement">if</span> ( list[ firingIndex ].apply( data[ <span class="Constant">0</span> ], data[ <span class="Constant">1</span> ] ) <span class="Statement">===</span> <span class="Constant">false</span> <span class="Statement">&amp;&amp;</span> options.stopOnFalse ) {
					memory <span class="Statement">=</span> <span class="Constant">false</span>; <span class="Comment">// To prevent further calls using add</span>
					<span class="Statement">break</span>;
				}
			}
			firing <span class="Statement">=</span> <span class="Constant">false</span>;
			<span class="Statement">if</span> ( list ) {
				<span class="Statement">if</span> ( stack ) {
					<span class="Statement">if</span> ( stack.length ) {
						fire( stack.shift() );
					}
				} <span class="Statement">else</span> <span class="Statement">if</span> ( memory ) {
					list <span class="Statement">=</span> [];
				} <span class="Statement">else</span> {
					self.disable();
				}
			}
		},
<span class="Comment">		// Actual Callbacks object</span>
		self <span class="Statement">=</span> {
<span class="Comment">			// Add a callback or a collection of callbacks to the list</span>
			add: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( list ) {
<span class="Comment">					// First, we save the current length</span>
					<span class="Type">var</span> start <span class="Statement">=</span> list.length;
					(<span class="Type">function</span> <span class="Identifier">add</span>( args ) {
						jQuery.each( args, <span class="Type">function</span>( _, arg ) {
							<span class="Type">var</span> type <span class="Statement">=</span> jQuery.type( arg );
							<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;function&quot;</span> ) {
								<span class="Statement">if</span> ( <span class="Statement">!</span>options.unique <span class="Statement">||</span> <span class="Statement">!</span>self.has( arg ) ) {
									list.push( arg );
								}
							} <span class="Statement">else</span> <span class="Statement">if</span> ( arg <span class="Statement">&amp;&amp;</span> arg.length <span class="Statement">&amp;&amp;</span> type <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
<span class="Comment">								// Inspect recursively</span>
								add( arg );
							}
						});
					})( arguments );
<span class="Comment">					// Do we need to add the callbacks to the</span>
<span class="Comment">					// current firing batch?</span>
					<span class="Statement">if</span> ( firing ) {
						firingLength <span class="Statement">=</span> list.length;
<span class="Comment">					// With memory, if we're not firing then</span>
<span class="Comment">					// we should call right away</span>
					} <span class="Statement">else</span> <span class="Statement">if</span> ( memory ) {
						firingStart <span class="Statement">=</span> start;
						fire( memory );
					}
				}
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// Remove a callback from the list</span>
			remove: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( list ) {
					jQuery.each( arguments, <span class="Type">function</span>( _, arg ) {
						<span class="Type">var</span> index;
						<span class="Statement">while</span> ( ( index <span class="Statement">=</span> jQuery.inArray( arg, list, index ) ) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span> ) {
							list.splice( index, <span class="Constant">1</span> );
<span class="Comment">							// Handle firing indexes</span>
							<span class="Statement">if</span> ( firing ) {
								<span class="Statement">if</span> ( index <span class="Statement">&lt;=</span> firingLength ) {
									firingLength<span class="Statement">--</span>;
								}
								<span class="Statement">if</span> ( index <span class="Statement">&lt;=</span> firingIndex ) {
									firingIndex<span class="Statement">--</span>;
								}
							}
						}
					});
				}
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// Check if a given callback is in the list.</span>
<span class="Comment">			// If no argument is given, return whether or not list has callbacks attached.</span>
			has: <span class="Type">function</span>( fn ) {
				<span class="Statement">return</span> fn <span class="Statement">?</span> jQuery.inArray( fn, list ) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">:</span> <span class="Statement">!!</span>( list <span class="Statement">&amp;&amp;</span> list.length );
			},
<span class="Comment">			// Remove all callbacks from the list</span>
			empty: <span class="Type">function</span>() {
				list <span class="Statement">=</span> [];
				firingLength <span class="Statement">=</span> <span class="Constant">0</span>;
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// Have the list do nothing anymore</span>
			disable: <span class="Type">function</span>() {
				list <span class="Statement">=</span> stack <span class="Statement">=</span> memory <span class="Statement">=</span> <span class="Type">undefined</span>;
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// Is it disabled?</span>
			disabled: <span class="Type">function</span>() {
				<span class="Statement">return</span> <span class="Statement">!</span>list;
			},
<span class="Comment">			// Lock the list in its current state</span>
			lock: <span class="Type">function</span>() {
				stack <span class="Statement">=</span> <span class="Type">undefined</span>;
				<span class="Statement">if</span> ( <span class="Statement">!</span>memory ) {
					self.disable();
				}
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// Is it locked?</span>
			locked: <span class="Type">function</span>() {
				<span class="Statement">return</span> <span class="Statement">!</span>stack;
			},
<span class="Comment">			// Call all callbacks with the given context and arguments</span>
			fireWith: <span class="Type">function</span>( context, args ) {
				<span class="Statement">if</span> ( list <span class="Statement">&amp;&amp;</span> ( <span class="Statement">!</span>fired <span class="Statement">||</span> stack ) ) {
					args <span class="Statement">=</span> args <span class="Statement">||</span> [];
					args <span class="Statement">=</span> [ context, args.slice <span class="Statement">?</span> args.slice() <span class="Statement">:</span> args ];
					<span class="Statement">if</span> ( firing ) {
						stack.push( args );
					} <span class="Statement">else</span> {
						fire( args );
					}
				}
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// Call all the callbacks with the given arguments</span>
			fire: <span class="Type">function</span>() {
				self.fireWith( <span class="Special">this</span>, arguments );
				<span class="Statement">return</span> <span class="Special">this</span>;
			},
<span class="Comment">			// To know if the callbacks have already been called at least once</span>
			fired: <span class="Type">function</span>() {
				<span class="Statement">return</span> <span class="Statement">!!</span>fired;
			}
		};

	<span class="Statement">return</span> self;
};


jQuery.extend({

	Deferred: <span class="Type">function</span>( func ) {
		<span class="Type">var</span> tuples <span class="Statement">=</span> [
<span class="Comment">				// action, add listener, listener list, final state</span>
				[ <span class="Constant">&quot;resolve&quot;</span>, <span class="Constant">&quot;done&quot;</span>, jQuery.Callbacks(<span class="Constant">&quot;once memory&quot;</span>), <span class="Constant">&quot;resolved&quot;</span> ],
				[ <span class="Constant">&quot;reject&quot;</span>, <span class="Constant">&quot;fail&quot;</span>, jQuery.Callbacks(<span class="Constant">&quot;once memory&quot;</span>), <span class="Constant">&quot;rejected&quot;</span> ],
				[ <span class="Constant">&quot;notify&quot;</span>, <span class="Constant">&quot;progress&quot;</span>, jQuery.Callbacks(<span class="Constant">&quot;memory&quot;</span>) ]
			],
			state <span class="Statement">=</span> <span class="Constant">&quot;pending&quot;</span>,
			promise <span class="Statement">=</span> {
				state: <span class="Type">function</span>() {
					<span class="Statement">return</span> state;
				},
				always: <span class="Type">function</span>() {
					deferred.done( arguments ).fail( arguments );
					<span class="Statement">return</span> <span class="Special">this</span>;
				},
				then: <span class="Type">function</span>( /* fnDone, fnFail, fnProgress */ ) {
					<span class="Type">var</span> fns <span class="Statement">=</span> <span class="Special">arguments</span>;
					<span class="Statement">return</span> jQuery.Deferred(<span class="Type">function</span>( newDefer ) {
						jQuery.each( tuples, <span class="Type">function</span>( i, tuple ) {
							<span class="Type">var</span> fn <span class="Statement">=</span> jQuery.isFunction( fns[ i ] ) <span class="Statement">&amp;&amp;</span> fns[ i ];
<span class="Comment">							// deferred[ done | fail | progress ] for forwarding actions to newDefer</span>
							deferred[ tuple[<span class="Constant">1</span>] ](<span class="Type">function</span>() {
								<span class="Type">var</span> returned <span class="Statement">=</span> fn <span class="Statement">&amp;&amp;</span> fn.apply( <span class="Special">this</span>, arguments );
								<span class="Statement">if</span> ( returned <span class="Statement">&amp;&amp;</span> jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} <span class="Statement">else</span> {
									newDefer[ tuple[ <span class="Constant">0</span> ] <span class="Statement">+</span> <span class="Constant">&quot;With&quot;</span> ]( <span class="Special">this</span> <span class="Statement">===</span> promise <span class="Statement">?</span> newDefer.promise() <span class="Statement">:</span> <span class="Special">this</span>, fn <span class="Statement">?</span> [ returned ] <span class="Statement">:</span> arguments );
								}
							});
						});
						fns <span class="Statement">=</span> <span class="Type">null</span>;
					}).promise();
				},
<span class="Comment">				// Get a promise for this deferred</span>
<span class="Comment">				// If obj is provided, the promise aspect is added to the object</span>
				promise: <span class="Type">function</span>( obj ) {
					<span class="Statement">return</span> obj <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">?</span> jQuery.extend( obj, promise ) <span class="Statement">:</span> promise;
				}
			},
			deferred <span class="Statement">=</span> {};

<span class="Comment">		// Keep pipe for back-compat</span>
		promise.pipe <span class="Statement">=</span> promise.then;

<span class="Comment">		// Add list-specific methods</span>
		jQuery.each( tuples, <span class="Type">function</span>( i, tuple ) {
			<span class="Type">var</span> list <span class="Statement">=</span> tuple[ <span class="Constant">2</span> ],
				stateString <span class="Statement">=</span> tuple[ <span class="Constant">3</span> ];

<span class="Comment">			// promise[ done | fail | progress ] = list.add</span>
			promise[ tuple[<span class="Constant">1</span>] ] <span class="Statement">=</span> list.add;

<span class="Comment">			// Handle state</span>
			<span class="Statement">if</span> ( stateString ) {
				list.add(<span class="Type">function</span>() {
<span class="Comment">					// state = [ resolved | rejected ]</span>
					state <span class="Statement">=</span> stateString;

<span class="Comment">				// [ reject_list | resolve_list ].disable; progress_list.lock</span>
				}, tuples[ i <span class="Statement">^</span> <span class="Constant">1</span> ][ <span class="Constant">2</span> ].disable, tuples[ <span class="Constant">2</span> ][ <span class="Constant">2</span> ].lock );
			}

<span class="Comment">			// deferred[ resolve | reject | notify ]</span>
			deferred[ tuple[<span class="Constant">0</span>] ] <span class="Statement">=</span> <span class="Type">function</span>() {
				deferred[ tuple[<span class="Constant">0</span>] <span class="Statement">+</span> <span class="Constant">&quot;With&quot;</span> ]( <span class="Special">this</span> <span class="Statement">===</span> deferred <span class="Statement">?</span> promise <span class="Statement">:</span> <span class="Special">this</span>, arguments );
				<span class="Statement">return</span> <span class="Special">this</span>;
			};
			deferred[ tuple[<span class="Constant">0</span>] <span class="Statement">+</span> <span class="Constant">&quot;With&quot;</span> ] <span class="Statement">=</span> list.fireWith;
		});

<span class="Comment">		// Make the deferred a promise</span>
		promise.promise( deferred );

<span class="Comment">		// Call given func if any</span>
		<span class="Statement">if</span> ( func ) {
			func.call( deferred, deferred );
		}

<span class="Comment">		// All done!</span>
		<span class="Statement">return</span> deferred;
	},

<span class="Comment">	// Deferred helper</span>
	when: <span class="Type">function</span>( subordinate /* , ..., subordinateN */ ) {
		<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
			resolveValues <span class="Statement">=</span> slice.call( arguments ),
			length <span class="Statement">=</span> resolveValues.length,

<span class="Comment">			// the count of uncompleted subordinates</span>
			remaining <span class="Statement">=</span> length <span class="Statement">!==</span> <span class="Constant">1</span> <span class="Statement">||</span> ( subordinate <span class="Statement">&amp;&amp;</span> jQuery.isFunction( subordinate.promise ) ) <span class="Statement">?</span> length <span class="Statement">:</span> <span class="Constant">0</span>,

<span class="Comment">			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.</span>
			deferred <span class="Statement">=</span> remaining <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">?</span> subordinate <span class="Statement">:</span> jQuery.Deferred(),

<span class="Comment">			// Update function for both resolve and progress values</span>
			updateFunc <span class="Statement">=</span> <span class="Type">function</span>( i, contexts, values ) {
				<span class="Statement">return</span> <span class="Type">function</span>( value ) {
					contexts[ i ] <span class="Statement">=</span> <span class="Special">this</span>;
					values[ i ] <span class="Statement">=</span> <span class="Special">arguments</span>.length <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">?</span> slice.call( arguments ) <span class="Statement">:</span> value;
					<span class="Statement">if</span> ( values <span class="Statement">===</span> progressValues ) {
						deferred.notifyWith( contexts, values );
					} <span class="Statement">else</span> <span class="Statement">if</span> ( <span class="Statement">!</span>( <span class="Statement">--</span>remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

<span class="Comment">		// add listeners to Deferred subordinates; treat others as resolved</span>
		<span class="Statement">if</span> ( length <span class="Statement">&gt;</span> <span class="Constant">1</span> ) {
			progressValues <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">Array</span>( length );
			progressContexts <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">Array</span>( length );
			resolveContexts <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">Array</span>( length );
			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> length; i<span class="Statement">++</span> ) {
				<span class="Statement">if</span> ( resolveValues[ i ] <span class="Statement">&amp;&amp;</span> jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} <span class="Statement">else</span> {
					<span class="Statement">--</span>remaining;
				}
			}
		}

<span class="Comment">		// if we're not waiting on anything, resolve the master</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		<span class="Statement">return</span> deferred.promise();
	}
});


<span class="Comment">// The deferred used on DOM ready</span>
<span class="Type">var</span> readyList;

jQuery.fn.ready <span class="Statement">=</span> <span class="Type">function</span>( fn ) {
<span class="Comment">	// Add the callback</span>
	jQuery.ready.promise().done( fn );

	<span class="Statement">return</span> <span class="Special">this</span>;
};

jQuery.extend({
<span class="Comment">	// Is the DOM ready to be used? Set to true once it occurs.</span>
	isReady: <span class="Constant">false</span>,

<span class="Comment">	// A counter to track how many items to wait for before</span>
<span class="Comment">	// the ready event fires. See #6781</span>
	readyWait: <span class="Constant">1</span>,

<span class="Comment">	// Hold (or release) the ready event</span>
	holdReady: <span class="Type">function</span>( hold ) {
		<span class="Statement">if</span> ( hold ) {
			jQuery.readyWait<span class="Statement">++</span>;
		} <span class="Statement">else</span> {
			jQuery.ready( <span class="Constant">true</span> );
		}
	},

<span class="Comment">	// Handle when the DOM is ready</span>
	ready: <span class="Type">function</span>( wait ) {

<span class="Comment">		// Abort if there are pending holds or we're already ready</span>
		<span class="Statement">if</span> ( wait <span class="Statement">===</span> <span class="Constant">true</span> <span class="Statement">?</span> <span class="Statement">--</span>jQuery.readyWait <span class="Statement">:</span> jQuery.isReady ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Remember that the DOM is ready</span>
		jQuery.isReady <span class="Statement">=</span> <span class="Constant">true</span>;

<span class="Comment">		// If a normal DOM Ready event fired, decrement, and wait if need be</span>
		<span class="Statement">if</span> ( wait <span class="Statement">!==</span> <span class="Constant">true</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">--</span>jQuery.readyWait <span class="Statement">&gt;</span> <span class="Constant">0</span> ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// If there are functions bound, to execute</span>
		readyList.resolveWith( <span class="Special">document</span>, [ jQuery ] );

<span class="Comment">		// Trigger any bound ready events</span>
		<span class="Statement">if</span> ( jQuery.fn.trigger ) {
			jQuery( <span class="Special">document</span> ).trigger(<span class="Constant">&quot;ready&quot;</span>).off(<span class="Constant">&quot;ready&quot;</span>);
		}
	}
});

<span class="Comment">/**</span>
<span class="Comment"> * The ready event handler and self cleanup method</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">completed</span>() {
	<span class="Special">document</span>.removeEventListener( <span class="Constant">&quot;DOMContentLoaded&quot;</span>, completed, <span class="Constant">false</span> );
	<span class="Special">window</span>.removeEventListener( <span class="Constant">&quot;load&quot;</span>, completed, <span class="Constant">false</span> );
	jQuery.ready();
}

jQuery.ready.promise <span class="Statement">=</span> <span class="Type">function</span>( obj ) {
	<span class="Statement">if</span> ( <span class="Statement">!</span>readyList ) {

		readyList <span class="Statement">=</span> jQuery.Deferred();

<span class="Comment">		// Catch cases where $(document).ready() is called after the browser event has already occurred.</span>
<span class="Comment">		// we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one</span>
<span class="Comment">		// discovered by ChrisS here: <a href="http://bugs.jquery.com/ticket/12282#comment:15">http://bugs.jquery.com/ticket/12282#comment:15</a></span>
		<span class="Statement">if</span> ( <span class="Special">document</span>.readyState <span class="Statement">===</span> <span class="Constant">&quot;complete&quot;</span> ) {
<span class="Comment">			// Handle it asynchronously to allow scripts the opportunity to delay ready</span>
			setTimeout( jQuery.ready );

		} <span class="Statement">else</span> {

<span class="Comment">			// Use the handy event callback</span>
			<span class="Special">document</span>.addEventListener( <span class="Constant">&quot;DOMContentLoaded&quot;</span>, completed, <span class="Constant">false</span> );

<span class="Comment">			// A fallback to window.onload, that will always work</span>
			<span class="Special">window</span>.addEventListener( <span class="Constant">&quot;load&quot;</span>, completed, <span class="Constant">false</span> );
		}
	}
	<span class="Statement">return</span> readyList.promise( obj );
};

<span class="Comment">// Kick off the DOM ready check even if the user does not</span>
jQuery.ready.promise();




<span class="Comment">// Multifunctional method to get and set values of a collection</span>
<span class="Comment">// The value/s can optionally be executed if it's a function</span>
<span class="Type">var</span> access <span class="Statement">=</span> jQuery.access <span class="Statement">=</span> <span class="Type">function</span>( elems, fn, key, value, chainable, emptyGet, raw ) {
	<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
		len <span class="Statement">=</span> elems.length,
		bulk <span class="Statement">=</span> key <span class="Statement">==</span> <span class="Type">null</span>;

<span class="Comment">	// Sets many values</span>
	<span class="Statement">if</span> ( jQuery.type( key ) <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
		chainable <span class="Statement">=</span> <span class="Constant">true</span>;
		<span class="Statement">for</span> ( i <span class="Statement">in</span> key ) {
			jQuery.access( elems, fn, i, key[i], <span class="Constant">true</span>, emptyGet, raw );
		}

<span class="Comment">	// Sets one value</span>
	} <span class="Statement">else</span> <span class="Statement">if</span> ( value <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
		chainable <span class="Statement">=</span> <span class="Constant">true</span>;

		<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.isFunction( value ) ) {
			raw <span class="Statement">=</span> <span class="Constant">true</span>;
		}

		<span class="Statement">if</span> ( bulk ) {
<span class="Comment">			// Bulk operations run against the entire set</span>
			<span class="Statement">if</span> ( raw ) {
				fn.call( elems, value );
				fn <span class="Statement">=</span> <span class="Type">null</span>;

<span class="Comment">			// ...except when executing function values</span>
			} <span class="Statement">else</span> {
				bulk <span class="Statement">=</span> fn;
				fn <span class="Statement">=</span> <span class="Type">function</span>( elem, key, value ) {
					<span class="Statement">return</span> bulk.call( jQuery( elem ), value );
				};
			}
		}

		<span class="Statement">if</span> ( fn ) {
			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
				fn( elems[i], key, raw <span class="Statement">?</span> value <span class="Statement">:</span> value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	<span class="Statement">return</span> chainable <span class="Statement">?</span>
		elems <span class="Statement">:</span>

<span class="Comment">		// Gets</span>
		bulk <span class="Statement">?</span>
			fn.call( elems ) <span class="Statement">:</span>
			len <span class="Statement">?</span> fn( elems[<span class="Constant">0</span>], key ) <span class="Statement">:</span> emptyGet;
};


<span class="Comment">/**</span>
<span class="Comment"> * Determines whether an object can have data</span>
<span class="Comment"> </span><span class="Comment">*/</span>
jQuery.acceptData <span class="Statement">=</span> <span class="Type">function</span>( owner ) {
<span class="Comment">	// Accepts only:</span>
<span class="Comment">	//  - Node</span>
<span class="Comment">	//    - Node.ELEMENT_NODE</span>
<span class="Comment">	//    - Node.DOCUMENT_NODE</span>
<span class="Comment">	//  - Object</span>
<span class="Comment">	//    - Any</span>
	<span class="Comment">/* jshint -W018 */</span>
	<span class="Statement">return</span> owner.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> owner.nodeType <span class="Statement">===</span> <span class="Constant">9</span> <span class="Statement">||</span> <span class="Statement">!</span>( <span class="Statement">+</span>owner.nodeType );
};


<span class="Type">function</span> <span class="Identifier">Data</span>() {
<span class="Comment">	// Support: Android &lt; 4,</span>
<span class="Comment">	// Old WebKit does not have Object.preventExtensions/freeze method,</span>
<span class="Comment">	// return new empty object instead with no [[set]] accessor</span>
	<span class="Special">Object</span>.defineProperty( <span class="Special">this</span>.cache <span class="Statement">=</span> {}, <span class="Constant">0</span>, {
		get: <span class="Type">function</span>() {
			<span class="Statement">return</span> {};
		}
	});

	<span class="Special">this</span>.expando <span class="Statement">=</span> jQuery.expando <span class="Statement">+</span> <span class="Special">Math</span>.random();
}

Data.uid <span class="Statement">=</span> <span class="Constant">1</span>;
Data.accepts <span class="Statement">=</span> jQuery.acceptData;

Data.<span class="Special">prototype</span> <span class="Statement">=</span> {
	key: <span class="Type">function</span>( owner ) {
<span class="Comment">		// We can accept data for non-element nodes in modern browsers,</span>
<span class="Comment">		// but we should not, see #8335.</span>
<span class="Comment">		// Always return the key for a frozen object.</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>Data.accepts( owner ) ) {
			<span class="Statement">return</span> <span class="Constant">0</span>;
		}

		<span class="Type">var</span> descriptor <span class="Statement">=</span> {},
<span class="Comment">			// Check if the owner object already has a cache key</span>
			unlock <span class="Statement">=</span> owner[ <span class="Special">this</span>.expando ];

<span class="Comment">		// If not, create one</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>unlock ) {
			unlock <span class="Statement">=</span> Data.uid<span class="Statement">++</span>;

<span class="Comment">			// Secure it in a non-enumerable, non-writable property</span>
			<span class="Statement">try</span> {
				descriptor[ <span class="Special">this</span>.expando ] <span class="Statement">=</span> { value: unlock };
				<span class="Special">Object</span>.defineProperties( owner, descriptor );

<span class="Comment">			// Support: Android &lt; 4</span>
<span class="Comment">			// Fallback to a less secure definition</span>
			} <span class="Statement">catch</span> ( e ) {
				descriptor[ <span class="Special">this</span>.expando ] <span class="Statement">=</span> unlock;
				jQuery.extend( owner, descriptor );
			}
		}

<span class="Comment">		// Ensure the cache object</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span><span class="Special">this</span>.cache[ unlock ] ) {
			<span class="Special">this</span>.cache[ unlock ] <span class="Statement">=</span> {};
		}

		<span class="Statement">return</span> unlock;
	},
	set: <span class="Type">function</span>( owner, data, value ) {
		<span class="Type">var</span> prop,
<span class="Comment">			// There may be an unlock assigned to this node,</span>
<span class="Comment">			// if there is no entry for this &quot;owner&quot;, create one inline</span>
<span class="Comment">			// and set the unlock as though an owner entry had always existed</span>
			unlock <span class="Statement">=</span> <span class="Special">this</span>.key( owner ),
			cache <span class="Statement">=</span> <span class="Special">this</span>.cache[ unlock ];

<span class="Comment">		// Handle: [ owner, key, value ] args</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> data <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			cache[ data ] <span class="Statement">=</span> value;

<span class="Comment">		// Handle: [ owner, { properties } ] args</span>
		} <span class="Statement">else</span> {
<span class="Comment">			// Fresh assignments by object are shallow copied</span>
			<span class="Statement">if</span> ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( <span class="Special">this</span>.cache[ unlock ], data );
<span class="Comment">			// Otherwise, copy the properties one-by-one to the cache object</span>
			} <span class="Statement">else</span> {
				<span class="Statement">for</span> ( prop <span class="Statement">in</span> data ) {
					cache[ prop ] <span class="Statement">=</span> data[ prop ];
				}
			}
		}
		<span class="Statement">return</span> cache;
	},
	get: <span class="Type">function</span>( owner, key ) {
<span class="Comment">		// Either a valid cache is found, or will be created.</span>
<span class="Comment">		// New caches will be created and the unlock returned,</span>
<span class="Comment">		// allowing direct access to the newly created</span>
<span class="Comment">		// empty data object. A valid owner object must be provided.</span>
		<span class="Type">var</span> cache <span class="Statement">=</span> <span class="Special">this</span>.cache[ <span class="Special">this</span>.key( owner ) ];

		<span class="Statement">return</span> key <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">?</span>
			cache <span class="Statement">:</span> cache[ key ];
	},
	access: <span class="Type">function</span>( owner, key, value ) {
		<span class="Type">var</span> stored;
<span class="Comment">		// In cases where either:</span>
<span class="Comment">		//</span>
<span class="Comment">		//   1. No key was specified</span>
<span class="Comment">		//   2. A string key was specified, but no value provided</span>
<span class="Comment">		//</span>
<span class="Comment">		// Take the &quot;read&quot; path and allow the get method to determine</span>
<span class="Comment">		// which value to return, respectively either:</span>
<span class="Comment">		//</span>
<span class="Comment">		//   1. The entire cache object</span>
<span class="Comment">		//   2. The data stored at the key</span>
<span class="Comment">		//</span>
		<span class="Statement">if</span> ( key <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">||</span>
				((key <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> key <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span>) <span class="Statement">&amp;&amp;</span> value <span class="Statement">===</span> <span class="Type">undefined</span>) ) {

			stored <span class="Statement">=</span> <span class="Special">this</span>.get( owner, key );

			<span class="Statement">return</span> stored <span class="Statement">!==</span> <span class="Type">undefined</span> <span class="Statement">?</span>
				stored <span class="Statement">:</span> <span class="Special">this</span>.get( owner, jQuery.camelCase(key) );
		}

<span class="Comment">		// [*]When the key is not a string, or both a key and value</span>
<span class="Comment">		// are specified, set or extend (existing objects) with either:</span>
<span class="Comment">		//</span>
<span class="Comment">		//   1. An object of properties</span>
<span class="Comment">		//   2. A key and value</span>
<span class="Comment">		//</span>
		<span class="Special">this</span>.set( owner, key, value );

<span class="Comment">		// Since the &quot;set&quot; path can have two possible entry points</span>
<span class="Comment">		// return the expected data based on which path was taken[*]</span>
		<span class="Statement">return</span> value <span class="Statement">!==</span> <span class="Type">undefined</span> <span class="Statement">?</span> value <span class="Statement">:</span> key;
	},
	remove: <span class="Type">function</span>( owner, key ) {
		<span class="Type">var</span> i, name, camel,
			unlock <span class="Statement">=</span> <span class="Special">this</span>.key( owner ),
			cache <span class="Statement">=</span> <span class="Special">this</span>.cache[ unlock ];

		<span class="Statement">if</span> ( key <span class="Statement">===</span> <span class="Type">undefined</span> ) {
			<span class="Special">this</span>.cache[ unlock ] <span class="Statement">=</span> {};

		} <span class="Statement">else</span> {
<span class="Comment">			// Support array or space separated string of keys</span>
			<span class="Statement">if</span> ( jQuery.isArray( key ) ) {
<span class="Comment">				// If &quot;name&quot; is an array of keys...</span>
<span class="Comment">				// When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature,</span>
<span class="Comment">				// keys will be converted to camelCase.</span>
<span class="Comment">				// Since there is no way to tell _how_ a key was added, remove</span>
<span class="Comment">				// both plain key and camelCase key. #12786</span>
<span class="Comment">				// This will only penalize the array argument path.</span>
				name <span class="Statement">=</span> key.concat( key.map( jQuery.camelCase ) );
			} <span class="Statement">else</span> {
				camel <span class="Statement">=</span> jQuery.camelCase( key );
<span class="Comment">				// Try the string as a key before any manipulation</span>
				<span class="Statement">if</span> ( key <span class="Statement">in</span> cache ) {
					name <span class="Statement">=</span> [ key, camel ];
				} <span class="Statement">else</span> {
<span class="Comment">					// If a key with the spaces exists, use it.</span>
<span class="Comment">					// Otherwise, create an array by matching non-whitespace</span>
					name <span class="Statement">=</span> camel;
					name <span class="Statement">=</span> name <span class="Statement">in</span> cache <span class="Statement">?</span>
						[ name ] <span class="Statement">:</span> ( name.match( rnotwhite ) <span class="Statement">||</span> [] );
				}
			}

			i <span class="Statement">=</span> name.length;
			<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
				<span class="Statement">delete</span> cache[ name[ i ] ];
			}
		}
	},
	hasData: <span class="Type">function</span>( owner ) {
		<span class="Statement">return</span> <span class="Statement">!</span>jQuery.isEmptyObject(
			<span class="Special">this</span>.cache[ owner[ <span class="Special">this</span>.expando ] ] <span class="Statement">||</span> {}
		);
	},
	discard: <span class="Type">function</span>( owner ) {
		<span class="Statement">if</span> ( owner[ <span class="Special">this</span>.expando ] ) {
			<span class="Statement">delete</span> <span class="Special">this</span>.cache[ owner[ <span class="Special">this</span>.expando ] ];
		}
	}
};
<span class="Type">var</span> data_priv <span class="Statement">=</span> <span class="Statement">new</span> Data();

<span class="Type">var</span> data_user <span class="Statement">=</span> <span class="Statement">new</span> Data();



<span class="Comment">/*</span>
<span class="Comment">	Implementation Summary</span>

<span class="Comment">	1. Enforce API surface and semantic compatibility with 1.9.x branch</span>
<span class="Comment">	2. Improve the module's maintainability by reducing the storage</span>
<span class="Comment">		paths to a single mechanism.</span>
<span class="Comment">	3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.</span>
<span class="Comment">	4. _Never_ expose &quot;private&quot; data to user code (</span><span class="Todo">TODO</span><span class="Comment">: Drop _data, _removeData)</span>
<span class="Comment">	5. Avoid exposing implementation details on user objects (eg. expando properties)</span>
<span class="Comment">	6. Provide a clear path for implementation upgrade to WeakMap in 2014</span>
<span class="Comment">*/</span>
<span class="Type">var</span> rbrace <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Special">\{</span><span class="Constant">[\w\W]</span><span class="Special">*</span><span class="Special">\}</span><span class="Statement">|</span><span class="Special">\[</span><span class="Constant">[\w\W]</span><span class="Special">*</span><span class="Special">\]</span><span class="Constant">)</span><span class="Special">$</span><span class="Constant">/</span>,
	rmultiDash <span class="Statement">=</span> <span class="Constant">/</span><span class="Constant">(</span><span class="Constant">[A-Z]</span><span class="Constant">)</span><span class="Constant">/g</span>;

<span class="Type">function</span> <span class="Identifier">dataAttr</span>( elem, key, data ) {
	<span class="Type">var</span> name;

<span class="Comment">	// If nothing was found internally, try to fetch any</span>
<span class="Comment">	// data from the HTML5 data-* attribute</span>
	<span class="Statement">if</span> ( data <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
		name <span class="Statement">=</span> <span class="Constant">&quot;data-&quot;</span> <span class="Statement">+</span> key.replace( rmultiDash, <span class="Constant">&quot;-$1&quot;</span> ).toLowerCase();
		data <span class="Statement">=</span> elem.getAttribute( name );

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> data <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			<span class="Statement">try</span> {
				data <span class="Statement">=</span> data <span class="Statement">===</span> <span class="Constant">&quot;true&quot;</span> <span class="Statement">?</span> <span class="Constant">true</span> <span class="Statement">:</span>
					data <span class="Statement">===</span> <span class="Constant">&quot;false&quot;</span> <span class="Statement">?</span> <span class="Constant">false</span> <span class="Statement">:</span>
					data <span class="Statement">===</span> <span class="Constant">&quot;null&quot;</span> <span class="Statement">?</span> <span class="Type">null</span> <span class="Statement">:</span>
<span class="Comment">					// Only convert to a number if it doesn't change the string</span>
					<span class="Statement">+</span>data <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">===</span> data <span class="Statement">?</span> <span class="Statement">+</span>data <span class="Statement">:</span>
					rbrace.test( data ) <span class="Statement">?</span> jQuery.parseJSON( data ) <span class="Statement">:</span>
					data;
			} <span class="Statement">catch</span>( e ) {}

<span class="Comment">			// Make sure we set the data so it isn't changed later</span>
			data_user.set( elem, key, data );
		} <span class="Statement">else</span> {
			data <span class="Statement">=</span> <span class="Type">undefined</span>;
		}
	}
	<span class="Statement">return</span> data;
}

jQuery.extend({
	hasData: <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> data_user.hasData( elem ) <span class="Statement">||</span> data_priv.hasData( elem );
	},

	data: <span class="Type">function</span>( elem, name, data ) {
		<span class="Statement">return</span> data_user.access( elem, name, data );
	},

	removeData: <span class="Type">function</span>( elem, name ) {
		data_user.remove( elem, name );
	},

<span class="Comment">	// </span><span class="Todo">TODO</span><span class="Comment">: Now that all calls to _data and _removeData have been replaced</span>
<span class="Comment">	// with direct calls to data_priv methods, these can be deprecated.</span>
	_data: <span class="Type">function</span>( elem, name, data ) {
		<span class="Statement">return</span> data_priv.access( elem, name, data );
	},

	_removeData: <span class="Type">function</span>( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: <span class="Type">function</span>( key, value ) {
		<span class="Type">var</span> i, name, data,
			elem <span class="Statement">=</span> <span class="Special">this</span>[ <span class="Constant">0</span> ],
			attrs <span class="Statement">=</span> elem <span class="Statement">&amp;&amp;</span> elem.attributes;

<span class="Comment">		// Gets all values</span>
		<span class="Statement">if</span> ( key <span class="Statement">===</span> <span class="Type">undefined</span> ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>.length ) {
				data <span class="Statement">=</span> data_user.get( elem );

				<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>data_priv.get( elem, <span class="Constant">&quot;hasDataAttrs&quot;</span> ) ) {
					i <span class="Statement">=</span> attrs.length;
					<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
						name <span class="Statement">=</span> attrs[ i ].name;

						<span class="Statement">if</span> ( name.indexOf( <span class="Constant">&quot;data-&quot;</span> ) <span class="Statement">===</span> <span class="Constant">0</span> ) {
							name <span class="Statement">=</span> jQuery.camelCase( name.slice(<span class="Constant">5</span>) );
							dataAttr( elem, name, data[ name ] );
						}
					}
					data_priv.set( elem, <span class="Constant">&quot;hasDataAttrs&quot;</span>, <span class="Constant">true</span> );
				}
			}

			<span class="Statement">return</span> data;
		}

<span class="Comment">		// Sets multiple values</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> key <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
				data_user.set( <span class="Special">this</span>, key );
			});
		}

		<span class="Statement">return</span> access( <span class="Special">this</span>, <span class="Type">function</span>( value ) {
			<span class="Type">var</span> data,
				camelKey <span class="Statement">=</span> jQuery.camelCase( key );

<span class="Comment">			// The calling jQuery object (element matches) is not empty</span>
<span class="Comment">			// (and therefore has an element appears at this[ 0 ]) and the</span>
<span class="Comment">			// `value` parameter was not undefined. An empty jQuery object</span>
<span class="Comment">			// will result in `undefined` for elem = this[ 0 ] which will</span>
<span class="Comment">			// throw an exception if an attempt to read a data cache is made.</span>
			<span class="Statement">if</span> ( elem <span class="Statement">&amp;&amp;</span> value <span class="Statement">===</span> <span class="Type">undefined</span> ) {
<span class="Comment">				// Attempt to get data from the cache</span>
<span class="Comment">				// with the key as-is</span>
				data <span class="Statement">=</span> data_user.get( elem, key );
				<span class="Statement">if</span> ( data <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					<span class="Statement">return</span> data;
				}

<span class="Comment">				// Attempt to get data from the cache</span>
<span class="Comment">				// with the key camelized</span>
				data <span class="Statement">=</span> data_user.get( elem, camelKey );
				<span class="Statement">if</span> ( data <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					<span class="Statement">return</span> data;
				}

<span class="Comment">				// Attempt to &quot;discover&quot; the data in</span>
<span class="Comment">				// HTML5 custom data-* attrs</span>
				data <span class="Statement">=</span> dataAttr( elem, camelKey, <span class="Type">undefined</span> );
				<span class="Statement">if</span> ( data <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					<span class="Statement">return</span> data;
				}

<span class="Comment">				// We tried really hard, but the data doesn't exist.</span>
				<span class="Statement">return</span>;
			}

<span class="Comment">			// Set the data...</span>
			<span class="Special">this</span>.each(<span class="Type">function</span>() {
<span class="Comment">				// First, attempt to store a copy or reference of any</span>
<span class="Comment">				// data that might've been store with a camelCased key.</span>
				<span class="Type">var</span> data <span class="Statement">=</span> data_user.get( <span class="Special">this</span>, camelKey );

<span class="Comment">				// For HTML5 data-* attribute interop, we have to</span>
<span class="Comment">				// store property names with dashes in a camelCase form.</span>
<span class="Comment">				// This might not apply to all properties...*</span>
				data_user.set( <span class="Special">this</span>, camelKey, value );

<span class="Comment">				// *... In the case of properties that might _actually_</span>
<span class="Comment">				// have dashes, we need to also store a copy of that</span>
<span class="Comment">				// unchanged property.</span>
				<span class="Statement">if</span> ( key.indexOf(<span class="Constant">&quot;-&quot;</span>) <span class="Statement">!==</span> <span class="Statement">-</span><span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> data <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					data_user.set( <span class="Special">this</span>, key, value );
				}
			});
		}, <span class="Type">null</span>, value, arguments.length <span class="Statement">&gt;</span> <span class="Constant">1</span>, <span class="Type">null</span>, <span class="Constant">true</span> );
	},

	removeData: <span class="Type">function</span>( key ) {
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			data_user.remove( <span class="Special">this</span>, key );
		});
	}
});


jQuery.extend({
	queue: <span class="Type">function</span>( elem, type, data ) {
		<span class="Type">var</span> queue;

		<span class="Statement">if</span> ( elem ) {
			type <span class="Statement">=</span> ( type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span> ) <span class="Statement">+</span> <span class="Constant">&quot;queue&quot;</span>;
			queue <span class="Statement">=</span> data_priv.get( elem, type );

<span class="Comment">			// Speed up dequeue by getting out quickly if this is just a lookup</span>
			<span class="Statement">if</span> ( data ) {
				<span class="Statement">if</span> ( <span class="Statement">!</span>queue <span class="Statement">||</span> jQuery.isArray( data ) ) {
					queue <span class="Statement">=</span> data_priv.access( elem, type, jQuery.makeArray(data) );
				} <span class="Statement">else</span> {
					queue.push( data );
				}
			}
			<span class="Statement">return</span> queue <span class="Statement">||</span> [];
		}
	},

	dequeue: <span class="Type">function</span>( elem, type ) {
		type <span class="Statement">=</span> type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span>;

		<span class="Type">var</span> queue <span class="Statement">=</span> jQuery.queue( elem, type ),
			startLength <span class="Statement">=</span> queue.length,
			fn <span class="Statement">=</span> queue.shift(),
			hooks <span class="Statement">=</span> jQuery._queueHooks( elem, type ),
			next <span class="Statement">=</span> <span class="Type">function</span>() {
				jQuery.dequeue( elem, type );
			};

<span class="Comment">		// If the fx queue is dequeued, always remove the progress sentinel</span>
		<span class="Statement">if</span> ( fn <span class="Statement">===</span> <span class="Constant">&quot;inprogress&quot;</span> ) {
			fn <span class="Statement">=</span> queue.shift();
			startLength<span class="Statement">--</span>;
		}

		<span class="Statement">if</span> ( fn ) {

<span class="Comment">			// Add a progress sentinel to prevent the fx queue from being</span>
<span class="Comment">			// automatically dequeued</span>
			<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;fx&quot;</span> ) {
				queue.unshift( <span class="Constant">&quot;inprogress&quot;</span> );
			}

<span class="Comment">			// clear up the last queue stop function</span>
			<span class="Statement">delete</span> hooks.stop;
			fn.call( elem, next, hooks );
		}

		<span class="Statement">if</span> ( <span class="Statement">!</span>startLength <span class="Statement">&amp;&amp;</span> hooks ) {
			hooks.empty.fire();
		}
	},

<span class="Comment">	// not intended for public consumption - generates a queueHooks object, or returns the current one</span>
	_queueHooks: <span class="Type">function</span>( elem, type ) {
		<span class="Type">var</span> key <span class="Statement">=</span> type <span class="Statement">+</span> <span class="Constant">&quot;queueHooks&quot;</span>;
		<span class="Statement">return</span> data_priv.get( elem, key ) <span class="Statement">||</span> data_priv.access( elem, key, {
			empty: jQuery.Callbacks(<span class="Constant">&quot;once memory&quot;</span>).add(<span class="Type">function</span>() {
				data_priv.remove( elem, [ type <span class="Statement">+</span> <span class="Constant">&quot;queue&quot;</span>, key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: <span class="Type">function</span>( type, data ) {
		<span class="Type">var</span> setter <span class="Statement">=</span> <span class="Constant">2</span>;

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> type <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
			data <span class="Statement">=</span> type;
			type <span class="Statement">=</span> <span class="Constant">&quot;fx&quot;</span>;
			setter<span class="Statement">--</span>;
		}

		<span class="Statement">if</span> ( arguments.length <span class="Statement">&lt;</span> setter ) {
			<span class="Statement">return</span> jQuery.queue( <span class="Special">this</span>[<span class="Constant">0</span>], type );
		}

		<span class="Statement">return</span> data <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">?</span>
			<span class="Special">this</span> <span class="Statement">:</span>
			<span class="Special">this</span>.each(<span class="Type">function</span>() {
				<span class="Type">var</span> queue <span class="Statement">=</span> jQuery.queue( <span class="Special">this</span>, type, data );

<span class="Comment">				// ensure a hooks for this queue</span>
				jQuery._queueHooks( <span class="Special">this</span>, type );

				<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;fx&quot;</span> <span class="Statement">&amp;&amp;</span> queue[<span class="Constant">0</span>] <span class="Statement">!==</span> <span class="Constant">&quot;inprogress&quot;</span> ) {
					jQuery.dequeue( <span class="Special">this</span>, type );
				}
			});
	},
	dequeue: <span class="Type">function</span>( type ) {
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			jQuery.dequeue( <span class="Special">this</span>, type );
		});
	},
	clearQueue: <span class="Type">function</span>( type ) {
		<span class="Statement">return</span> <span class="Special">this</span>.queue( type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span>, [] );
	},
<span class="Comment">	// Get a promise resolved when queues of a certain type</span>
<span class="Comment">	// are emptied (fx is the type by default)</span>
	promise: <span class="Type">function</span>( type, obj ) {
		<span class="Type">var</span> tmp,
			count <span class="Statement">=</span> <span class="Constant">1</span>,
			defer <span class="Statement">=</span> jQuery.Deferred(),
			elements <span class="Statement">=</span> <span class="Special">this</span>,
			i <span class="Statement">=</span> <span class="Special">this</span>.length,
			resolve <span class="Statement">=</span> <span class="Type">function</span>() {
				<span class="Statement">if</span> ( <span class="Statement">!</span>( <span class="Statement">--</span>count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> type <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
			obj <span class="Statement">=</span> type;
			type <span class="Statement">=</span> <span class="Type">undefined</span>;
		}
		type <span class="Statement">=</span> type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span>;

		<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
			tmp <span class="Statement">=</span> data_priv.get( elements[ i ], type <span class="Statement">+</span> <span class="Constant">&quot;queueHooks&quot;</span> );
			<span class="Statement">if</span> ( tmp <span class="Statement">&amp;&amp;</span> tmp.empty ) {
				count<span class="Statement">++</span>;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		<span class="Statement">return</span> defer.promise( obj );
	}
});
<span class="Type">var</span> pnum <span class="Statement">=</span> (<span class="Constant">/</span><span class="Constant">[+-]</span><span class="Special">?</span><span class="Constant">(</span><span class="Special">?:</span><span class="Special">\d</span><span class="Special">*</span><span class="Special">\.</span><span class="Statement">|</span><span class="Constant">)</span><span class="Special">\d</span><span class="Special">+</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">[eE][+-]</span><span class="Special">?</span><span class="Special">\d</span><span class="Special">+</span><span class="Statement">|</span><span class="Constant">)</span><span class="Constant">/</span>).source;

<span class="Type">var</span> cssExpand <span class="Statement">=</span> [ <span class="Constant">&quot;Top&quot;</span>, <span class="Constant">&quot;Right&quot;</span>, <span class="Constant">&quot;Bottom&quot;</span>, <span class="Constant">&quot;Left&quot;</span> ];

<span class="Type">var</span> isHidden <span class="Statement">=</span> <span class="Type">function</span>( elem, el ) {
<span class="Comment">		// isHidden might be called from jQuery#filter function;</span>
<span class="Comment">		// in that case, element will be second argument</span>
		elem <span class="Statement">=</span> el <span class="Statement">||</span> elem;
		<span class="Statement">return</span> jQuery.css( elem, <span class="Constant">&quot;display&quot;</span> ) <span class="Statement">===</span> <span class="Constant">&quot;none&quot;</span> <span class="Statement">||</span> <span class="Statement">!</span>jQuery.contains( elem.ownerDocument, elem );
	};

<span class="Type">var</span> rcheckableType <span class="Statement">=</span> (<span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">checkbox</span><span class="Statement">|</span><span class="Constant">radio)</span><span class="Special">$</span><span class="Constant">/i</span>);



(<span class="Type">function</span>() {
	<span class="Type">var</span> fragment <span class="Statement">=</span> <span class="Special">document</span>.createDocumentFragment(),
		div <span class="Statement">=</span> fragment.appendChild( <span class="Special">document</span>.createElement( <span class="Constant">&quot;div&quot;</span> ) );

<span class="Comment">	// #11217 - WebKit loses check when the name is after the checked attribute</span>
	div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&lt;input type='radio' checked='checked' name='t'/&gt;&quot;</span>;

<span class="Comment">	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3</span>
<span class="Comment">	// old WebKit doesn't clone checked state correctly in fragments</span>
	support.checkClone <span class="Statement">=</span> div.cloneNode( <span class="Constant">true</span> ).cloneNode( <span class="Constant">true</span> ).lastChild.checked;

<span class="Comment">	// Make sure textarea (and checkbox) defaultValue is properly cloned</span>
<span class="Comment">	// Support: IE9-IE11+</span>
	div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;</span>;
	support.noCloneChecked <span class="Statement">=</span> <span class="Statement">!!</span>div.cloneNode( <span class="Constant">true</span> ).lastChild.defaultValue;
})();
<span class="Type">var</span> strundefined <span class="Statement">=</span> <span class="Statement">typeof</span> <span class="Type">undefined</span>;



support.focusinBubbles <span class="Statement">=</span> <span class="Constant">&quot;onfocusin&quot;</span> <span class="Statement">in</span> <span class="Special">window</span>;


<span class="Type">var</span>
	rkeyEvent <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">key/</span>,
	rmouseEvent <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">mouse</span><span class="Statement">|</span><span class="Constant">contextmenu)</span><span class="Statement">|</span><span class="Constant">click/</span>,
	rfocusMorph <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">focusinfocus</span><span class="Statement">|</span><span class="Constant">focusoutblur)</span><span class="Special">$</span><span class="Constant">/</span>,
	rtypenamespace <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Constant">[^.]</span><span class="Special">*</span><span class="Constant">)(</span><span class="Special">?:</span><span class="Special">\.</span><span class="Constant">(.</span><span class="Special">+</span><span class="Constant">)</span><span class="Statement">|</span><span class="Constant">)</span><span class="Special">$</span><span class="Constant">/</span>;

<span class="Type">function</span> <span class="Identifier">returnTrue</span>() {
	<span class="Statement">return</span> <span class="Constant">true</span>;
}

<span class="Type">function</span> <span class="Identifier">returnFalse</span>() {
	<span class="Statement">return</span> <span class="Constant">false</span>;
}

<span class="Type">function</span> <span class="Identifier">safeActiveElement</span>() {
	<span class="Statement">try</span> {
		<span class="Statement">return</span> <span class="Special">document</span>.activeElement;
	} <span class="Statement">catch</span> ( err ) { }
}

<span class="Comment">/*</span>
<span class="Comment"> * Helper functions for managing events -- not part of the public interface.</span>
<span class="Comment"> * Props to Dean Edwards' addEvent library for many of the ideas.</span>
<span class="Comment"> */</span>
jQuery.event <span class="Statement">=</span> {

	global: {},

	add: <span class="Type">function</span>( elem, types, handler, data, selector ) {

		<span class="Type">var</span> handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData <span class="Statement">=</span> data_priv.get( elem );

<span class="Comment">		// Don't attach events to noData or text/comment nodes (but allow plain objects)</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>elemData ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Caller can pass in an object of custom data in lieu of the handler</span>
		<span class="Statement">if</span> ( handler.handler ) {
			handleObjIn <span class="Statement">=</span> handler;
			handler <span class="Statement">=</span> handleObjIn.handler;
			selector <span class="Statement">=</span> handleObjIn.selector;
		}

<span class="Comment">		// Make sure that the handler has a unique ID, used to find/remove it later</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>handler.guid ) {
			handler.guid <span class="Statement">=</span> jQuery.guid<span class="Statement">++</span>;
		}

<span class="Comment">		// Init the element's event structure and main handler, if this is the first</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>(events <span class="Statement">=</span> elemData.events) ) {
			events <span class="Statement">=</span> elemData.events <span class="Statement">=</span> {};
		}
		<span class="Statement">if</span> ( <span class="Statement">!</span>(eventHandle <span class="Statement">=</span> elemData.handle) ) {
			eventHandle <span class="Statement">=</span> elemData.handle <span class="Statement">=</span> <span class="Type">function</span>( e ) {
<span class="Comment">				// Discard the second event of a jQuery.event.trigger() and</span>
<span class="Comment">				// when an event is called after a page has unloaded</span>
				<span class="Statement">return</span> <span class="Statement">typeof</span> jQuery <span class="Statement">!==</span> strundefined <span class="Statement">&amp;&amp;</span> jQuery.event.triggered <span class="Statement">!==</span> e.type <span class="Statement">?</span>
					jQuery.event.dispatch.apply( elem, arguments ) <span class="Statement">:</span> <span class="Type">undefined</span>;
			};
		}

<span class="Comment">		// Handle multiple events separated by a space</span>
		types <span class="Statement">=</span> ( types <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).match( rnotwhite ) <span class="Statement">||</span> [ <span class="Constant">&quot;&quot;</span> ];
		t <span class="Statement">=</span> types.length;
		<span class="Statement">while</span> ( t<span class="Statement">--</span> ) {
			tmp <span class="Statement">=</span> rtypenamespace.exec( types[t] ) <span class="Statement">||</span> [];
			type <span class="Statement">=</span> origType <span class="Statement">=</span> tmp[<span class="Constant">1</span>];
			namespaces <span class="Statement">=</span> ( tmp[<span class="Constant">2</span>] <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).split( <span class="Constant">&quot;.&quot;</span> ).sort();

<span class="Comment">			// There *must* be a type, no attaching namespace-only handlers</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>type ) {
				<span class="Statement">continue</span>;
			}

<span class="Comment">			// If event changes its type, use the special event handlers for the changed type</span>
			special <span class="Statement">=</span> jQuery.event.special[ type ] <span class="Statement">||</span> {};

<span class="Comment">			// If selector defined, determine special event api type, otherwise given type</span>
			type <span class="Statement">=</span> ( selector <span class="Statement">?</span> special.delegateType <span class="Statement">:</span> special.bindType ) <span class="Statement">||</span> type;

<span class="Comment">			// Update special based on newly reset type</span>
			special <span class="Statement">=</span> jQuery.event.special[ type ] <span class="Statement">||</span> {};

<span class="Comment">			// handleObj is passed to all event handlers</span>
			handleObj <span class="Statement">=</span> jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector <span class="Statement">&amp;&amp;</span> jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(<span class="Constant">&quot;.&quot;</span>)
			}, handleObjIn );

<span class="Comment">			// Init the event handler queue if we're the first</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>(handlers <span class="Statement">=</span> events[ type ]) ) {
				handlers <span class="Statement">=</span> events[ type ] <span class="Statement">=</span> [];
				handlers.delegateCount <span class="Statement">=</span> <span class="Constant">0</span>;

<span class="Comment">				// Only use addEventListener if the special events handler returns false</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>special.setup <span class="Statement">||</span> special.setup.call( elem, data, namespaces, eventHandle ) <span class="Statement">===</span> <span class="Constant">false</span> ) {
					<span class="Statement">if</span> ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, <span class="Constant">false</span> );
					}
				}
			}

			<span class="Statement">if</span> ( special.add ) {
				special.add.call( elem, handleObj );

				<span class="Statement">if</span> ( <span class="Statement">!</span>handleObj.handler.guid ) {
					handleObj.handler.guid <span class="Statement">=</span> handler.guid;
				}
			}

<span class="Comment">			// Add to the element's handler list, delegates in front</span>
			<span class="Statement">if</span> ( selector ) {
				handlers.splice( handlers.delegateCount<span class="Statement">++</span>, <span class="Constant">0</span>, handleObj );
			} <span class="Statement">else</span> {
				handlers.push( handleObj );
			}

<span class="Comment">			// Keep track of which events have ever been used, for event optimization</span>
			jQuery.event.global[ type ] <span class="Statement">=</span> <span class="Constant">true</span>;
		}

	},

<span class="Comment">	// Detach an event or set of events from an element</span>
	remove: <span class="Type">function</span>( elem, types, handler, selector, mappedTypes ) {

		<span class="Type">var</span> j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData <span class="Statement">=</span> data_priv.hasData( elem ) <span class="Statement">&amp;&amp;</span> data_priv.get( elem );

		<span class="Statement">if</span> ( <span class="Statement">!</span>elemData <span class="Statement">||</span> <span class="Statement">!</span>(events <span class="Statement">=</span> elemData.events) ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Once for each type.namespace in types; type may be omitted</span>
		types <span class="Statement">=</span> ( types <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).match( rnotwhite ) <span class="Statement">||</span> [ <span class="Constant">&quot;&quot;</span> ];
		t <span class="Statement">=</span> types.length;
		<span class="Statement">while</span> ( t<span class="Statement">--</span> ) {
			tmp <span class="Statement">=</span> rtypenamespace.exec( types[t] ) <span class="Statement">||</span> [];
			type <span class="Statement">=</span> origType <span class="Statement">=</span> tmp[<span class="Constant">1</span>];
			namespaces <span class="Statement">=</span> ( tmp[<span class="Constant">2</span>] <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).split( <span class="Constant">&quot;.&quot;</span> ).sort();

<span class="Comment">			// Unbind all events (on this namespace, if provided) for the element</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>type ) {
				<span class="Statement">for</span> ( type <span class="Statement">in</span> events ) {
					jQuery.event.remove( elem, type <span class="Statement">+</span> types[ t ], handler, selector, <span class="Constant">true</span> );
				}
				<span class="Statement">continue</span>;
			}

			special <span class="Statement">=</span> jQuery.event.special[ type ] <span class="Statement">||</span> {};
			type <span class="Statement">=</span> ( selector <span class="Statement">?</span> special.delegateType <span class="Statement">:</span> special.bindType ) <span class="Statement">||</span> type;
			handlers <span class="Statement">=</span> events[ type ] <span class="Statement">||</span> [];
			tmp <span class="Statement">=</span> tmp[<span class="Constant">2</span>] <span class="Statement">&amp;&amp;</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;(^|</span><span class="Special">\\</span><span class="Constant">.)&quot;</span> <span class="Statement">+</span> namespaces.join(<span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">.(?:.*</span><span class="Special">\\</span><span class="Constant">.|)&quot;</span>) <span class="Statement">+</span> <span class="Constant">&quot;(</span><span class="Special">\\</span><span class="Constant">.|$)&quot;</span> );

<span class="Comment">			// Remove matching events</span>
			origCount <span class="Statement">=</span> j <span class="Statement">=</span> handlers.length;
			<span class="Statement">while</span> ( j<span class="Statement">--</span> ) {
				handleObj <span class="Statement">=</span> handlers[ j ];

				<span class="Statement">if</span> ( ( mappedTypes <span class="Statement">||</span> origType <span class="Statement">===</span> handleObj.origType ) <span class="Statement">&amp;&amp;</span>
					( <span class="Statement">!</span>handler <span class="Statement">||</span> handler.guid <span class="Statement">===</span> handleObj.guid ) <span class="Statement">&amp;&amp;</span>
					( <span class="Statement">!</span>tmp <span class="Statement">||</span> tmp.test( handleObj.namespace ) ) <span class="Statement">&amp;&amp;</span>
					( <span class="Statement">!</span>selector <span class="Statement">||</span> selector <span class="Statement">===</span> handleObj.selector <span class="Statement">||</span> selector <span class="Statement">===</span> <span class="Constant">&quot;**&quot;</span> <span class="Statement">&amp;&amp;</span> handleObj.selector ) ) {
					handlers.splice( j, <span class="Constant">1</span> );

					<span class="Statement">if</span> ( handleObj.selector ) {
						handlers.delegateCount<span class="Statement">--</span>;
					}
					<span class="Statement">if</span> ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

<span class="Comment">			// Remove generic event handler if we removed something and no more handlers exist</span>
<span class="Comment">			// (avoids potential for endless recursion during removal of special event handlers)</span>
			<span class="Statement">if</span> ( origCount <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>handlers.length ) {
				<span class="Statement">if</span> ( <span class="Statement">!</span>special.teardown <span class="Statement">||</span> special.teardown.call( elem, namespaces, elemData.handle ) <span class="Statement">===</span> <span class="Constant">false</span> ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				<span class="Statement">delete</span> events[ type ];
			}
		}

<span class="Comment">		// Remove the expando if it's no longer used</span>
		<span class="Statement">if</span> ( jQuery.isEmptyObject( events ) ) {
			<span class="Statement">delete</span> elemData.handle;
			data_priv.remove( elem, <span class="Constant">&quot;events&quot;</span> );
		}
	},

	trigger: <span class="Type">function</span>( event, data, elem, onlyHandlers ) {

		<span class="Type">var</span> i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath <span class="Statement">=</span> [ elem <span class="Statement">||</span> <span class="Special">document</span> ],
			type <span class="Statement">=</span> hasOwn.call( event, <span class="Constant">&quot;type&quot;</span> ) <span class="Statement">?</span> event.type <span class="Statement">:</span> event,
			namespaces <span class="Statement">=</span> hasOwn.call( event, <span class="Constant">&quot;namespace&quot;</span> ) <span class="Statement">?</span> event.namespace.split(<span class="Constant">&quot;.&quot;</span>) <span class="Statement">:</span> [];

		cur <span class="Statement">=</span> tmp <span class="Statement">=</span> elem <span class="Statement">=</span> elem <span class="Statement">||</span> <span class="Special">document</span>;

<span class="Comment">		// Don't do events on text and comment nodes</span>
		<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">3</span> <span class="Statement">||</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">8</span> ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// focus/blur morphs to focusin/out; ensure we're not firing them right now</span>
		<span class="Statement">if</span> ( rfocusMorph.test( type <span class="Statement">+</span> jQuery.event.triggered ) ) {
			<span class="Statement">return</span>;
		}

		<span class="Statement">if</span> ( type.indexOf(<span class="Constant">&quot;.&quot;</span>) <span class="Statement">&gt;=</span> <span class="Constant">0</span> ) {
<span class="Comment">			// Namespaced trigger; create a regexp to match event type in handle()</span>
			namespaces <span class="Statement">=</span> type.split(<span class="Constant">&quot;.&quot;</span>);
			type <span class="Statement">=</span> namespaces.shift();
			namespaces.sort();
		}
		ontype <span class="Statement">=</span> type.indexOf(<span class="Constant">&quot;:&quot;</span>) <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;on&quot;</span> <span class="Statement">+</span> type;

<span class="Comment">		// Caller can pass in a jQuery.Event object, Object, or just an event type string</span>
		event <span class="Statement">=</span> event[ jQuery.expando ] <span class="Statement">?</span>
			event <span class="Statement">:</span>
			<span class="Statement">new</span> jQuery.Event( type, <span class="Statement">typeof</span> event <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">&amp;&amp;</span> event );

<span class="Comment">		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)</span>
		event.isTrigger <span class="Statement">=</span> onlyHandlers <span class="Statement">?</span> <span class="Constant">2</span> <span class="Statement">:</span> <span class="Constant">3</span>;
		event.namespace <span class="Statement">=</span> namespaces.join(<span class="Constant">&quot;.&quot;</span>);
		event.namespace_re <span class="Statement">=</span> event.namespace <span class="Statement">?</span>
			<span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;(^|</span><span class="Special">\\</span><span class="Constant">.)&quot;</span> <span class="Statement">+</span> namespaces.join(<span class="Constant">&quot;</span><span class="Special">\\</span><span class="Constant">.(?:.*</span><span class="Special">\\</span><span class="Constant">.|)&quot;</span>) <span class="Statement">+</span> <span class="Constant">&quot;(</span><span class="Special">\\</span><span class="Constant">.|$)&quot;</span> ) <span class="Statement">:</span>
			<span class="Type">null</span>;

<span class="Comment">		// Clean up the event in case it is being reused</span>
		event.result <span class="Statement">=</span> <span class="Type">undefined</span>;
		<span class="Statement">if</span> ( <span class="Statement">!</span>event.target ) {
			event.target <span class="Statement">=</span> elem;
		}

<span class="Comment">		// Clone any incoming data and prepend the event, creating the handler arg list</span>
		data <span class="Statement">=</span> data <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span>
			[ event ] <span class="Statement">:</span>
			jQuery.makeArray( data, [ event ] );

<span class="Comment">		// Allow special events to draw outside the lines</span>
		special <span class="Statement">=</span> jQuery.event.special[ type ] <span class="Statement">||</span> {};
		<span class="Statement">if</span> ( <span class="Statement">!</span>onlyHandlers <span class="Statement">&amp;&amp;</span> special.trigger <span class="Statement">&amp;&amp;</span> special.trigger.apply( elem, data ) <span class="Statement">===</span> <span class="Constant">false</span> ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Determine event propagation path in advance, per W3C events spec (#9951)</span>
<span class="Comment">		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>onlyHandlers <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>special.noBubble <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.isWindow( elem ) ) {

			bubbleType <span class="Statement">=</span> special.delegateType <span class="Statement">||</span> type;
			<span class="Statement">if</span> ( <span class="Statement">!</span>rfocusMorph.test( bubbleType <span class="Statement">+</span> type ) ) {
				cur <span class="Statement">=</span> cur.parentNode;
			}
			<span class="Statement">for</span> ( ; cur; cur <span class="Statement">=</span> cur.parentNode ) {
				eventPath.push( cur );
				tmp <span class="Statement">=</span> cur;
			}

<span class="Comment">			// Only add window if we got to document (e.g., not plain obj or detached DOM)</span>
			<span class="Statement">if</span> ( tmp <span class="Statement">===</span> (elem.ownerDocument <span class="Statement">||</span> <span class="Special">document</span>) ) {
				eventPath.push( tmp.defaultView <span class="Statement">||</span> tmp.parentWindow <span class="Statement">||</span> <span class="Special">window</span> );
			}
		}

<span class="Comment">		// Fire handlers on the event path</span>
		i <span class="Statement">=</span> <span class="Constant">0</span>;
		<span class="Statement">while</span> ( (cur <span class="Statement">=</span> eventPath[i<span class="Statement">++</span>]) <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>event.isPropagationStopped() ) {

			event.type <span class="Statement">=</span> i <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">?</span>
				bubbleType <span class="Statement">:</span>
				special.bindType <span class="Statement">||</span> type;

<span class="Comment">			// jQuery handler</span>
			handle <span class="Statement">=</span> ( data_priv.get( cur, <span class="Constant">&quot;events&quot;</span> ) <span class="Statement">||</span> {} )[ event.type ] <span class="Statement">&amp;&amp;</span> data_priv.get( cur, <span class="Constant">&quot;handle&quot;</span> );
			<span class="Statement">if</span> ( handle ) {
				handle.apply( cur, data );
			}

<span class="Comment">			// Native handler</span>
			handle <span class="Statement">=</span> ontype <span class="Statement">&amp;&amp;</span> cur[ ontype ];
			<span class="Statement">if</span> ( handle <span class="Statement">&amp;&amp;</span> handle.apply <span class="Statement">&amp;&amp;</span> jQuery.acceptData( cur ) ) {
				event.result <span class="Statement">=</span> handle.apply( cur, data );
				<span class="Statement">if</span> ( event.result <span class="Statement">===</span> <span class="Constant">false</span> ) {
					event.preventDefault();
				}
			}
		}
		event.type <span class="Statement">=</span> type;

<span class="Comment">		// If nobody prevented the default action, do it now</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>onlyHandlers <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>event.isDefaultPrevented() ) {

			<span class="Statement">if</span> ( (<span class="Statement">!</span>special._default <span class="Statement">||</span> special._default.apply( eventPath.pop(), data ) <span class="Statement">===</span> <span class="Constant">false</span>) <span class="Statement">&amp;&amp;</span>
				jQuery.acceptData( elem ) ) {

<span class="Comment">				// Call a native DOM method on the target with the same name name as the event.</span>
<span class="Comment">				// Don't do default actions on window, that's where global variables be (#6170)</span>
				<span class="Statement">if</span> ( ontype <span class="Statement">&amp;&amp;</span> jQuery.isFunction( elem[ type ] ) <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.isWindow( elem ) ) {

<span class="Comment">					// Don't re-trigger an onFOO event when we call its FOO() method</span>
					tmp <span class="Statement">=</span> elem[ ontype ];

					<span class="Statement">if</span> ( tmp ) {
						elem[ ontype ] <span class="Statement">=</span> <span class="Type">null</span>;
					}

<span class="Comment">					// Prevent re-triggering of the same event, since we already bubbled it above</span>
					jQuery.event.triggered <span class="Statement">=</span> type;
					elem[ type ]();
					jQuery.event.triggered <span class="Statement">=</span> <span class="Type">undefined</span>;

					<span class="Statement">if</span> ( tmp ) {
						elem[ ontype ] <span class="Statement">=</span> tmp;
					}
				}
			}
		}

		<span class="Statement">return</span> event.result;
	},

	dispatch: <span class="Type">function</span>( event ) {

<span class="Comment">		// Make a writable jQuery.Event from the native event object</span>
		event <span class="Statement">=</span> jQuery.event.fix( event );

		<span class="Type">var</span> i, j, ret, matched, handleObj,
			handlerQueue <span class="Statement">=</span> [],
			args <span class="Statement">=</span> slice.call( arguments ),
			handlers <span class="Statement">=</span> ( data_priv.get( <span class="Special">this</span>, <span class="Constant">&quot;events&quot;</span> ) <span class="Statement">||</span> {} )[ event.type ] <span class="Statement">||</span> [],
			special <span class="Statement">=</span> jQuery.event.special[ event.type ] <span class="Statement">||</span> {};

<span class="Comment">		// Use the fix-ed jQuery.Event rather than the (read-only) native event</span>
		args[<span class="Constant">0</span>] <span class="Statement">=</span> event;
		event.delegateTarget <span class="Statement">=</span> <span class="Special">this</span>;

<span class="Comment">		// Call the preDispatch hook for the mapped type, and let it bail if desired</span>
		<span class="Statement">if</span> ( special.preDispatch <span class="Statement">&amp;&amp;</span> special.preDispatch.call( <span class="Special">this</span>, event ) <span class="Statement">===</span> <span class="Constant">false</span> ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Determine handlers</span>
		handlerQueue <span class="Statement">=</span> jQuery.event.handlers.call( <span class="Special">this</span>, event, handlers );

<span class="Comment">		// Run delegates first; they may want to stop propagation beneath us</span>
		i <span class="Statement">=</span> <span class="Constant">0</span>;
		<span class="Statement">while</span> ( (matched <span class="Statement">=</span> handlerQueue[ i<span class="Statement">++</span> ]) <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>event.isPropagationStopped() ) {
			event.currentTarget <span class="Statement">=</span> matched.elem;

			j <span class="Statement">=</span> <span class="Constant">0</span>;
			<span class="Statement">while</span> ( (handleObj <span class="Statement">=</span> matched.handlers[ j<span class="Statement">++</span> ]) <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>event.isImmediatePropagationStopped() ) {

<span class="Comment">				// Triggered event must either 1) have no namespace, or</span>
<span class="Comment">				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>event.namespace_re <span class="Statement">||</span> event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj <span class="Statement">=</span> handleObj;
					event.data <span class="Statement">=</span> handleObj.data;

					ret <span class="Statement">=</span> ( (jQuery.event.special[ handleObj.origType ] <span class="Statement">||</span> {}).handle <span class="Statement">||</span> handleObj.handler )
							.apply( matched.elem, args );

					<span class="Statement">if</span> ( ret <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
						<span class="Statement">if</span> ( (event.result <span class="Statement">=</span> ret) <span class="Statement">===</span> <span class="Constant">false</span> ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

<span class="Comment">		// Call the postDispatch hook for the mapped type</span>
		<span class="Statement">if</span> ( special.postDispatch ) {
			special.postDispatch.call( <span class="Special">this</span>, event );
		}

		<span class="Statement">return</span> event.result;
	},

	handlers: <span class="Type">function</span>( event, handlers ) {
		<span class="Type">var</span> i, matches, sel, handleObj,
			handlerQueue <span class="Statement">=</span> [],
			delegateCount <span class="Statement">=</span> handlers.delegateCount,
			cur <span class="Statement">=</span> event.target;

<span class="Comment">		// Find delegate handlers</span>
<span class="Comment">		// Black-hole SVG &lt;use&gt; instance trees (#13180)</span>
<span class="Comment">		// Avoid non-left-click bubbling in Firefox (#3861)</span>
		<span class="Statement">if</span> ( delegateCount <span class="Statement">&amp;&amp;</span> cur.nodeType <span class="Statement">&amp;&amp;</span> (<span class="Statement">!</span>event.button <span class="Statement">||</span> event.type <span class="Statement">!==</span> <span class="Constant">&quot;click&quot;</span>) ) {

			<span class="Statement">for</span> ( ; cur <span class="Statement">!==</span> <span class="Special">this</span>; cur <span class="Statement">=</span> cur.parentNode <span class="Statement">||</span> <span class="Special">this</span> ) {

<span class="Comment">				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)</span>
				<span class="Statement">if</span> ( cur.disabled <span class="Statement">!==</span> <span class="Constant">true</span> <span class="Statement">||</span> event.type <span class="Statement">!==</span> <span class="Constant">&quot;click&quot;</span> ) {
					matches <span class="Statement">=</span> [];
					<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>; i <span class="Statement">&lt;</span> delegateCount; i<span class="Statement">++</span> ) {
						handleObj <span class="Statement">=</span> handlers[ i ];

<span class="Comment">						// Don't conflict with Object.prototype properties (#13203)</span>
						sel <span class="Statement">=</span> handleObj.selector <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span>;

						<span class="Statement">if</span> ( matches[ sel ] <span class="Statement">===</span> <span class="Type">undefined</span> ) {
							matches[ sel ] <span class="Statement">=</span> handleObj.needsContext <span class="Statement">?</span>
								jQuery( sel, <span class="Special">this</span> ).index( cur ) <span class="Statement">&gt;=</span> <span class="Constant">0</span> <span class="Statement">:</span>
								jQuery.find( sel, <span class="Special">this</span>, <span class="Type">null</span>, [ cur ] ).length;
						}
						<span class="Statement">if</span> ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					<span class="Statement">if</span> ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

<span class="Comment">		// Add the remaining (directly-bound) handlers</span>
		<span class="Statement">if</span> ( delegateCount <span class="Statement">&lt;</span> handlers.length ) {
			handlerQueue.push({ elem: <span class="Special">this</span>, handlers: handlers.slice( delegateCount ) });
		}

		<span class="Statement">return</span> handlerQueue;
	},

<span class="Comment">	// Includes some event props shared by KeyEvent and MouseEvent</span>
	props: <span class="Constant">&quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;</span>.split(<span class="Constant">&quot; &quot;</span>),

	fixHooks: {},

	keyHooks: {
		props: <span class="Constant">&quot;char charCode key keyCode&quot;</span>.split(<span class="Constant">&quot; &quot;</span>),
		filter: <span class="Type">function</span>( event, original ) {

<span class="Comment">			// Add which for key events</span>
			<span class="Statement">if</span> ( event.which <span class="Statement">==</span> <span class="Type">null</span> ) {
				event.which <span class="Statement">=</span> original.charCode <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">?</span> original.charCode <span class="Statement">:</span> original.keyCode;
			}

			<span class="Statement">return</span> event;
		}
	},

	mouseHooks: {
		props: <span class="Constant">&quot;button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement&quot;</span>.split(<span class="Constant">&quot; &quot;</span>),
		filter: <span class="Type">function</span>( event, original ) {
			<span class="Type">var</span> eventDoc, doc, body,
				button <span class="Statement">=</span> original.button;

<span class="Comment">			// Calculate pageX/Y if missing and clientX/Y available</span>
			<span class="Statement">if</span> ( event.pageX <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">&amp;&amp;</span> original.clientX <span class="Statement">!=</span> <span class="Type">null</span> ) {
				eventDoc <span class="Statement">=</span> event.target.ownerDocument <span class="Statement">||</span> <span class="Special">document</span>;
				doc <span class="Statement">=</span> eventDoc.documentElement;
				body <span class="Statement">=</span> eventDoc.body;

				event.pageX <span class="Statement">=</span> original.clientX <span class="Statement">+</span> ( doc <span class="Statement">&amp;&amp;</span> doc.scrollLeft <span class="Statement">||</span> body <span class="Statement">&amp;&amp;</span> body.scrollLeft <span class="Statement">||</span> <span class="Constant">0</span> ) <span class="Statement">-</span> ( doc <span class="Statement">&amp;&amp;</span> doc.clientLeft <span class="Statement">||</span> body <span class="Statement">&amp;&amp;</span> body.clientLeft <span class="Statement">||</span> <span class="Constant">0</span> );
				event.pageY <span class="Statement">=</span> original.clientY <span class="Statement">+</span> ( doc <span class="Statement">&amp;&amp;</span> doc.scrollTop  <span class="Statement">||</span> body <span class="Statement">&amp;&amp;</span> body.scrollTop  <span class="Statement">||</span> <span class="Constant">0</span> ) <span class="Statement">-</span> ( doc <span class="Statement">&amp;&amp;</span> doc.clientTop  <span class="Statement">||</span> body <span class="Statement">&amp;&amp;</span> body.clientTop  <span class="Statement">||</span> <span class="Constant">0</span> );
			}

<span class="Comment">			// Add which for click: 1 === left; 2 === middle; 3 === right</span>
<span class="Comment">			// Note: button is not normalized, so don't use it</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>event.which <span class="Statement">&amp;&amp;</span> button <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
				event.which <span class="Statement">=</span> ( button <span class="Statement">&amp;</span> <span class="Constant">1</span> <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> ( button <span class="Statement">&amp;</span> <span class="Constant">2</span> <span class="Statement">?</span> <span class="Constant">3</span> <span class="Statement">:</span> ( button <span class="Statement">&amp;</span> <span class="Constant">4</span> <span class="Statement">?</span> <span class="Constant">2</span> <span class="Statement">:</span> <span class="Constant">0</span> ) ) );
			}

			<span class="Statement">return</span> event;
		}
	},

	fix: <span class="Type">function</span>( event ) {
		<span class="Statement">if</span> ( event[ jQuery.expando ] ) {
			<span class="Statement">return</span> event;
		}

<span class="Comment">		// Create a writable copy of the event object and normalize some properties</span>
		<span class="Type">var</span> i, prop, copy,
			type <span class="Statement">=</span> event.type,
			originalEvent <span class="Statement">=</span> event,
			fixHook <span class="Statement">=</span> <span class="Special">this</span>.fixHooks[ type ];

		<span class="Statement">if</span> ( <span class="Statement">!</span>fixHook ) {
			<span class="Special">this</span>.fixHooks[ type ] <span class="Statement">=</span> fixHook <span class="Statement">=</span>
				rmouseEvent.test( type ) <span class="Statement">?</span> <span class="Special">this</span>.mouseHooks <span class="Statement">:</span>
				rkeyEvent.test( type ) <span class="Statement">?</span> <span class="Special">this</span>.keyHooks <span class="Statement">:</span>
				{};
		}
		copy <span class="Statement">=</span> fixHook.props <span class="Statement">?</span> <span class="Special">this</span>.props.concat( fixHook.props ) <span class="Statement">:</span> <span class="Special">this</span>.props;

		event <span class="Statement">=</span> <span class="Statement">new</span> jQuery.Event( originalEvent );

		i <span class="Statement">=</span> copy.length;
		<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
			prop <span class="Statement">=</span> copy[ i ];
			event[ prop ] <span class="Statement">=</span> originalEvent[ prop ];
		}

<span class="Comment">		// Support: Cordova 2.5 (WebKit) (#13255)</span>
<span class="Comment">		// All events should have a target; Cordova deviceready doesn't</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>event.target ) {
			event.target <span class="Statement">=</span> <span class="Special">document</span>;
		}

<span class="Comment">		// Support: Safari 6.0+, Chrome &lt; 28</span>
<span class="Comment">		// Target should not be a text node (#504, #13143)</span>
		<span class="Statement">if</span> ( event.target.nodeType <span class="Statement">===</span> <span class="Constant">3</span> ) {
			event.target <span class="Statement">=</span> event.target.parentNode;
		}

		<span class="Statement">return</span> fixHook.filter <span class="Statement">?</span> fixHook.filter( event, originalEvent ) <span class="Statement">:</span> event;
	},

	special: {
		load: {
<span class="Comment">			// Prevent triggered image.load events from bubbling to window.load</span>
			noBubble: <span class="Constant">true</span>
		},
		focus: {
<span class="Comment">			// Fire native event if possible so blur/focus sequence is correct</span>
			trigger: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( <span class="Special">this</span> <span class="Statement">!==</span> safeActiveElement() <span class="Statement">&amp;&amp;</span> <span class="Special">this</span>.focus ) {
					<span class="Special">this</span>.focus();
					<span class="Statement">return</span> <span class="Constant">false</span>;
				}
			},
			delegateType: <span class="Constant">&quot;focusin&quot;</span>
		},
		blur: {
			trigger: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( <span class="Special">this</span> <span class="Statement">===</span> safeActiveElement() <span class="Statement">&amp;&amp;</span> <span class="Special">this</span>.blur ) {
					<span class="Special">this</span>.blur();
					<span class="Statement">return</span> <span class="Constant">false</span>;
				}
			},
			delegateType: <span class="Constant">&quot;focusout&quot;</span>
		},
		click: {
<span class="Comment">			// For checkbox, fire native event so checked state will be right</span>
			trigger: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( <span class="Special">this</span>.type <span class="Statement">===</span> <span class="Constant">&quot;checkbox&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Special">this</span>.click <span class="Statement">&amp;&amp;</span> jQuery.nodeName( <span class="Special">this</span>, <span class="Constant">&quot;input&quot;</span> ) ) {
					<span class="Special">this</span>.click();
					<span class="Statement">return</span> <span class="Constant">false</span>;
				}
			},

<span class="Comment">			// For cross-browser consistency, don't fire native .click() on links</span>
			_default: <span class="Type">function</span>( event ) {
				<span class="Statement">return</span> jQuery.nodeName( event.target, <span class="Constant">&quot;a&quot;</span> );
			}
		},

		beforeunload: {
			postDispatch: <span class="Type">function</span>( event ) {

<span class="Comment">				// Support: Firefox 20+</span>
<span class="Comment">				// Firefox doesn't alert if the returnValue field is not set.</span>
				<span class="Statement">if</span> ( event.result <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					event.originalEvent.returnValue <span class="Statement">=</span> event.result;
				}
			}
		}
	},

	simulate: <span class="Type">function</span>( type, elem, event, bubble ) {
<span class="Comment">		// Piggyback on a donor event to simulate a different one.</span>
<span class="Comment">		// Fake originalEvent to avoid donor's stopPropagation, but if the</span>
<span class="Comment">		// simulated event prevents default then we do the same on the donor.</span>
		<span class="Type">var</span> e <span class="Statement">=</span> jQuery.extend(
			<span class="Statement">new</span> jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: <span class="Constant">true</span>,
				originalEvent: {}
			}
		);
		<span class="Statement">if</span> ( bubble ) {
			jQuery.event.trigger( e, <span class="Type">null</span>, elem );
		} <span class="Statement">else</span> {
			jQuery.event.dispatch.call( elem, e );
		}
		<span class="Statement">if</span> ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent <span class="Statement">=</span> <span class="Type">function</span>( elem, type, handle ) {
	<span class="Statement">if</span> ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, <span class="Constant">false</span> );
	}
};

jQuery.Event <span class="Statement">=</span> <span class="Type">function</span>( src, props ) {
<span class="Comment">	// Allow instantiation without the 'new' keyword</span>
	<span class="Statement">if</span> ( <span class="Statement">!</span>(<span class="Special">this</span> <span class="Statement">instanceof</span> jQuery.Event) ) {
		<span class="Statement">return</span> <span class="Statement">new</span> jQuery.Event( src, props );
	}

<span class="Comment">	// Event object</span>
	<span class="Statement">if</span> ( src <span class="Statement">&amp;&amp;</span> src.type ) {
		<span class="Special">this</span>.originalEvent <span class="Statement">=</span> src;
		<span class="Special">this</span>.type <span class="Statement">=</span> src.type;

<span class="Comment">		// Events bubbling up the document may have been marked as prevented</span>
<span class="Comment">		// by a handler lower down the tree; reflect the correct value.</span>
		<span class="Special">this</span>.isDefaultPrevented <span class="Statement">=</span> src.defaultPrevented <span class="Statement">||</span>
<span class="Comment">				// Support: Android &lt; 4.0</span>
				src.defaultPrevented <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">&amp;&amp;</span>
				src.getPreventDefault <span class="Statement">&amp;&amp;</span> src.getPreventDefault() <span class="Statement">?</span>
			returnTrue <span class="Statement">:</span>
			returnFalse;

<span class="Comment">	// Event type</span>
	} <span class="Statement">else</span> {
		<span class="Special">this</span>.type <span class="Statement">=</span> src;
	}

<span class="Comment">	// Put explicitly provided properties onto the event object</span>
	<span class="Statement">if</span> ( props ) {
		jQuery.extend( <span class="Special">this</span>, props );
	}

<span class="Comment">	// Create a timestamp if incoming event doesn't have one</span>
	<span class="Special">this</span>.timeStamp <span class="Statement">=</span> src <span class="Statement">&amp;&amp;</span> src.timeStamp <span class="Statement">||</span> jQuery.now();

<span class="Comment">	// Mark it as fixed</span>
	<span class="Special">this</span>[ jQuery.expando ] <span class="Statement">=</span> <span class="Constant">true</span>;
};

<span class="Comment">// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding</span>
<span class="Comment">// <a href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html">http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</a></span>
jQuery.Event.<span class="Special">prototype</span> <span class="Statement">=</span> {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: <span class="Type">function</span>() {
		<span class="Type">var</span> e <span class="Statement">=</span> <span class="Special">this</span>.originalEvent;

		<span class="Special">this</span>.isDefaultPrevented <span class="Statement">=</span> returnTrue;

		<span class="Statement">if</span> ( e <span class="Statement">&amp;&amp;</span> e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: <span class="Type">function</span>() {
		<span class="Type">var</span> e <span class="Statement">=</span> <span class="Special">this</span>.originalEvent;

		<span class="Special">this</span>.isPropagationStopped <span class="Statement">=</span> returnTrue;

		<span class="Statement">if</span> ( e <span class="Statement">&amp;&amp;</span> e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: <span class="Type">function</span>() {
		<span class="Special">this</span>.isImmediatePropagationStopped <span class="Statement">=</span> returnTrue;
		<span class="Special">this</span>.stopPropagation();
	}
};

<span class="Comment">// Create mouseenter/leave events using mouseover/out and event-time checks</span>
<span class="Comment">// Support: Chrome 15+</span>
jQuery.each({
	mouseenter: <span class="Constant">&quot;mouseover&quot;</span>,
	mouseleave: <span class="Constant">&quot;mouseout&quot;</span>
}, <span class="Type">function</span>( orig, fix ) {
	jQuery.event.special[ orig ] <span class="Statement">=</span> {
		delegateType: fix,
		bindType: fix,

		handle: <span class="Type">function</span>( event ) {
			<span class="Type">var</span> ret,
				target <span class="Statement">=</span> <span class="Special">this</span>,
				related <span class="Statement">=</span> event.relatedTarget,
				handleObj <span class="Statement">=</span> event.handleObj;

<span class="Comment">			// For mousenter/leave call the handler if related is outside the target.</span>
<span class="Comment">			// NB: No relatedTarget if the mouse left/entered the browser window</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>related <span class="Statement">||</span> (related <span class="Statement">!==</span> target <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.contains( target, related )) ) {
				event.type <span class="Statement">=</span> handleObj.origType;
				ret <span class="Statement">=</span> handleObj.handler.apply( <span class="Special">this</span>, arguments );
				event.type <span class="Statement">=</span> fix;
			}
			<span class="Statement">return</span> ret;
		}
	};
});

<span class="Comment">// Create &quot;bubbling&quot; focus and blur events</span>
<span class="Comment">// Support: Firefox, Chrome, Safari</span>
<span class="Statement">if</span> ( <span class="Statement">!</span>support.focusinBubbles ) {
	jQuery.each({ focus: <span class="Constant">&quot;focusin&quot;</span>, blur: <span class="Constant">&quot;focusout&quot;</span> }, <span class="Type">function</span>( orig, fix ) {

<span class="Comment">		// Attach a single capturing handler on the document while someone wants focusin/focusout</span>
		<span class="Type">var</span> handler <span class="Statement">=</span> <span class="Type">function</span>( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), <span class="Constant">true</span> );
			};

		jQuery.event.special[ fix ] <span class="Statement">=</span> {
			setup: <span class="Type">function</span>() {
				<span class="Type">var</span> doc <span class="Statement">=</span> <span class="Special">this</span>.ownerDocument <span class="Statement">||</span> <span class="Special">this</span>,
					attaches <span class="Statement">=</span> data_priv.access( doc, fix );

				<span class="Statement">if</span> ( <span class="Statement">!</span>attaches ) {
					doc.addEventListener( orig, handler, <span class="Constant">true</span> );
				}
				data_priv.access( doc, fix, ( attaches <span class="Statement">||</span> <span class="Constant">0</span> ) <span class="Statement">+</span> <span class="Constant">1</span> );
			},
			teardown: <span class="Type">function</span>() {
				<span class="Type">var</span> doc <span class="Statement">=</span> <span class="Special">this</span>.ownerDocument <span class="Statement">||</span> <span class="Special">this</span>,
					attaches <span class="Statement">=</span> data_priv.access( doc, fix ) <span class="Statement">-</span> <span class="Constant">1</span>;

				<span class="Statement">if</span> ( <span class="Statement">!</span>attaches ) {
					doc.removeEventListener( orig, handler, <span class="Constant">true</span> );
					data_priv.remove( doc, fix );

				} <span class="Statement">else</span> {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: <span class="Type">function</span>( types, selector, data, fn, /*INTERNAL*/ one ) {
		<span class="Type">var</span> origFn, type;

<span class="Comment">		// Types can be a map of types/handlers</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> types <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
<span class="Comment">			// ( types-Object, selector, data )</span>
			<span class="Statement">if</span> ( <span class="Statement">typeof</span> selector <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
<span class="Comment">				// ( types-Object, data )</span>
				data <span class="Statement">=</span> data <span class="Statement">||</span> selector;
				selector <span class="Statement">=</span> <span class="Type">undefined</span>;
			}
			<span class="Statement">for</span> ( type <span class="Statement">in</span> types ) {
				<span class="Special">this</span>.on( type, selector, data, types[ type ], one );
			}
			<span class="Statement">return</span> <span class="Special">this</span>;
		}

		<span class="Statement">if</span> ( data <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">&amp;&amp;</span> fn <span class="Statement">==</span> <span class="Type">null</span> ) {
<span class="Comment">			// ( types, fn )</span>
			fn <span class="Statement">=</span> selector;
			data <span class="Statement">=</span> selector <span class="Statement">=</span> <span class="Type">undefined</span>;
		} <span class="Statement">else</span> <span class="Statement">if</span> ( fn <span class="Statement">==</span> <span class="Type">null</span> ) {
			<span class="Statement">if</span> ( <span class="Statement">typeof</span> selector <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
<span class="Comment">				// ( types, selector, fn )</span>
				fn <span class="Statement">=</span> data;
				data <span class="Statement">=</span> <span class="Type">undefined</span>;
			} <span class="Statement">else</span> {
<span class="Comment">				// ( types, data, fn )</span>
				fn <span class="Statement">=</span> data;
				data <span class="Statement">=</span> selector;
				selector <span class="Statement">=</span> <span class="Type">undefined</span>;
			}
		}
		<span class="Statement">if</span> ( fn <span class="Statement">===</span> <span class="Constant">false</span> ) {
			fn <span class="Statement">=</span> returnFalse;
		} <span class="Statement">else</span> <span class="Statement">if</span> ( <span class="Statement">!</span>fn ) {
			<span class="Statement">return</span> <span class="Special">this</span>;
		}

		<span class="Statement">if</span> ( one <span class="Statement">===</span> <span class="Constant">1</span> ) {
			origFn <span class="Statement">=</span> fn;
			fn <span class="Statement">=</span> <span class="Type">function</span>( event ) {
<span class="Comment">				// Can use an empty set, since event contains the info</span>
				jQuery().off( event );
				<span class="Statement">return</span> origFn.apply( <span class="Special">this</span>, arguments );
			};
<span class="Comment">			// Use same guid so caller can remove using origFn</span>
			fn.guid <span class="Statement">=</span> origFn.guid <span class="Statement">||</span> ( origFn.guid <span class="Statement">=</span> jQuery.guid<span class="Statement">++</span> );
		}
		<span class="Statement">return</span> <span class="Special">this</span>.each( <span class="Type">function</span>() {
			jQuery.event.add( <span class="Special">this</span>, types, fn, data, selector );
		});
	},
	one: <span class="Type">function</span>( types, selector, data, fn ) {
		<span class="Statement">return</span> <span class="Special">this</span>.on( types, selector, data, fn, <span class="Constant">1</span> );
	},
	off: <span class="Type">function</span>( types, selector, fn ) {
		<span class="Type">var</span> handleObj, type;
		<span class="Statement">if</span> ( types <span class="Statement">&amp;&amp;</span> types.preventDefault <span class="Statement">&amp;&amp;</span> types.handleObj ) {
<span class="Comment">			// ( event )  dispatched jQuery.Event</span>
			handleObj <span class="Statement">=</span> types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace <span class="Statement">?</span> handleObj.origType <span class="Statement">+</span> <span class="Constant">&quot;.&quot;</span> <span class="Statement">+</span> handleObj.namespace <span class="Statement">:</span> handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			<span class="Statement">return</span> <span class="Special">this</span>;
		}
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> types <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
<span class="Comment">			// ( types-object [, selector] )</span>
			<span class="Statement">for</span> ( type <span class="Statement">in</span> types ) {
				<span class="Special">this</span>.off( type, selector, types[ type ] );
			}
			<span class="Statement">return</span> <span class="Special">this</span>;
		}
		<span class="Statement">if</span> ( selector <span class="Statement">===</span> <span class="Constant">false</span> <span class="Statement">||</span> <span class="Statement">typeof</span> selector <span class="Statement">===</span> <span class="Constant">&quot;function&quot;</span> ) {
<span class="Comment">			// ( types [, fn] )</span>
			fn <span class="Statement">=</span> selector;
			selector <span class="Statement">=</span> <span class="Type">undefined</span>;
		}
		<span class="Statement">if</span> ( fn <span class="Statement">===</span> <span class="Constant">false</span> ) {
			fn <span class="Statement">=</span> returnFalse;
		}
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			jQuery.event.remove( <span class="Special">this</span>, types, fn, selector );
		});
	},

	trigger: <span class="Type">function</span>( type, data ) {
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			jQuery.event.trigger( type, data, <span class="Special">this</span> );
		});
	},
	triggerHandler: <span class="Type">function</span>( type, data ) {
		<span class="Type">var</span> elem <span class="Statement">=</span> <span class="Special">this</span>[<span class="Constant">0</span>];
		<span class="Statement">if</span> ( elem ) {
			<span class="Statement">return</span> jQuery.event.trigger( type, data, elem, <span class="Constant">true</span> );
		}
	}
});


<span class="Type">var</span>
	rxhtmlTag <span class="Statement">=</span> <span class="Constant">/&lt;</span><span class="Constant">(</span><span class="Special">?!</span><span class="Constant">area</span><span class="Statement">|</span><span class="Constant">br</span><span class="Statement">|</span><span class="Constant">col</span><span class="Statement">|</span><span class="Constant">embed</span><span class="Statement">|</span><span class="Constant">hr</span><span class="Statement">|</span><span class="Constant">img</span><span class="Statement">|</span><span class="Constant">input</span><span class="Statement">|</span><span class="Constant">link</span><span class="Statement">|</span><span class="Constant">meta</span><span class="Statement">|</span><span class="Constant">param)((</span><span class="Constant">[\w:]</span><span class="Special">+</span><span class="Constant">)</span><span class="Constant">[^&gt;]</span><span class="Special">*</span><span class="Constant">)</span><span class="Special">\/</span><span class="Constant">&gt;/gi</span>,
	rtagName <span class="Statement">=</span> <span class="Constant">/&lt;</span><span class="Constant">(</span><span class="Constant">[\w:]</span><span class="Special">+</span><span class="Constant">)</span><span class="Constant">/</span>,
	rhtml <span class="Statement">=</span> <span class="Constant">/&lt;</span><span class="Statement">|</span><span class="Constant">&amp;#</span><span class="Special">?</span><span class="Special">\w</span><span class="Special">+</span><span class="Constant">;/</span>,
	rnoInnerhtml <span class="Statement">=</span> <span class="Constant">/&lt;</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">script</span><span class="Statement">|</span><span class="Constant">style</span><span class="Statement">|</span><span class="Constant">link)</span><span class="Constant">/i</span>,
<span class="Comment">	// checked=&quot;checked&quot; or checked</span>
	rchecked <span class="Statement">=</span> <span class="Constant">/checked</span><span class="Special">\s</span><span class="Special">*</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">[^=]</span><span class="Statement">|</span><span class="Constant">=</span><span class="Special">\s</span><span class="Special">*</span><span class="Constant">.checked.)</span><span class="Constant">/i</span>,
	rscriptType <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^$</span><span class="Statement">|</span><span class="Special">\/</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">java</span><span class="Statement">|</span><span class="Constant">ecma)</span><span class="Constant">script/i</span>,
	rscriptTypeMasked <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">true</span><span class="Special">\/</span><span class="Constant">(.</span><span class="Special">*</span><span class="Constant">)</span><span class="Constant">/</span>,
	rcleanScript <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Special">\s</span><span class="Special">*</span><span class="Constant">&lt;!</span><span class="Constant">(</span><span class="Special">?:</span><span class="Special">\[</span><span class="Constant">CDATA</span><span class="Special">\[</span><span class="Statement">|</span><span class="Constant">--)</span><span class="Statement">|</span><span class="Constant">(</span><span class="Special">?:</span><span class="Special">\]\]</span><span class="Statement">|</span><span class="Constant">--)</span><span class="Constant">&gt;</span><span class="Special">\s</span><span class="Special">*</span><span class="Special">$</span><span class="Constant">/g</span>,

<span class="Comment">	// We have to close these tags to support XHTML (#13200)</span>
	wrapMap <span class="Statement">=</span> {

<span class="Comment">		// Support: IE 9</span>
		option: [ <span class="Constant">1</span>, <span class="Constant">&quot;&lt;select multiple='multiple'&gt;&quot;</span>, <span class="Constant">&quot;&lt;/select&gt;&quot;</span> ],

		thead: [ <span class="Constant">1</span>, <span class="Constant">&quot;&lt;table&gt;&quot;</span>, <span class="Constant">&quot;&lt;/table&gt;&quot;</span> ],
		col: [ <span class="Constant">2</span>, <span class="Constant">&quot;&lt;table&gt;&lt;colgroup&gt;&quot;</span>, <span class="Constant">&quot;&lt;/colgroup&gt;&lt;/table&gt;&quot;</span> ],
		tr: [ <span class="Constant">2</span>, <span class="Constant">&quot;&lt;table&gt;&lt;tbody&gt;&quot;</span>, <span class="Constant">&quot;&lt;/tbody&gt;&lt;/table&gt;&quot;</span> ],
		td: [ <span class="Constant">3</span>, <span class="Constant">&quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;</span>, <span class="Constant">&quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot;</span> ],

		_default: [ <span class="Constant">0</span>, <span class="Constant">&quot;&quot;</span>, <span class="Constant">&quot;&quot;</span> ]
	};

<span class="Comment">// Support: IE 9</span>
wrapMap.optgroup <span class="Statement">=</span> wrapMap.option;

wrapMap.tbody <span class="Statement">=</span> wrapMap.tfoot <span class="Statement">=</span> wrapMap.colgroup <span class="Statement">=</span> wrapMap.caption <span class="Statement">=</span> wrapMap.thead;
wrapMap.th <span class="Statement">=</span> wrapMap.td;

<span class="Comment">// Support: 1.x compatibility</span>
<span class="Comment">// Manipulating tables requires a tbody</span>
<span class="Type">function</span> <span class="Identifier">manipulationTarget</span>( elem, content ) {
	<span class="Statement">return</span> jQuery.nodeName( elem, <span class="Constant">&quot;table&quot;</span> ) <span class="Statement">&amp;&amp;</span>
		jQuery.nodeName( content.nodeType <span class="Statement">!==</span> <span class="Constant">11</span> <span class="Statement">?</span> content <span class="Statement">:</span> content.firstChild, <span class="Constant">&quot;tr&quot;</span> ) <span class="Statement">?</span>

		elem.getElementsByTagName(<span class="Constant">&quot;tbody&quot;</span>)[<span class="Constant">0</span>] <span class="Statement">||</span>
			elem.appendChild( elem.ownerDocument.createElement(<span class="Constant">&quot;tbody&quot;</span>) ) <span class="Statement">:</span>
		elem;
}

<span class="Comment">// Replace/restore the type attribute of script elements for safe DOM manipulation</span>
<span class="Type">function</span> <span class="Identifier">disableScript</span>( elem ) {
	elem.type <span class="Statement">=</span> (elem.getAttribute(<span class="Constant">&quot;type&quot;</span>) <span class="Statement">!==</span> <span class="Type">null</span>) <span class="Statement">+</span> <span class="Constant">&quot;/&quot;</span> <span class="Statement">+</span> elem.type;
	<span class="Statement">return</span> elem;
}
<span class="Type">function</span> <span class="Identifier">restoreScript</span>( elem ) {
	<span class="Type">var</span> match <span class="Statement">=</span> rscriptTypeMasked.exec( elem.type );

	<span class="Statement">if</span> ( match ) {
		elem.type <span class="Statement">=</span> match[ <span class="Constant">1</span> ];
	} <span class="Statement">else</span> {
		elem.removeAttribute(<span class="Constant">&quot;type&quot;</span>);
	}

	<span class="Statement">return</span> elem;
}

<span class="Comment">// Mark scripts as having already been evaluated</span>
<span class="Type">function</span> <span class="Identifier">setGlobalEval</span>( elems, refElements ) {
	<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
		l <span class="Statement">=</span> elems.length;

	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
		data_priv.set(
			elems[ i ], <span class="Constant">&quot;globalEval&quot;</span>, <span class="Statement">!</span>refElements <span class="Statement">||</span> data_priv.get( refElements[ i ], <span class="Constant">&quot;globalEval&quot;</span> )
		);
	}
}

<span class="Type">function</span> <span class="Identifier">cloneCopyEvent</span>( src, dest ) {
	<span class="Type">var</span> i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	<span class="Statement">if</span> ( dest.nodeType <span class="Statement">!==</span> <span class="Constant">1</span> ) {
		<span class="Statement">return</span>;
	}

<span class="Comment">	// 1. Copy private data: events, handlers, etc.</span>
	<span class="Statement">if</span> ( data_priv.hasData( src ) ) {
		pdataOld <span class="Statement">=</span> data_priv.access( src );
		pdataCur <span class="Statement">=</span> data_priv.set( dest, pdataOld );
		events <span class="Statement">=</span> pdataOld.events;

		<span class="Statement">if</span> ( events ) {
			<span class="Statement">delete</span> pdataCur.handle;
			pdataCur.events <span class="Statement">=</span> {};

			<span class="Statement">for</span> ( type <span class="Statement">in</span> events ) {
				<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>, l <span class="Statement">=</span> events[ type ].length; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

<span class="Comment">	// 2. Copy user data</span>
	<span class="Statement">if</span> ( data_user.hasData( src ) ) {
		udataOld <span class="Statement">=</span> data_user.access( src );
		udataCur <span class="Statement">=</span> jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

<span class="Type">function</span> <span class="Identifier">getAll</span>( context, tag ) {
	<span class="Type">var</span> ret <span class="Statement">=</span> context.getElementsByTagName <span class="Statement">?</span> context.getElementsByTagName( tag <span class="Statement">||</span> <span class="Constant">&quot;*&quot;</span> ) <span class="Statement">:</span>
			context.querySelectorAll <span class="Statement">?</span> context.querySelectorAll( tag <span class="Statement">||</span> <span class="Constant">&quot;*&quot;</span> ) <span class="Statement">:</span>
			[];

	<span class="Statement">return</span> tag <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">||</span> tag <span class="Statement">&amp;&amp;</span> jQuery.nodeName( context, tag ) <span class="Statement">?</span>
		jQuery.merge( [ context ], ret ) <span class="Statement">:</span>
		ret;
}

<span class="Comment">// Support: IE &gt;= 9</span>
<span class="Type">function</span> <span class="Identifier">fixInput</span>( src, dest ) {
	<span class="Type">var</span> nodeName <span class="Statement">=</span> dest.nodeName.toLowerCase();

<span class="Comment">	// Fails to persist the checked state of a cloned checkbox or radio button.</span>
	<span class="Statement">if</span> ( nodeName <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">&amp;&amp;</span> rcheckableType.test( src.type ) ) {
		dest.checked <span class="Statement">=</span> src.checked;

<span class="Comment">	// Fails to return the selected option to the default selected state when cloning options</span>
	} <span class="Statement">else</span> <span class="Statement">if</span> ( nodeName <span class="Statement">===</span> <span class="Constant">&quot;input&quot;</span> <span class="Statement">||</span> nodeName <span class="Statement">===</span> <span class="Constant">&quot;textarea&quot;</span> ) {
		dest.defaultValue <span class="Statement">=</span> src.defaultValue;
	}
}

jQuery.extend({
	clone: <span class="Type">function</span>( elem, dataAndEvents, deepDataAndEvents ) {
		<span class="Type">var</span> i, l, srcElements, destElements,
			clone <span class="Statement">=</span> elem.cloneNode( <span class="Constant">true</span> ),
			inPage <span class="Statement">=</span> jQuery.contains( elem.ownerDocument, elem );

<span class="Comment">		// Support: IE &gt;= 9</span>
<span class="Comment">		// Fix Cloning issues</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>support.noCloneChecked <span class="Statement">&amp;&amp;</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">11</span> ) <span class="Statement">&amp;&amp;</span>
				<span class="Statement">!</span>jQuery.isXMLDoc( elem ) ) {

<span class="Comment">			// We eschew Sizzle here for performance reasons: <a href="http://jsperf.com/getall-vs-sizzle/2">http://jsperf.com/getall-vs-sizzle/2</a></span>
			destElements <span class="Statement">=</span> getAll( clone );
			srcElements <span class="Statement">=</span> getAll( elem );

			<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>, l <span class="Statement">=</span> srcElements.length; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

<span class="Comment">		// Copy the events from the original to the clone</span>
		<span class="Statement">if</span> ( dataAndEvents ) {
			<span class="Statement">if</span> ( deepDataAndEvents ) {
				srcElements <span class="Statement">=</span> srcElements <span class="Statement">||</span> getAll( elem );
				destElements <span class="Statement">=</span> destElements <span class="Statement">||</span> getAll( clone );

				<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>, l <span class="Statement">=</span> srcElements.length; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} <span class="Statement">else</span> {
				cloneCopyEvent( elem, clone );
			}
		}

<span class="Comment">		// Preserve script evaluation history</span>
		destElements <span class="Statement">=</span> getAll( clone, <span class="Constant">&quot;script&quot;</span> );
		<span class="Statement">if</span> ( destElements.length <span class="Statement">&gt;</span> <span class="Constant">0</span> ) {
			setGlobalEval( destElements, <span class="Statement">!</span>inPage <span class="Statement">&amp;&amp;</span> getAll( elem, <span class="Constant">&quot;script&quot;</span> ) );
		}

<span class="Comment">		// Return the cloned set</span>
		<span class="Statement">return</span> clone;
	},

	buildFragment: <span class="Type">function</span>( elems, context, scripts, selection ) {
		<span class="Type">var</span> elem, tmp, tag, wrap, contains, j,
			fragment <span class="Statement">=</span> context.createDocumentFragment(),
			nodes <span class="Statement">=</span> [],
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			l <span class="Statement">=</span> elems.length;

		<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
			elem <span class="Statement">=</span> elems[ i ];

			<span class="Statement">if</span> ( elem <span class="Statement">||</span> elem <span class="Statement">===</span> <span class="Constant">0</span> ) {

<span class="Comment">				// Add nodes directly</span>
				<span class="Statement">if</span> ( jQuery.type( elem ) <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
<span class="Comment">					// Support: QtWebKit</span>
<span class="Comment">					// jQuery.merge because push.apply(_, arraylike) throws</span>
					jQuery.merge( nodes, elem.nodeType <span class="Statement">?</span> [ elem ] <span class="Statement">:</span> elem );

<span class="Comment">				// Convert non-html into a text node</span>
				} <span class="Statement">else</span> <span class="Statement">if</span> ( <span class="Statement">!</span>rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

<span class="Comment">				// Convert html into DOM nodes</span>
				} <span class="Statement">else</span> {
					tmp <span class="Statement">=</span> tmp <span class="Statement">||</span> fragment.appendChild( context.createElement(<span class="Constant">&quot;div&quot;</span>) );

<span class="Comment">					// Deserialize a standard representation</span>
					tag <span class="Statement">=</span> ( rtagName.exec( elem ) <span class="Statement">||</span> [ <span class="Constant">&quot;&quot;</span>, <span class="Constant">&quot;&quot;</span> ] )[ <span class="Constant">1</span> ].toLowerCase();
					wrap <span class="Statement">=</span> wrapMap[ tag ] <span class="Statement">||</span> wrapMap._default;
					tmp.innerHTML <span class="Statement">=</span> wrap[ <span class="Constant">1</span> ] <span class="Statement">+</span> elem.replace( rxhtmlTag, <span class="Constant">&quot;&lt;$1&gt;&lt;/$2&gt;&quot;</span> ) <span class="Statement">+</span> wrap[ <span class="Constant">2</span> ];

<span class="Comment">					// Descend through wrappers to the right content</span>
					j <span class="Statement">=</span> wrap[ <span class="Constant">0</span> ];
					<span class="Statement">while</span> ( j<span class="Statement">--</span> ) {
						tmp <span class="Statement">=</span> tmp.lastChild;
					}

<span class="Comment">					// Support: QtWebKit</span>
<span class="Comment">					// jQuery.merge because push.apply(_, arraylike) throws</span>
					jQuery.merge( nodes, tmp.childNodes );

<span class="Comment">					// Remember the top-level container</span>
					tmp <span class="Statement">=</span> fragment.firstChild;

<span class="Comment">					// Fixes #12346</span>
<span class="Comment">					// Support: Webkit, IE</span>
					tmp.textContent <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
				}
			}
		}

<span class="Comment">		// Remove wrapper from fragment</span>
		fragment.textContent <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;

		i <span class="Statement">=</span> <span class="Constant">0</span>;
		<span class="Statement">while</span> ( (elem <span class="Statement">=</span> nodes[ i<span class="Statement">++</span> ]) ) {

<span class="Comment">			// #4087 - If origin and destination elements are the same, and this is</span>
<span class="Comment">			// that element, do not do anything</span>
			<span class="Statement">if</span> ( selection <span class="Statement">&amp;&amp;</span> jQuery.inArray( elem, selection ) <span class="Statement">!==</span> <span class="Statement">-</span><span class="Constant">1</span> ) {
				<span class="Statement">continue</span>;
			}

			contains <span class="Statement">=</span> jQuery.contains( elem.ownerDocument, elem );

<span class="Comment">			// Append to fragment</span>
			tmp <span class="Statement">=</span> getAll( fragment.appendChild( elem ), <span class="Constant">&quot;script&quot;</span> );

<span class="Comment">			// Preserve script evaluation history</span>
			<span class="Statement">if</span> ( contains ) {
				setGlobalEval( tmp );
			}

<span class="Comment">			// Capture executables</span>
			<span class="Statement">if</span> ( scripts ) {
				j <span class="Statement">=</span> <span class="Constant">0</span>;
				<span class="Statement">while</span> ( (elem <span class="Statement">=</span> tmp[ j<span class="Statement">++</span> ]) ) {
					<span class="Statement">if</span> ( rscriptType.test( elem.type <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		<span class="Statement">return</span> fragment;
	},

	cleanData: <span class="Type">function</span>( elems ) {
		<span class="Type">var</span> data, elem, events, type, key, j,
			special <span class="Statement">=</span> jQuery.event.special,
			i <span class="Statement">=</span> <span class="Constant">0</span>;

		<span class="Statement">for</span> ( ; (elem <span class="Statement">=</span> elems[ i ]) <span class="Statement">!==</span> <span class="Type">undefined</span>; i<span class="Statement">++</span> ) {
			<span class="Statement">if</span> ( jQuery.acceptData( elem ) ) {
				key <span class="Statement">=</span> elem[ data_priv.expando ];

				<span class="Statement">if</span> ( key <span class="Statement">&amp;&amp;</span> (data <span class="Statement">=</span> data_priv.cache[ key ]) ) {
					events <span class="Statement">=</span> <span class="Special">Object</span>.keys( data.events <span class="Statement">||</span> {} );
					<span class="Statement">if</span> ( events.length ) {
						<span class="Statement">for</span> ( j <span class="Statement">=</span> <span class="Constant">0</span>; (type <span class="Statement">=</span> events[j]) <span class="Statement">!==</span> <span class="Type">undefined</span>; j<span class="Statement">++</span> ) {
							<span class="Statement">if</span> ( special[ type ] ) {
								jQuery.event.remove( elem, type );

<span class="Comment">							// This is a shortcut to avoid jQuery.event.remove's overhead</span>
							} <span class="Statement">else</span> {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					<span class="Statement">if</span> ( data_priv.cache[ key ] ) {
<span class="Comment">						// Discard any remaining `private` data</span>
						<span class="Statement">delete</span> data_priv.cache[ key ];
					}
				}
			}
<span class="Comment">			// Discard any remaining `user` data</span>
			<span class="Statement">delete</span> data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: <span class="Type">function</span>( value ) {
		<span class="Statement">return</span> access( <span class="Special">this</span>, <span class="Type">function</span>( value ) {
			<span class="Statement">return</span> value <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">?</span>
				jQuery.text( <span class="Special">this</span> ) <span class="Statement">:</span>
				<span class="Special">this</span>.empty().each(<span class="Type">function</span>() {
					<span class="Statement">if</span> ( <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">11</span> <span class="Statement">||</span> <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">9</span> ) {
						<span class="Special">this</span>.textContent <span class="Statement">=</span> value;
					}
				});
		}, <span class="Type">null</span>, value, arguments.length );
	},

	append: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.domManip( arguments, <span class="Type">function</span>( elem ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">11</span> <span class="Statement">||</span> <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">9</span> ) {
				<span class="Type">var</span> target <span class="Statement">=</span> manipulationTarget( <span class="Special">this</span>, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.domManip( arguments, <span class="Type">function</span>( elem ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">||</span> <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">11</span> <span class="Statement">||</span> <span class="Special">this</span>.nodeType <span class="Statement">===</span> <span class="Constant">9</span> ) {
				<span class="Type">var</span> target <span class="Statement">=</span> manipulationTarget( <span class="Special">this</span>, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.domManip( arguments, <span class="Type">function</span>( elem ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>.parentNode ) {
				<span class="Special">this</span>.parentNode.insertBefore( elem, <span class="Special">this</span> );
			}
		});
	},

	after: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.domManip( arguments, <span class="Type">function</span>( elem ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>.parentNode ) {
				<span class="Special">this</span>.parentNode.insertBefore( elem, <span class="Special">this</span>.nextSibling );
			}
		});
	},

	remove: <span class="Type">function</span>( selector, keepData /* Internal Use Only */ ) {
		<span class="Type">var</span> elem,
			elems <span class="Statement">=</span> selector <span class="Statement">?</span> jQuery.filter( selector, <span class="Special">this</span> ) <span class="Statement">:</span> <span class="Special">this</span>,
			i <span class="Statement">=</span> <span class="Constant">0</span>;

		<span class="Statement">for</span> ( ; (elem <span class="Statement">=</span> elems[i]) <span class="Statement">!=</span> <span class="Type">null</span>; i<span class="Statement">++</span> ) {
			<span class="Statement">if</span> ( <span class="Statement">!</span>keepData <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
				jQuery.cleanData( getAll( elem ) );
			}

			<span class="Statement">if</span> ( elem.parentNode ) {
				<span class="Statement">if</span> ( keepData <span class="Statement">&amp;&amp;</span> jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, <span class="Constant">&quot;script&quot;</span> ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>;
	},

	empty: <span class="Type">function</span>() {
		<span class="Type">var</span> elem,
			i <span class="Statement">=</span> <span class="Constant">0</span>;

		<span class="Statement">for</span> ( ; (elem <span class="Statement">=</span> <span class="Special">this</span>[i]) <span class="Statement">!=</span> <span class="Type">null</span>; i<span class="Statement">++</span> ) {
			<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {

<span class="Comment">				// Prevent memory leaks</span>
				jQuery.cleanData( getAll( elem, <span class="Constant">false</span> ) );

<span class="Comment">				// Remove any remaining nodes</span>
				elem.textContent <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>;
	},

	clone: <span class="Type">function</span>( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents <span class="Statement">=</span> dataAndEvents <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">false</span> <span class="Statement">:</span> dataAndEvents;
		deepDataAndEvents <span class="Statement">=</span> deepDataAndEvents <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> dataAndEvents <span class="Statement">:</span> deepDataAndEvents;

		<span class="Statement">return</span> <span class="Special">this</span>.map(<span class="Type">function</span>() {
			<span class="Statement">return</span> jQuery.clone( <span class="Special">this</span>, dataAndEvents, deepDataAndEvents );
		});
	},

	html: <span class="Type">function</span>( value ) {
		<span class="Statement">return</span> access( <span class="Special">this</span>, <span class="Type">function</span>( value ) {
			<span class="Type">var</span> elem <span class="Statement">=</span> <span class="Special">this</span>[ <span class="Constant">0</span> ] <span class="Statement">||</span> {},
				i <span class="Statement">=</span> <span class="Constant">0</span>,
				l <span class="Statement">=</span> <span class="Special">this</span>.length;

			<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
				<span class="Statement">return</span> elem.innerHTML;
			}

<span class="Comment">			// See if we can take a shortcut and just use innerHTML</span>
			<span class="Statement">if</span> ( <span class="Statement">typeof</span> value <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>rnoInnerhtml.test( value ) <span class="Statement">&amp;&amp;</span>
				<span class="Statement">!</span>wrapMap[ ( rtagName.exec( value ) <span class="Statement">||</span> [ <span class="Constant">&quot;&quot;</span>, <span class="Constant">&quot;&quot;</span> ] )[ <span class="Constant">1</span> ].toLowerCase() ] ) {

				value <span class="Statement">=</span> value.replace( rxhtmlTag, <span class="Constant">&quot;&lt;$1&gt;&lt;/$2&gt;&quot;</span> );

				<span class="Statement">try</span> {
					<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
						elem <span class="Statement">=</span> <span class="Special">this</span>[ i ] <span class="Statement">||</span> {};

<span class="Comment">						// Remove element nodes and prevent memory leaks</span>
						<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
							jQuery.cleanData( getAll( elem, <span class="Constant">false</span> ) );
							elem.innerHTML <span class="Statement">=</span> value;
						}
					}

					elem <span class="Statement">=</span> <span class="Constant">0</span>;

<span class="Comment">				// If using innerHTML throws an exception, use the fallback method</span>
				} <span class="Statement">catch</span>( e ) {}
			}

			<span class="Statement">if</span> ( elem ) {
				<span class="Special">this</span>.empty().append( value );
			}
		}, <span class="Type">null</span>, value, arguments.length );
	},

	replaceWith: <span class="Type">function</span>() {
		<span class="Type">var</span> arg <span class="Statement">=</span> <span class="Special">arguments</span>[ <span class="Constant">0</span> ];

<span class="Comment">		// Make the changes, replacing each context element with the new content</span>
		<span class="Special">this</span>.domManip( arguments, <span class="Type">function</span>( elem ) {
			arg <span class="Statement">=</span> <span class="Special">this</span>.parentNode;

			jQuery.cleanData( getAll( <span class="Special">this</span> ) );

			<span class="Statement">if</span> ( arg ) {
				arg.replaceChild( elem, <span class="Special">this</span> );
			}
		});

<span class="Comment">		// Force removal if there was no new content (e.g., from empty arguments)</span>
		<span class="Statement">return</span> arg <span class="Statement">&amp;&amp;</span> (arg.length <span class="Statement">||</span> arg.nodeType) <span class="Statement">?</span> <span class="Special">this</span> <span class="Statement">:</span> <span class="Special">this</span>.remove();
	},

	detach: <span class="Type">function</span>( selector ) {
		<span class="Statement">return</span> <span class="Special">this</span>.remove( selector, <span class="Constant">true</span> );
	},

	domManip: <span class="Type">function</span>( args, callback ) {

<span class="Comment">		// Flatten any nested arrays</span>
		args <span class="Statement">=</span> concat.apply( [], args );

		<span class="Type">var</span> fragment, first, scripts, hasScripts, node, doc,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			l <span class="Statement">=</span> <span class="Special">this</span>.length,
			set <span class="Statement">=</span> <span class="Special">this</span>,
			iNoClone <span class="Statement">=</span> l <span class="Statement">-</span> <span class="Constant">1</span>,
			value <span class="Statement">=</span> args[ <span class="Constant">0</span> ],
			isFunction <span class="Statement">=</span> jQuery.isFunction( value );

<span class="Comment">		// We can't cloneNode fragments that contain checked, in WebKit</span>
		<span class="Statement">if</span> ( isFunction <span class="Statement">||</span>
				( l <span class="Statement">&gt;</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> value <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span>
					<span class="Statement">!</span>support.checkClone <span class="Statement">&amp;&amp;</span> rchecked.test( value ) ) ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( index ) {
				<span class="Type">var</span> self <span class="Statement">=</span> set.eq( index );
				<span class="Statement">if</span> ( isFunction ) {
					args[ <span class="Constant">0</span> ] <span class="Statement">=</span> value.call( <span class="Special">this</span>, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		<span class="Statement">if</span> ( l ) {
			fragment <span class="Statement">=</span> jQuery.buildFragment( args, <span class="Special">this</span>[ <span class="Constant">0</span> ].ownerDocument, <span class="Constant">false</span>, <span class="Special">this</span> );
			first <span class="Statement">=</span> fragment.firstChild;

			<span class="Statement">if</span> ( fragment.childNodes.length <span class="Statement">===</span> <span class="Constant">1</span> ) {
				fragment <span class="Statement">=</span> first;
			}

			<span class="Statement">if</span> ( first ) {
				scripts <span class="Statement">=</span> jQuery.map( getAll( fragment, <span class="Constant">&quot;script&quot;</span> ), disableScript );
				hasScripts <span class="Statement">=</span> scripts.length;

<span class="Comment">				// Use the original fragment for the last item instead of the first because it can end up</span>
<span class="Comment">				// being emptied incorrectly in certain situations (#8070).</span>
				<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
					node <span class="Statement">=</span> fragment;

					<span class="Statement">if</span> ( i <span class="Statement">!==</span> iNoClone ) {
						node <span class="Statement">=</span> jQuery.clone( node, <span class="Constant">true</span>, <span class="Constant">true</span> );

<span class="Comment">						// Keep references to cloned scripts for later restoration</span>
						<span class="Statement">if</span> ( hasScripts ) {
<span class="Comment">							// Support: QtWebKit</span>
<span class="Comment">							// jQuery.merge because push.apply(_, arraylike) throws</span>
							jQuery.merge( scripts, getAll( node, <span class="Constant">&quot;script&quot;</span> ) );
						}
					}

					callback.call( <span class="Special">this</span>[ i ], node, i );
				}

				<span class="Statement">if</span> ( hasScripts ) {
					doc <span class="Statement">=</span> scripts[ scripts.length <span class="Statement">-</span> <span class="Constant">1</span> ].ownerDocument;

<span class="Comment">					// Reenable scripts</span>
					jQuery.map( scripts, restoreScript );

<span class="Comment">					// Evaluate executable scripts on first document insertion</span>
					<span class="Statement">for</span> ( i <span class="Statement">=</span> <span class="Constant">0</span>; i <span class="Statement">&lt;</span> hasScripts; i<span class="Statement">++</span> ) {
						node <span class="Statement">=</span> scripts[ i ];
						<span class="Statement">if</span> ( rscriptType.test( node.type <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ) <span class="Statement">&amp;&amp;</span>
							<span class="Statement">!</span>data_priv.access( node, <span class="Constant">&quot;globalEval&quot;</span> ) <span class="Statement">&amp;&amp;</span> jQuery.contains( doc, node ) ) {

							<span class="Statement">if</span> ( node.src ) {
<span class="Comment">								// Optional AJAX dependency, but won't run scripts if not present</span>
								<span class="Statement">if</span> ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} <span class="Statement">else</span> {
								jQuery.globalEval( node.textContent.replace( rcleanScript, <span class="Constant">&quot;&quot;</span> ) );
							}
						}
					}
				}
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>;
	}
});

jQuery.each({
	appendTo: <span class="Constant">&quot;append&quot;</span>,
	prependTo: <span class="Constant">&quot;prepend&quot;</span>,
	insertBefore: <span class="Constant">&quot;before&quot;</span>,
	insertAfter: <span class="Constant">&quot;after&quot;</span>,
	replaceAll: <span class="Constant">&quot;replaceWith&quot;</span>
}, <span class="Type">function</span>( name, original ) {
	jQuery.fn[ name ] <span class="Statement">=</span> <span class="Type">function</span>( selector ) {
		<span class="Type">var</span> elems,
			ret <span class="Statement">=</span> [],
			insert <span class="Statement">=</span> jQuery( selector ),
			last <span class="Statement">=</span> insert.length <span class="Statement">-</span> <span class="Constant">1</span>,
			i <span class="Statement">=</span> <span class="Constant">0</span>;

		<span class="Statement">for</span> ( ; i <span class="Statement">&lt;=</span> last; i<span class="Statement">++</span> ) {
			elems <span class="Statement">=</span> i <span class="Statement">===</span> last <span class="Statement">?</span> <span class="Special">this</span> <span class="Statement">:</span> <span class="Special">this</span>.clone( <span class="Constant">true</span> );
			jQuery( insert[ i ] )[ original ]( elems );

<span class="Comment">			// Support: QtWebKit</span>
<span class="Comment">			// .get() because push.apply(_, arraylike) throws</span>
			push.apply( ret, elems.get() );
		}

		<span class="Statement">return</span> <span class="Special">this</span>.pushStack( ret );
	};
});


<span class="Type">var</span> iframe,
	elemdisplay <span class="Statement">=</span> {};

<span class="Comment">/**</span>
<span class="Comment"> * Retrieve the actual display of a element</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{String}</span><span class="Comment"> </span><span class="Statement">name</span><span class="Comment"> nodeName of the element</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{Object}</span><span class="Comment"> </span><span class="Statement">doc</span><span class="Comment"> Document object</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Comment">// Called only from within defaultDisplay</span>
<span class="Type">function</span> <span class="Identifier">actualDisplay</span>( name, doc ) {
	<span class="Type">var</span> elem <span class="Statement">=</span> jQuery( doc.createElement( name ) ).appendTo( doc.body ),

<span class="Comment">		// getDefaultComputedStyle might be reliably used only on attached element</span>
		display <span class="Statement">=</span> <span class="Special">window</span>.getDefaultComputedStyle <span class="Statement">?</span>

<span class="Comment">			// Use of this method is a temporary fix (more like optmization) until something better comes along,</span>
<span class="Comment">			// since it was removed from specification and supported only in FF</span>
			<span class="Special">window</span>.getDefaultComputedStyle( elem[ <span class="Constant">0</span> ] ).display <span class="Statement">:</span> jQuery.css( elem[ <span class="Constant">0</span> ], <span class="Constant">&quot;display&quot;</span> );

<span class="Comment">	// We don't have any data stored on the element,</span>
<span class="Comment">	// so use &quot;detach&quot; method as fast way to get rid of the element</span>
	elem.detach();

	<span class="Statement">return</span> display;
}

<span class="Comment">/**</span>
<span class="Comment"> * Try to determine the default display value of an element</span>
<span class="Comment"> * </span><span class="Special">@param</span><span class="Comment"> </span><span class="Type">{String}</span><span class="Comment"> </span><span class="Statement">nodeName</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">defaultDisplay</span>( nodeName ) {
	<span class="Type">var</span> doc <span class="Statement">=</span> <span class="Special">document</span>,
		display <span class="Statement">=</span> elemdisplay[ nodeName ];

	<span class="Statement">if</span> ( <span class="Statement">!</span>display ) {
		display <span class="Statement">=</span> actualDisplay( nodeName, doc );

<span class="Comment">		// If the simple way fails, read from inside an iframe</span>
		<span class="Statement">if</span> ( display <span class="Statement">===</span> <span class="Constant">&quot;none&quot;</span> <span class="Statement">||</span> <span class="Statement">!</span>display ) {

<span class="Comment">			// Use the already-created iframe if possible</span>
			iframe <span class="Statement">=</span> (iframe <span class="Statement">||</span> jQuery( <span class="Constant">&quot;&lt;iframe frameborder='0' width='0' height='0'/&gt;&quot;</span> )).appendTo( doc.documentElement );

<span class="Comment">			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse</span>
			doc <span class="Statement">=</span> iframe[ <span class="Constant">0</span> ].contentDocument;

<span class="Comment">			// Support: IE</span>
			doc.write();
			doc.close();

			display <span class="Statement">=</span> actualDisplay( nodeName, doc );
			iframe.detach();
		}

<span class="Comment">		// Store the correct default display</span>
		elemdisplay[ nodeName ] <span class="Statement">=</span> display;
	}

	<span class="Statement">return</span> display;
}
<span class="Type">var</span> rmargin <span class="Statement">=</span> (<span class="Constant">/</span><span class="Special">^</span><span class="Constant">margin/</span>);

<span class="Type">var</span> rnumnonpx <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^(&quot;</span> <span class="Statement">+</span> pnum <span class="Statement">+</span> <span class="Constant">&quot;)(?!px)[a-z%]+$&quot;</span>, <span class="Constant">&quot;i&quot;</span> );

<span class="Type">var</span> getStyles <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
		<span class="Statement">return</span> elem.ownerDocument.defaultView.getComputedStyle( elem, <span class="Type">null</span> );
	};



<span class="Type">function</span> <span class="Identifier">curCSS</span>( elem, name, computed ) {
	<span class="Type">var</span> width, minWidth, maxWidth, ret,
		style <span class="Statement">=</span> elem.style;

	computed <span class="Statement">=</span> computed <span class="Statement">||</span> getStyles( elem );

<span class="Comment">	// Support: IE9</span>
<span class="Comment">	// getPropertyValue is only needed for .css('filter') in IE9, see #12537</span>
	<span class="Statement">if</span> ( computed ) {
		ret <span class="Statement">=</span> computed.getPropertyValue( name ) <span class="Statement">||</span> computed[ name ];
	}

	<span class="Statement">if</span> ( computed ) {

		<span class="Statement">if</span> ( ret <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.contains( elem.ownerDocument, elem ) ) {
			ret <span class="Statement">=</span> jQuery.style( elem, name );
		}

<span class="Comment">		// Support: iOS &lt; 6</span>
<span class="Comment">		// A tribute to the &quot;awesome hack by Dean Edwards&quot;</span>
<span class="Comment">		// iOS &lt; 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels</span>
<span class="Comment">		// this is against the CSSOM draft spec: <a href="http://dev.w3.org/csswg/cssom/#resolved-values">http://dev.w3.org/csswg/cssom/#resolved-values</a></span>
		<span class="Statement">if</span> ( rnumnonpx.test( ret ) <span class="Statement">&amp;&amp;</span> rmargin.test( name ) ) {

<span class="Comment">			// Remember the original values</span>
			width <span class="Statement">=</span> style.width;
			minWidth <span class="Statement">=</span> style.minWidth;
			maxWidth <span class="Statement">=</span> style.maxWidth;

<span class="Comment">			// Put in the new values to get a computed value out</span>
			style.minWidth <span class="Statement">=</span> style.maxWidth <span class="Statement">=</span> style.width <span class="Statement">=</span> ret;
			ret <span class="Statement">=</span> computed.width;

<span class="Comment">			// Revert the changed values</span>
			style.width <span class="Statement">=</span> width;
			style.minWidth <span class="Statement">=</span> minWidth;
			style.maxWidth <span class="Statement">=</span> maxWidth;
		}
	}

	<span class="Statement">return</span> ret <span class="Statement">!==</span> <span class="Type">undefined</span> <span class="Statement">?</span>
<span class="Comment">		// Support: IE</span>
<span class="Comment">		// IE returns zIndex value as an integer.</span>
		ret <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span>
		ret;
}


<span class="Type">function</span> <span class="Identifier">addGetHookIf</span>( conditionFn, hookFn ) {
<span class="Comment">	// Define the hook, we'll check on the first run if it's really needed.</span>
	<span class="Statement">return</span> {
		get: <span class="Type">function</span>() {
			<span class="Statement">if</span> ( conditionFn() ) {
<span class="Comment">				// Hook not needed (or it's not possible to use it due to missing dependency),</span>
<span class="Comment">				// remove it.</span>
<span class="Comment">				// Since there are no other hooks for marginRight, remove the whole object.</span>
				<span class="Statement">delete</span> <span class="Special">this</span>.get;
				<span class="Statement">return</span>;
			}

<span class="Comment">			// Hook needed; redefine it so that the support test is not executed again.</span>

			<span class="Statement">return</span> (<span class="Special">this</span>.get <span class="Statement">=</span> hookFn).apply( <span class="Special">this</span>, arguments );
		}
	};
}


(<span class="Type">function</span>() {
	<span class="Type">var</span> pixelPositionVal, boxSizingReliableVal,
<span class="Comment">		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).</span>
		divReset <span class="Statement">=</span> <span class="Constant">&quot;padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;&quot;</span> <span class="Statement">+</span>
			<span class="Constant">&quot;-moz-box-sizing:content-box;box-sizing:content-box&quot;</span>,
		docElem <span class="Statement">=</span> <span class="Special">document</span>.documentElement,
		container <span class="Statement">=</span> <span class="Special">document</span>.createElement( <span class="Constant">&quot;div&quot;</span> ),
		div <span class="Statement">=</span> <span class="Special">document</span>.createElement( <span class="Constant">&quot;div&quot;</span> );

	div.style.backgroundClip <span class="Statement">=</span> <span class="Constant">&quot;content-box&quot;</span>;
	div.cloneNode( <span class="Constant">true</span> ).style.backgroundClip <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
	support.clearCloneStyle <span class="Statement">=</span> div.style.backgroundClip <span class="Statement">===</span> <span class="Constant">&quot;content-box&quot;</span>;

	container.style.cssText <span class="Statement">=</span> <span class="Constant">&quot;border:0;width:0;height:0;position:absolute;top:0;left:-9999px;&quot;</span> <span class="Statement">+</span>
		<span class="Constant">&quot;margin-top:1px&quot;</span>;
	container.appendChild( div );

<span class="Comment">	// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout</span>
<span class="Comment">	// so they're executed at the same time to save the second computation.</span>
	<span class="Type">function</span> <span class="Identifier">computePixelPositionAndBoxSizingReliable</span>() {
<span class="Comment">		// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).</span>
		div.style.cssText <span class="Statement">=</span> <span class="Constant">&quot;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;&quot;</span> <span class="Statement">+</span>
			<span class="Constant">&quot;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;&quot;</span> <span class="Statement">+</span>
			<span class="Constant">&quot;position:absolute;top:1%&quot;</span>;
		docElem.appendChild( container );

		<span class="Type">var</span> divStyle <span class="Statement">=</span> <span class="Special">window</span>.getComputedStyle( div, <span class="Type">null</span> );
		pixelPositionVal <span class="Statement">=</span> divStyle.top <span class="Statement">!==</span> <span class="Constant">&quot;1%&quot;</span>;
		boxSizingReliableVal <span class="Statement">=</span> divStyle.width <span class="Statement">===</span> <span class="Constant">&quot;4px&quot;</span>;

		docElem.removeChild( container );
	}

<span class="Comment">	// Use window.getComputedStyle because jsdom on node.js will break without it.</span>
	<span class="Statement">if</span> ( <span class="Special">window</span>.getComputedStyle ) {
		jQuery.extend(support, {
			pixelPosition: <span class="Type">function</span>() {
<span class="Comment">				// This test is executed only once but we still do memoizing</span>
<span class="Comment">				// since we can use the boxSizingReliable pre-computing.</span>
<span class="Comment">				// No need to check if the test was already performed, though.</span>
				computePixelPositionAndBoxSizingReliable();
				<span class="Statement">return</span> pixelPositionVal;
			},
			boxSizingReliable: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( boxSizingReliableVal <span class="Statement">==</span> <span class="Type">null</span> ) {
					computePixelPositionAndBoxSizingReliable();
				}
				<span class="Statement">return</span> boxSizingReliableVal;
			},
			reliableMarginRight: <span class="Type">function</span>() {
<span class="Comment">				// Support: Android 2.3</span>
<span class="Comment">				// Check if div with explicit width and no margin-right incorrectly</span>
<span class="Comment">				// gets computed margin-right based on width of container. (#3333)</span>
<span class="Comment">				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right</span>
<span class="Comment">				// This support function is only executed once so no memoizing is needed.</span>
				<span class="Type">var</span> ret,
					marginDiv <span class="Statement">=</span> div.appendChild( <span class="Special">document</span>.createElement( <span class="Constant">&quot;div&quot;</span> ) );
				marginDiv.style.cssText <span class="Statement">=</span> div.style.cssText <span class="Statement">=</span> divReset;
				marginDiv.style.marginRight <span class="Statement">=</span> marginDiv.style.width <span class="Statement">=</span> <span class="Constant">&quot;0&quot;</span>;
				div.style.width <span class="Statement">=</span> <span class="Constant">&quot;1px&quot;</span>;
				docElem.appendChild( container );

				ret <span class="Statement">=</span> <span class="Statement">!</span><span class="Special">parseFloat</span>( <span class="Special">window</span>.getComputedStyle( marginDiv, <span class="Type">null</span> ).marginRight );

				docElem.removeChild( container );

<span class="Comment">				// Clean up the div for other support tests.</span>
				div.innerHTML <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;

				<span class="Statement">return</span> ret;
			}
		});
	}
})();


<span class="Comment">// A method for quickly swapping in/out CSS properties to get correct calculations.</span>
jQuery.swap <span class="Statement">=</span> <span class="Type">function</span>( elem, options, callback, args ) {
	<span class="Type">var</span> ret, name,
		old <span class="Statement">=</span> {};

<span class="Comment">	// Remember the old values, and insert the new ones</span>
	<span class="Statement">for</span> ( name <span class="Statement">in</span> options ) {
		old[ name ] <span class="Statement">=</span> elem.style[ name ];
		elem.style[ name ] <span class="Statement">=</span> options[ name ];
	}

	ret <span class="Statement">=</span> callback.apply( elem, args <span class="Statement">||</span> [] );

<span class="Comment">	// Revert the old values</span>
	<span class="Statement">for</span> ( name <span class="Statement">in</span> options ) {
		elem.style[ name ] <span class="Statement">=</span> old[ name ];
	}

	<span class="Statement">return</span> ret;
};


<span class="Type">var</span>
<span class="Comment">	// swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;</span>
<span class="Comment">	// see here for display values: <a href="https://developer.mozilla.org/en-US/docs/CSS/display">https://developer.mozilla.org/en-US/docs/CSS/display</a></span>
	rdisplayswap <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(none</span><span class="Statement">|</span><span class="Constant">table(</span><span class="Special">?!</span><span class="Constant">-c</span><span class="Constant">[ea]</span><span class="Constant">)</span><span class="Constant">.</span><span class="Special">+</span><span class="Constant">)/</span>,
	rnumsplit <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^(&quot;</span> <span class="Statement">+</span> pnum <span class="Statement">+</span> <span class="Constant">&quot;)(.*)$&quot;</span>, <span class="Constant">&quot;i&quot;</span> ),
	rrelNum <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^([+-])=(&quot;</span> <span class="Statement">+</span> pnum <span class="Statement">+</span> <span class="Constant">&quot;)&quot;</span>, <span class="Constant">&quot;i&quot;</span> ),

	cssShow <span class="Statement">=</span> { position: <span class="Constant">&quot;absolute&quot;</span>, visibility: <span class="Constant">&quot;hidden&quot;</span>, display: <span class="Constant">&quot;block&quot;</span> },
	cssNormalTransform <span class="Statement">=</span> {
		letterSpacing: <span class="Constant">0</span>,
		fontWeight: <span class="Constant">400</span>
	},

	cssPrefixes <span class="Statement">=</span> [ <span class="Constant">&quot;Webkit&quot;</span>, <span class="Constant">&quot;O&quot;</span>, <span class="Constant">&quot;Moz&quot;</span>, <span class="Constant">&quot;ms&quot;</span> ];

<span class="Comment">// return a css property mapped to a potentially vendor prefixed property</span>
<span class="Type">function</span> <span class="Identifier">vendorPropName</span>( style, name ) {

<span class="Comment">	// shortcut for names that are not vendor prefixed</span>
	<span class="Statement">if</span> ( name <span class="Statement">in</span> style ) {
		<span class="Statement">return</span> name;
	}

<span class="Comment">	// check for vendor prefixed names</span>
	<span class="Type">var</span> capName <span class="Statement">=</span> name[<span class="Constant">0</span>].toUpperCase() <span class="Statement">+</span> name.slice(<span class="Constant">1</span>),
		origName <span class="Statement">=</span> name,
		i <span class="Statement">=</span> cssPrefixes.length;

	<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
		name <span class="Statement">=</span> cssPrefixes[ i ] <span class="Statement">+</span> capName;
		<span class="Statement">if</span> ( name <span class="Statement">in</span> style ) {
			<span class="Statement">return</span> name;
		}
	}

	<span class="Statement">return</span> origName;
}

<span class="Type">function</span> <span class="Identifier">setPositiveNumber</span>( elem, value, subtract ) {
	<span class="Type">var</span> matches <span class="Statement">=</span> rnumsplit.exec( value );
	<span class="Statement">return</span> matches <span class="Statement">?</span>
<span class="Comment">		// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks</span>
		<span class="Special">Math</span>.max( <span class="Constant">0</span>, matches[ <span class="Constant">1</span> ] <span class="Statement">-</span> ( subtract <span class="Statement">||</span> <span class="Constant">0</span> ) ) <span class="Statement">+</span> ( matches[ <span class="Constant">2</span> ] <span class="Statement">||</span> <span class="Constant">&quot;px&quot;</span> ) <span class="Statement">:</span>
		value;
}

<span class="Type">function</span> <span class="Identifier">augmentWidthOrHeight</span>( elem, name, extra, isBorderBox, styles ) {
	<span class="Type">var</span> i <span class="Statement">=</span> extra <span class="Statement">===</span> ( isBorderBox <span class="Statement">?</span> <span class="Constant">&quot;border&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;content&quot;</span> ) <span class="Statement">?</span>
<span class="Comment">		// If we already have the right measurement, avoid augmentation</span>
		<span class="Constant">4</span> <span class="Statement">:</span>
<span class="Comment">		// Otherwise initialize for horizontal or vertical properties</span>
		name <span class="Statement">===</span> <span class="Constant">&quot;width&quot;</span> <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Constant">0</span>,

		val <span class="Statement">=</span> <span class="Constant">0</span>;

	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> <span class="Constant">4</span>; i <span class="Statement">+=</span> <span class="Constant">2</span> ) {
<span class="Comment">		// both box models exclude margin, so add it if we want it</span>
		<span class="Statement">if</span> ( extra <span class="Statement">===</span> <span class="Constant">&quot;margin&quot;</span> ) {
			val <span class="Statement">+=</span> jQuery.css( elem, extra <span class="Statement">+</span> cssExpand[ i ], <span class="Constant">true</span>, styles );
		}

		<span class="Statement">if</span> ( isBorderBox ) {
<span class="Comment">			// border-box includes padding, so remove it if we want content</span>
			<span class="Statement">if</span> ( extra <span class="Statement">===</span> <span class="Constant">&quot;content&quot;</span> ) {
				val <span class="Statement">-=</span> jQuery.css( elem, <span class="Constant">&quot;padding&quot;</span> <span class="Statement">+</span> cssExpand[ i ], <span class="Constant">true</span>, styles );
			}

<span class="Comment">			// at this point, extra isn't border nor margin, so remove border</span>
			<span class="Statement">if</span> ( extra <span class="Statement">!==</span> <span class="Constant">&quot;margin&quot;</span> ) {
				val <span class="Statement">-=</span> jQuery.css( elem, <span class="Constant">&quot;border&quot;</span> <span class="Statement">+</span> cssExpand[ i ] <span class="Statement">+</span> <span class="Constant">&quot;Width&quot;</span>, <span class="Constant">true</span>, styles );
			}
		} <span class="Statement">else</span> {
<span class="Comment">			// at this point, extra isn't content, so add padding</span>
			val <span class="Statement">+=</span> jQuery.css( elem, <span class="Constant">&quot;padding&quot;</span> <span class="Statement">+</span> cssExpand[ i ], <span class="Constant">true</span>, styles );

<span class="Comment">			// at this point, extra isn't content nor padding, so add border</span>
			<span class="Statement">if</span> ( extra <span class="Statement">!==</span> <span class="Constant">&quot;padding&quot;</span> ) {
				val <span class="Statement">+=</span> jQuery.css( elem, <span class="Constant">&quot;border&quot;</span> <span class="Statement">+</span> cssExpand[ i ] <span class="Statement">+</span> <span class="Constant">&quot;Width&quot;</span>, <span class="Constant">true</span>, styles );
			}
		}
	}

	<span class="Statement">return</span> val;
}

<span class="Type">function</span> <span class="Identifier">getWidthOrHeight</span>( elem, name, extra ) {

<span class="Comment">	// Start with offset property, which is equivalent to the border-box value</span>
	<span class="Type">var</span> valueIsBorderBox <span class="Statement">=</span> <span class="Constant">true</span>,
		val <span class="Statement">=</span> name <span class="Statement">===</span> <span class="Constant">&quot;width&quot;</span> <span class="Statement">?</span> elem.offsetWidth <span class="Statement">:</span> elem.offsetHeight,
		styles <span class="Statement">=</span> getStyles( elem ),
		isBorderBox <span class="Statement">=</span> jQuery.css( elem, <span class="Constant">&quot;boxSizing&quot;</span>, <span class="Constant">false</span>, styles ) <span class="Statement">===</span> <span class="Constant">&quot;border-box&quot;</span>;

<span class="Comment">	// some non-html elements return undefined for offsetWidth, so check for null/undefined</span>
<span class="Comment">	// svg - <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=649285">https://bugzilla.mozilla.org/show_bug.cgi?id=649285</a></span>
<span class="Comment">	// MathML - <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=491668">https://bugzilla.mozilla.org/show_bug.cgi?id=491668</a></span>
	<span class="Statement">if</span> ( val <span class="Statement">&lt;=</span> <span class="Constant">0</span> <span class="Statement">||</span> val <span class="Statement">==</span> <span class="Type">null</span> ) {
<span class="Comment">		// Fall back to computed then uncomputed css if necessary</span>
		val <span class="Statement">=</span> curCSS( elem, name, styles );
		<span class="Statement">if</span> ( val <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">||</span> val <span class="Statement">==</span> <span class="Type">null</span> ) {
			val <span class="Statement">=</span> elem.style[ name ];
		}

<span class="Comment">		// Computed unit is not pixels. Stop here and return.</span>
		<span class="Statement">if</span> ( rnumnonpx.test(val) ) {
			<span class="Statement">return</span> val;
		}

<span class="Comment">		// we need the check for style in case a browser which returns unreliable values</span>
<span class="Comment">		// for getComputedStyle silently falls back to the reliable elem.style</span>
		valueIsBorderBox <span class="Statement">=</span> isBorderBox <span class="Statement">&amp;&amp;</span>
			( support.boxSizingReliable() <span class="Statement">||</span> val <span class="Statement">===</span> elem.style[ name ] );

<span class="Comment">		// Normalize &quot;&quot;, auto, and prepare for extra</span>
		val <span class="Statement">=</span> <span class="Special">parseFloat</span>( val ) <span class="Statement">||</span> <span class="Constant">0</span>;
	}

<span class="Comment">	// use the active box-sizing model to add/subtract irrelevant styles</span>
	<span class="Statement">return</span> ( val <span class="Statement">+</span>
		augmentWidthOrHeight(
			elem,
			name,
			extra <span class="Statement">||</span> ( isBorderBox <span class="Statement">?</span> <span class="Constant">&quot;border&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;content&quot;</span> ),
			valueIsBorderBox,
			styles
		)
	) <span class="Statement">+</span> <span class="Constant">&quot;px&quot;</span>;
}

<span class="Type">function</span> <span class="Identifier">showHide</span>( elements, show ) {
	<span class="Type">var</span> display, elem, hidden,
		values <span class="Statement">=</span> [],
		index <span class="Statement">=</span> <span class="Constant">0</span>,
		length <span class="Statement">=</span> elements.length;

	<span class="Statement">for</span> ( ; index <span class="Statement">&lt;</span> length; index<span class="Statement">++</span> ) {
		elem <span class="Statement">=</span> elements[ index ];
		<span class="Statement">if</span> ( <span class="Statement">!</span>elem.style ) {
			<span class="Statement">continue</span>;
		}

		values[ index ] <span class="Statement">=</span> data_priv.get( elem, <span class="Constant">&quot;olddisplay&quot;</span> );
		display <span class="Statement">=</span> elem.style.display;
		<span class="Statement">if</span> ( show ) {
<span class="Comment">			// Reset the inline display of this element to learn if it is</span>
<span class="Comment">			// being hidden by cascaded rules or not</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>values[ index ] <span class="Statement">&amp;&amp;</span> display <span class="Statement">===</span> <span class="Constant">&quot;none&quot;</span> ) {
				elem.style.display <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
			}

<span class="Comment">			// Set elements which have been overridden with display: none</span>
<span class="Comment">			// in a stylesheet to whatever the default browser style is</span>
<span class="Comment">			// for such an element</span>
			<span class="Statement">if</span> ( elem.style.display <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">&amp;&amp;</span> isHidden( elem ) ) {
				values[ index ] <span class="Statement">=</span> data_priv.access( elem, <span class="Constant">&quot;olddisplay&quot;</span>, defaultDisplay(elem.nodeName) );
			}
		} <span class="Statement">else</span> {

			<span class="Statement">if</span> ( <span class="Statement">!</span>values[ index ] ) {
				hidden <span class="Statement">=</span> isHidden( elem );

				<span class="Statement">if</span> ( display <span class="Statement">&amp;&amp;</span> display <span class="Statement">!==</span> <span class="Constant">&quot;none&quot;</span> <span class="Statement">||</span> <span class="Statement">!</span>hidden ) {
					data_priv.set( elem, <span class="Constant">&quot;olddisplay&quot;</span>, hidden <span class="Statement">?</span> display <span class="Statement">:</span> jQuery.css(elem, <span class="Constant">&quot;display&quot;</span>) );
				}
			}
		}
	}

<span class="Comment">	// Set the display of most of the elements in a second loop</span>
<span class="Comment">	// to avoid the constant reflow</span>
	<span class="Statement">for</span> ( index <span class="Statement">=</span> <span class="Constant">0</span>; index <span class="Statement">&lt;</span> length; index<span class="Statement">++</span> ) {
		elem <span class="Statement">=</span> elements[ index ];
		<span class="Statement">if</span> ( <span class="Statement">!</span>elem.style ) {
			<span class="Statement">continue</span>;
		}
		<span class="Statement">if</span> ( <span class="Statement">!</span>show <span class="Statement">||</span> elem.style.display <span class="Statement">===</span> <span class="Constant">&quot;none&quot;</span> <span class="Statement">||</span> elem.style.display <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span> ) {
			elem.style.display <span class="Statement">=</span> show <span class="Statement">?</span> values[ index ] <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;none&quot;</span>;
		}
	}

	<span class="Statement">return</span> elements;
}

jQuery.extend({
<span class="Comment">	// Add in style property hooks for overriding the default</span>
<span class="Comment">	// behavior of getting and setting a style property</span>
	cssHooks: {
		opacity: {
			get: <span class="Type">function</span>( elem, computed ) {
				<span class="Statement">if</span> ( computed ) {
<span class="Comment">					// We should always get a number back from opacity</span>
					<span class="Type">var</span> ret <span class="Statement">=</span> curCSS( elem, <span class="Constant">&quot;opacity&quot;</span> );
					<span class="Statement">return</span> ret <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">?</span> <span class="Constant">&quot;1&quot;</span> <span class="Statement">:</span> ret;
				}
			}
		}
	},

<span class="Comment">	// Don't automatically add &quot;px&quot; to these possibly-unitless properties</span>
	cssNumber: {
		<span class="Constant">&quot;columnCount&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;fillOpacity&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;fontWeight&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;lineHeight&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;opacity&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;order&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;orphans&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;widows&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;zIndex&quot;</span>: <span class="Constant">true</span>,
		<span class="Constant">&quot;zoom&quot;</span>: <span class="Constant">true</span>
	},

<span class="Comment">	// Add in properties whose names you wish to fix before</span>
<span class="Comment">	// setting or getting the value</span>
	cssProps: {
<span class="Comment">		// normalize float css property</span>
		<span class="Constant">&quot;float&quot;</span>: <span class="Constant">&quot;cssFloat&quot;</span>
	},

<span class="Comment">	// Get and set the style property on a DOM Node</span>
	style: <span class="Type">function</span>( elem, name, value, extra ) {
<span class="Comment">		// Don't set styles on text and comment nodes</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>elem <span class="Statement">||</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">3</span> <span class="Statement">||</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">8</span> <span class="Statement">||</span> <span class="Statement">!</span>elem.style ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Make sure that we're working with the right name</span>
		<span class="Type">var</span> ret, type, hooks,
			origName <span class="Statement">=</span> jQuery.camelCase( name ),
			style <span class="Statement">=</span> elem.style;

		name <span class="Statement">=</span> jQuery.cssProps[ origName ] <span class="Statement">||</span> ( jQuery.cssProps[ origName ] <span class="Statement">=</span> vendorPropName( style, origName ) );

<span class="Comment">		// gets hook for the prefixed version</span>
<span class="Comment">		// followed by the unprefixed version</span>
		hooks <span class="Statement">=</span> jQuery.cssHooks[ name ] <span class="Statement">||</span> jQuery.cssHooks[ origName ];

<span class="Comment">		// Check if we're setting a value</span>
		<span class="Statement">if</span> ( value <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
			type <span class="Statement">=</span> <span class="Statement">typeof</span> value;

<span class="Comment">			// convert relative number strings (+= or -=) to relative numbers. #7345</span>
			<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> rrelNum.exec( value )) ) {
				value <span class="Statement">=</span> ( ret[<span class="Constant">1</span>] <span class="Statement">+</span> <span class="Constant">1</span> ) <span class="Statement">*</span> ret[<span class="Constant">2</span>] <span class="Statement">+</span> <span class="Special">parseFloat</span>( jQuery.css( elem, name ) );
<span class="Comment">				// Fixes bug #9237</span>
				type <span class="Statement">=</span> <span class="Constant">&quot;number&quot;</span>;
			}

<span class="Comment">			// Make sure that null and NaN values aren't set. See: #7116</span>
			<span class="Statement">if</span> ( value <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">||</span> value <span class="Statement">!==</span> value ) {
				<span class="Statement">return</span>;
			}

<span class="Comment">			// If a number was passed in, add 'px' to the (except for certain CSS properties)</span>
			<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;number&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.cssNumber[ origName ] ) {
				value <span class="Statement">+=</span> <span class="Constant">&quot;px&quot;</span>;
			}

<span class="Comment">			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,</span>
<span class="Comment">			// but it would mean to define eight (for every problematic property) identical functions</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>support.clearCloneStyle <span class="Statement">&amp;&amp;</span> value <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">&amp;&amp;</span> name.indexOf( <span class="Constant">&quot;background&quot;</span> ) <span class="Statement">===</span> <span class="Constant">0</span> ) {
				style[ name ] <span class="Statement">=</span> <span class="Constant">&quot;inherit&quot;</span>;
			}

<span class="Comment">			// If a hook was provided, use that value, otherwise just set the specified value</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>hooks <span class="Statement">||</span> <span class="Statement">!</span>(<span class="Constant">&quot;set&quot;</span> <span class="Statement">in</span> hooks) <span class="Statement">||</span> (value <span class="Statement">=</span> hooks.set( elem, value, extra )) <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
<span class="Comment">				// Support: Chrome, Safari</span>
<span class="Comment">				// Setting style to blank string required to delete &quot;style: x !important;&quot;</span>
				style[ name ] <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
				style[ name ] <span class="Statement">=</span> value;
			}

		} <span class="Statement">else</span> {
<span class="Comment">			// If a hook was provided get the non-computed value from there</span>
			<span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;get&quot;</span> <span class="Statement">in</span> hooks <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> hooks.get( elem, <span class="Constant">false</span>, extra )) <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
				<span class="Statement">return</span> ret;
			}

<span class="Comment">			// Otherwise just get the value from the style object</span>
			<span class="Statement">return</span> style[ name ];
		}
	},

	css: <span class="Type">function</span>( elem, name, extra, styles ) {
		<span class="Type">var</span> val, num, hooks,
			origName <span class="Statement">=</span> jQuery.camelCase( name );

<span class="Comment">		// Make sure that we're working with the right name</span>
		name <span class="Statement">=</span> jQuery.cssProps[ origName ] <span class="Statement">||</span> ( jQuery.cssProps[ origName ] <span class="Statement">=</span> vendorPropName( elem.style, origName ) );

<span class="Comment">		// gets hook for the prefixed version</span>
<span class="Comment">		// followed by the unprefixed version</span>
		hooks <span class="Statement">=</span> jQuery.cssHooks[ name ] <span class="Statement">||</span> jQuery.cssHooks[ origName ];

<span class="Comment">		// If a hook was provided get the computed value from there</span>
		<span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;get&quot;</span> <span class="Statement">in</span> hooks ) {
			val <span class="Statement">=</span> hooks.get( elem, <span class="Constant">true</span>, extra );
		}

<span class="Comment">		// Otherwise, if a way to get the computed value exists, use that</span>
		<span class="Statement">if</span> ( val <span class="Statement">===</span> <span class="Type">undefined</span> ) {
			val <span class="Statement">=</span> curCSS( elem, name, styles );
		}

<span class="Comment">		//convert &quot;normal&quot; to computed value</span>
		<span class="Statement">if</span> ( val <span class="Statement">===</span> <span class="Constant">&quot;normal&quot;</span> <span class="Statement">&amp;&amp;</span> name <span class="Statement">in</span> cssNormalTransform ) {
			val <span class="Statement">=</span> cssNormalTransform[ name ];
		}

<span class="Comment">		// Return, converting to number if forced or a qualifier was provided and val looks numeric</span>
		<span class="Statement">if</span> ( extra <span class="Statement">===</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">||</span> extra ) {
			num <span class="Statement">=</span> <span class="Special">parseFloat</span>( val );
			<span class="Statement">return</span> extra <span class="Statement">===</span> <span class="Constant">true</span> <span class="Statement">||</span> jQuery.isNumeric( num ) <span class="Statement">?</span> num <span class="Statement">||</span> <span class="Constant">0</span> <span class="Statement">:</span> val;
		}
		<span class="Statement">return</span> val;
	}
});

jQuery.each([ <span class="Constant">&quot;height&quot;</span>, <span class="Constant">&quot;width&quot;</span> ], <span class="Type">function</span>( i, name ) {
	jQuery.cssHooks[ name ] <span class="Statement">=</span> {
		get: <span class="Type">function</span>( elem, computed, extra ) {
			<span class="Statement">if</span> ( computed ) {
<span class="Comment">				// certain elements can have dimension info if we invisibly show them</span>
<span class="Comment">				// however, it must have a current display style that would benefit from this</span>
				<span class="Statement">return</span> elem.offsetWidth <span class="Statement">===</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span> rdisplayswap.test( jQuery.css( elem, <span class="Constant">&quot;display&quot;</span> ) ) <span class="Statement">?</span>
					jQuery.swap( elem, cssShow, <span class="Type">function</span>() {
						<span class="Statement">return</span> getWidthOrHeight( elem, name, extra );
					}) <span class="Statement">:</span>
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: <span class="Type">function</span>( elem, value, extra ) {
			<span class="Type">var</span> styles <span class="Statement">=</span> extra <span class="Statement">&amp;&amp;</span> getStyles( elem );
			<span class="Statement">return</span> setPositiveNumber( elem, value, extra <span class="Statement">?</span>
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, <span class="Constant">&quot;boxSizing&quot;</span>, <span class="Constant">false</span>, styles ) <span class="Statement">===</span> <span class="Constant">&quot;border-box&quot;</span>,
					styles
				) <span class="Statement">:</span> <span class="Constant">0</span>
			);
		}
	};
});

<span class="Comment">// Support: Android 2.3</span>
jQuery.cssHooks.marginRight <span class="Statement">=</span> addGetHookIf( support.reliableMarginRight,
	<span class="Type">function</span>( elem, computed ) {
		<span class="Statement">if</span> ( computed ) {
<span class="Comment">			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right</span>
<span class="Comment">			// Work around by temporarily setting element display to inline-block</span>
			<span class="Statement">return</span> jQuery.swap( elem, { <span class="Constant">&quot;display&quot;</span>: <span class="Constant">&quot;inline-block&quot;</span> },
				curCSS, [ elem, <span class="Constant">&quot;marginRight&quot;</span> ] );
		}
	}
);

<span class="Comment">// These hooks are used by animate to expand properties</span>
jQuery.each({
	margin: <span class="Constant">&quot;&quot;</span>,
	padding: <span class="Constant">&quot;&quot;</span>,
	border: <span class="Constant">&quot;Width&quot;</span>
}, <span class="Type">function</span>( prefix, suffix ) {
	jQuery.cssHooks[ prefix <span class="Statement">+</span> suffix ] <span class="Statement">=</span> {
		expand: <span class="Type">function</span>( value ) {
			<span class="Type">var</span> i <span class="Statement">=</span> <span class="Constant">0</span>,
				expanded <span class="Statement">=</span> {},

<span class="Comment">				// assumes a single number if not a string</span>
				parts <span class="Statement">=</span> <span class="Statement">typeof</span> value <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">?</span> value.split(<span class="Constant">&quot; &quot;</span>) <span class="Statement">:</span> [ value ];

			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> <span class="Constant">4</span>; i<span class="Statement">++</span> ) {
				expanded[ prefix <span class="Statement">+</span> cssExpand[ i ] <span class="Statement">+</span> suffix ] <span class="Statement">=</span>
					parts[ i ] <span class="Statement">||</span> parts[ i <span class="Statement">-</span> <span class="Constant">2</span> ] <span class="Statement">||</span> parts[ <span class="Constant">0</span> ];
			}

			<span class="Statement">return</span> expanded;
		}
	};

	<span class="Statement">if</span> ( <span class="Statement">!</span>rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix <span class="Statement">+</span> suffix ].set <span class="Statement">=</span> setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: <span class="Type">function</span>( name, value ) {
		<span class="Statement">return</span> access( <span class="Special">this</span>, <span class="Type">function</span>( elem, name, value ) {
			<span class="Type">var</span> styles, len,
				map <span class="Statement">=</span> {},
				i <span class="Statement">=</span> <span class="Constant">0</span>;

			<span class="Statement">if</span> ( jQuery.isArray( name ) ) {
				styles <span class="Statement">=</span> getStyles( elem );
				len <span class="Statement">=</span> name.length;

				<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
					map[ name[ i ] ] <span class="Statement">=</span> jQuery.css( elem, name[ i ], <span class="Constant">false</span>, styles );
				}

				<span class="Statement">return</span> map;
			}

			<span class="Statement">return</span> value <span class="Statement">!==</span> <span class="Type">undefined</span> <span class="Statement">?</span>
				jQuery.style( elem, name, value ) <span class="Statement">:</span>
				jQuery.css( elem, name );
		}, name, value, arguments.length <span class="Statement">&gt;</span> <span class="Constant">1</span> );
	},
	show: <span class="Type">function</span>() {
		<span class="Statement">return</span> showHide( <span class="Special">this</span>, <span class="Constant">true</span> );
	},
	hide: <span class="Type">function</span>() {
		<span class="Statement">return</span> showHide( <span class="Special">this</span> );
	},
	toggle: <span class="Type">function</span>( state ) {
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> state <span class="Statement">===</span> <span class="Constant">&quot;boolean&quot;</span> ) {
			<span class="Statement">return</span> state <span class="Statement">?</span> <span class="Special">this</span>.show() <span class="Statement">:</span> <span class="Special">this</span>.hide();
		}

		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			<span class="Statement">if</span> ( isHidden( <span class="Special">this</span> ) ) {
				jQuery( <span class="Special">this</span> ).show();
			} <span class="Statement">else</span> {
				jQuery( <span class="Special">this</span> ).hide();
			}
		});
	}
});


<span class="Type">function</span> <span class="Identifier">Tween</span>( elem, options, prop, end, easing ) {
	<span class="Statement">return</span> <span class="Statement">new</span> Tween.<span class="Special">prototype</span>.init( elem, options, prop, end, easing );
}
jQuery.Tween <span class="Statement">=</span> Tween;

Tween.<span class="Special">prototype</span> <span class="Statement">=</span> {
	constructor: Tween,
	init: <span class="Type">function</span>( elem, options, prop, end, easing, unit ) {
		<span class="Special">this</span>.elem <span class="Statement">=</span> elem;
		<span class="Special">this</span>.prop <span class="Statement">=</span> prop;
		<span class="Special">this</span>.easing <span class="Statement">=</span> easing <span class="Statement">||</span> <span class="Constant">&quot;swing&quot;</span>;
		<span class="Special">this</span>.options <span class="Statement">=</span> options;
		<span class="Special">this</span>.start <span class="Statement">=</span> <span class="Special">this</span>.now <span class="Statement">=</span> <span class="Special">this</span>.cur();
		<span class="Special">this</span>.end <span class="Statement">=</span> end;
		<span class="Special">this</span>.unit <span class="Statement">=</span> unit <span class="Statement">||</span> ( jQuery.cssNumber[ prop ] <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;px&quot;</span> );
	},
	cur: <span class="Type">function</span>() {
		<span class="Type">var</span> hooks <span class="Statement">=</span> Tween.propHooks[ <span class="Special">this</span>.prop ];

		<span class="Statement">return</span> hooks <span class="Statement">&amp;&amp;</span> hooks.get <span class="Statement">?</span>
			hooks.get( <span class="Special">this</span> ) <span class="Statement">:</span>
			Tween.propHooks._default.get( <span class="Special">this</span> );
	},
	run: <span class="Type">function</span>( percent ) {
		<span class="Type">var</span> eased,
			hooks <span class="Statement">=</span> Tween.propHooks[ <span class="Special">this</span>.prop ];

		<span class="Statement">if</span> ( <span class="Special">this</span>.options.duration ) {
			<span class="Special">this</span>.pos <span class="Statement">=</span> eased <span class="Statement">=</span> jQuery.easing[ <span class="Special">this</span>.easing ](
				percent, <span class="Special">this</span>.options.duration <span class="Statement">*</span> percent, <span class="Constant">0</span>, <span class="Constant">1</span>, <span class="Special">this</span>.options.duration
			);
		} <span class="Statement">else</span> {
			<span class="Special">this</span>.pos <span class="Statement">=</span> eased <span class="Statement">=</span> percent;
		}
		<span class="Special">this</span>.now <span class="Statement">=</span> ( <span class="Special">this</span>.end <span class="Statement">-</span> <span class="Special">this</span>.start ) <span class="Statement">*</span> eased <span class="Statement">+</span> <span class="Special">this</span>.start;

		<span class="Statement">if</span> ( <span class="Special">this</span>.options.step ) {
			<span class="Special">this</span>.options.step.call( <span class="Special">this</span>.elem, <span class="Special">this</span>.now, <span class="Special">this</span> );
		}

		<span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> hooks.set ) {
			hooks.set( <span class="Special">this</span> );
		} <span class="Statement">else</span> {
			Tween.propHooks._default.set( <span class="Special">this</span> );
		}
		<span class="Statement">return</span> <span class="Special">this</span>;
	}
};

Tween.<span class="Special">prototype</span>.init.<span class="Special">prototype</span> <span class="Statement">=</span> Tween.<span class="Special">prototype</span>;

Tween.propHooks <span class="Statement">=</span> {
	_default: {
		get: <span class="Type">function</span>( tween ) {
			<span class="Type">var</span> result;

			<span class="Statement">if</span> ( tween.elem[ tween.prop ] <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">&amp;&amp;</span>
				(<span class="Statement">!</span>tween.elem.style <span class="Statement">||</span> tween.elem.style[ tween.prop ] <span class="Statement">==</span> <span class="Type">null</span>) ) {
				<span class="Statement">return</span> tween.elem[ tween.prop ];
			}

<span class="Comment">			// passing an empty string as a 3rd parameter to .css will automatically</span>
<span class="Comment">			// attempt a parseFloat and fallback to a string if the parse fails</span>
<span class="Comment">			// so, simple values such as &quot;10px&quot; are parsed to Float.</span>
<span class="Comment">			// complex values such as &quot;rotate(1rad)&quot; are returned as is.</span>
			result <span class="Statement">=</span> jQuery.css( tween.elem, tween.prop, <span class="Constant">&quot;&quot;</span> );
<span class="Comment">			// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.</span>
			<span class="Statement">return</span> <span class="Statement">!</span>result <span class="Statement">||</span> result <span class="Statement">===</span> <span class="Constant">&quot;auto&quot;</span> <span class="Statement">?</span> <span class="Constant">0</span> <span class="Statement">:</span> result;
		},
		set: <span class="Type">function</span>( tween ) {
<span class="Comment">			// use step hook for back compat - use cssHook if its there - use .style if its</span>
<span class="Comment">			// available and use plain properties where available</span>
			<span class="Statement">if</span> ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} <span class="Statement">else</span> <span class="Statement">if</span> ( tween.elem.style <span class="Statement">&amp;&amp;</span> ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">||</span> jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now <span class="Statement">+</span> tween.unit );
			} <span class="Statement">else</span> {
				tween.elem[ tween.prop ] <span class="Statement">=</span> tween.now;
			}
		}
	}
};

<span class="Comment">// Support: IE9</span>
<span class="Comment">// Panic based approach to setting things on disconnected nodes</span>

Tween.propHooks.scrollTop <span class="Statement">=</span> Tween.propHooks.scrollLeft <span class="Statement">=</span> {
	set: <span class="Type">function</span>( tween ) {
		<span class="Statement">if</span> ( tween.elem.nodeType <span class="Statement">&amp;&amp;</span> tween.elem.parentNode ) {
			tween.elem[ tween.prop ] <span class="Statement">=</span> tween.now;
		}
	}
};

jQuery.easing <span class="Statement">=</span> {
	linear: <span class="Type">function</span>( p ) {
		<span class="Statement">return</span> p;
	},
	swing: <span class="Type">function</span>( p ) {
		<span class="Statement">return</span> <span class="Constant">0.5</span> <span class="Statement">-</span> <span class="Special">Math</span>.cos( p <span class="Statement">*</span> <span class="Special">Math</span>.PI ) <span class="Statement">/</span> <span class="Constant">2</span>;
	}
};

jQuery.fx <span class="Statement">=</span> Tween.<span class="Special">prototype</span>.init;

<span class="Comment">// Back Compat &lt;1.8 extension point</span>
jQuery.fx.step <span class="Statement">=</span> {};




<span class="Type">var</span>
	fxNow, timerId,
	rfxtypes <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">toggle</span><span class="Statement">|</span><span class="Constant">show</span><span class="Statement">|</span><span class="Constant">hide)</span><span class="Special">$</span><span class="Constant">/</span>,
	rfxnum <span class="Statement">=</span> <span class="Statement">new</span> <span class="Special">RegExp</span>( <span class="Constant">&quot;^(?:([+-])=|)(&quot;</span> <span class="Statement">+</span> pnum <span class="Statement">+</span> <span class="Constant">&quot;)([a-z%]*)$&quot;</span>, <span class="Constant">&quot;i&quot;</span> ),
	rrun <span class="Statement">=</span> <span class="Constant">/queueHooks</span><span class="Special">$</span><span class="Constant">/</span>,
	animationPrefilters <span class="Statement">=</span> [ defaultPrefilter ],
	tweeners <span class="Statement">=</span> {
		<span class="Constant">&quot;*&quot;</span>: [ <span class="Type">function</span>( prop, value ) {
			<span class="Type">var</span> tween <span class="Statement">=</span> <span class="Special">this</span>.createTween( prop, value ),
				target <span class="Statement">=</span> tween.cur(),
				parts <span class="Statement">=</span> rfxnum.exec( value ),
				unit <span class="Statement">=</span> parts <span class="Statement">&amp;&amp;</span> parts[ <span class="Constant">3</span> ] <span class="Statement">||</span> ( jQuery.cssNumber[ prop ] <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;px&quot;</span> ),

<span class="Comment">				// Starting value computation is required for potential unit mismatches</span>
				start <span class="Statement">=</span> ( jQuery.cssNumber[ prop ] <span class="Statement">||</span> unit <span class="Statement">!==</span> <span class="Constant">&quot;px&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">+</span>target ) <span class="Statement">&amp;&amp;</span>
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale <span class="Statement">=</span> <span class="Constant">1</span>,
				maxIterations <span class="Statement">=</span> <span class="Constant">20</span>;

			<span class="Statement">if</span> ( start <span class="Statement">&amp;&amp;</span> start[ <span class="Constant">3</span> ] <span class="Statement">!==</span> unit ) {
<span class="Comment">				// Trust units reported by jQuery.css</span>
				unit <span class="Statement">=</span> unit <span class="Statement">||</span> start[ <span class="Constant">3</span> ];

<span class="Comment">				// Make sure we update the tween properties later on</span>
				parts <span class="Statement">=</span> parts <span class="Statement">||</span> [];

<span class="Comment">				// Iteratively approximate from a nonzero starting point</span>
				start <span class="Statement">=</span> <span class="Statement">+</span>target <span class="Statement">||</span> <span class="Constant">1</span>;

				<span class="Statement">do</span> {
<span class="Comment">					// If previous iteration zeroed out, double until we get *something*</span>
<span class="Comment">					// Use a string for doubling factor so we don't accidentally see scale as unchanged below</span>
					scale <span class="Statement">=</span> scale <span class="Statement">||</span> <span class="Constant">&quot;.5&quot;</span>;

<span class="Comment">					// Adjust and apply</span>
					start <span class="Statement">=</span> start <span class="Statement">/</span> scale;
					jQuery.style( tween.elem, prop, start <span class="Statement">+</span> unit );

<span class="Comment">				// Update scale, tolerating zero or NaN from tween.cur()</span>
<span class="Comment">				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough</span>
				} <span class="Statement">while</span> ( scale <span class="Statement">!==</span> (scale <span class="Statement">=</span> tween.cur() <span class="Statement">/</span> target) <span class="Statement">&amp;&amp;</span> scale <span class="Statement">!==</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">--</span>maxIterations );
			}

<span class="Comment">			// Update tween properties</span>
			<span class="Statement">if</span> ( parts ) {
				start <span class="Statement">=</span> tween.start <span class="Statement">=</span> <span class="Statement">+</span>start <span class="Statement">||</span> <span class="Statement">+</span>target <span class="Statement">||</span> <span class="Constant">0</span>;
				tween.unit <span class="Statement">=</span> unit;
<span class="Comment">				// If a +=/-= token was provided, we're doing a relative animation</span>
				tween.end <span class="Statement">=</span> parts[ <span class="Constant">1</span> ] <span class="Statement">?</span>
					start <span class="Statement">+</span> ( parts[ <span class="Constant">1</span> ] <span class="Statement">+</span> <span class="Constant">1</span> ) <span class="Statement">*</span> parts[ <span class="Constant">2</span> ] <span class="Statement">:</span>
					<span class="Statement">+</span>parts[ <span class="Constant">2</span> ];
			}

			<span class="Statement">return</span> tween;
		} ]
	};

<span class="Comment">// Animations created synchronously will run synchronously</span>
<span class="Type">function</span> <span class="Identifier">createFxNow</span>() {
	setTimeout(<span class="Type">function</span>() {
		fxNow <span class="Statement">=</span> <span class="Type">undefined</span>;
	});
	<span class="Statement">return</span> ( fxNow <span class="Statement">=</span> jQuery.now() );
}

<span class="Comment">// Generate parameters to create a standard animation</span>
<span class="Type">function</span> <span class="Identifier">genFx</span>( type, includeWidth ) {
	<span class="Type">var</span> which,
		i <span class="Statement">=</span> <span class="Constant">0</span>,
		attrs <span class="Statement">=</span> { height: type };

<span class="Comment">	// if we include width, step value is 1 to do all cssExpand values,</span>
<span class="Comment">	// if we don't include width, step value is 2 to skip over Left and Right</span>
	includeWidth <span class="Statement">=</span> includeWidth <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Constant">0</span>;
	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> <span class="Constant">4</span> ; i <span class="Statement">+=</span> <span class="Constant">2</span> <span class="Statement">-</span> includeWidth ) {
		which <span class="Statement">=</span> cssExpand[ i ];
		attrs[ <span class="Constant">&quot;margin&quot;</span> <span class="Statement">+</span> which ] <span class="Statement">=</span> attrs[ <span class="Constant">&quot;padding&quot;</span> <span class="Statement">+</span> which ] <span class="Statement">=</span> type;
	}

	<span class="Statement">if</span> ( includeWidth ) {
		attrs.opacity <span class="Statement">=</span> attrs.width <span class="Statement">=</span> type;
	}

	<span class="Statement">return</span> attrs;
}

<span class="Type">function</span> <span class="Identifier">createTween</span>( value, prop, animation ) {
	<span class="Type">var</span> tween,
		collection <span class="Statement">=</span> ( tweeners[ prop ] <span class="Statement">||</span> [] ).concat( tweeners[ <span class="Constant">&quot;*&quot;</span> ] ),
		index <span class="Statement">=</span> <span class="Constant">0</span>,
		length <span class="Statement">=</span> collection.length;
	<span class="Statement">for</span> ( ; index <span class="Statement">&lt;</span> length; index<span class="Statement">++</span> ) {
		<span class="Statement">if</span> ( (tween <span class="Statement">=</span> collection[ index ].call( animation, prop, value )) ) {

<span class="Comment">			// we're done with this property</span>
			<span class="Statement">return</span> tween;
		}
	}
}

<span class="Type">function</span> <span class="Identifier">defaultPrefilter</span>( elem, props, opts ) {
	<span class="Comment">/* jshint validthis: true */</span>
	<span class="Type">var</span> prop, value, toggle, tween, hooks, oldfire, display,
		anim <span class="Statement">=</span> <span class="Special">this</span>,
		orig <span class="Statement">=</span> {},
		style <span class="Statement">=</span> elem.style,
		hidden <span class="Statement">=</span> elem.nodeType <span class="Statement">&amp;&amp;</span> isHidden( elem ),
		dataShow <span class="Statement">=</span> data_priv.get( elem, <span class="Constant">&quot;fxshow&quot;</span> );

<span class="Comment">	// handle queue: false promises</span>
	<span class="Statement">if</span> ( <span class="Statement">!</span>opts.queue ) {
		hooks <span class="Statement">=</span> jQuery._queueHooks( elem, <span class="Constant">&quot;fx&quot;</span> );
		<span class="Statement">if</span> ( hooks.unqueued <span class="Statement">==</span> <span class="Type">null</span> ) {
			hooks.unqueued <span class="Statement">=</span> <span class="Constant">0</span>;
			oldfire <span class="Statement">=</span> hooks.empty.fire;
			hooks.empty.fire <span class="Statement">=</span> <span class="Type">function</span>() {
				<span class="Statement">if</span> ( <span class="Statement">!</span>hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued<span class="Statement">++</span>;

		anim.always(<span class="Type">function</span>() {
<span class="Comment">			// doing this makes sure that the complete handler will be called</span>
<span class="Comment">			// before this completes</span>
			anim.always(<span class="Type">function</span>() {
				hooks.unqueued<span class="Statement">--</span>;
				<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.queue( elem, <span class="Constant">&quot;fx&quot;</span> ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

<span class="Comment">	// height/width overflow pass</span>
	<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> ( <span class="Constant">&quot;height&quot;</span> <span class="Statement">in</span> props <span class="Statement">||</span> <span class="Constant">&quot;width&quot;</span> <span class="Statement">in</span> props ) ) {
<span class="Comment">		// Make sure that nothing sneaks out</span>
<span class="Comment">		// Record all 3 overflow attributes because IE9-10 do not</span>
<span class="Comment">		// change the overflow attribute when overflowX and</span>
<span class="Comment">		// overflowY are set to the same value</span>
		opts.overflow <span class="Statement">=</span> [ style.overflow, style.overflowX, style.overflowY ];

<span class="Comment">		// Set display property to inline-block for height/width</span>
<span class="Comment">		// animations on inline elements that are having width/height animated</span>
		display <span class="Statement">=</span> jQuery.css( elem, <span class="Constant">&quot;display&quot;</span> );
<span class="Comment">		// Get default display if display is currently &quot;none&quot;</span>
		<span class="Statement">if</span> ( display <span class="Statement">===</span> <span class="Constant">&quot;none&quot;</span> ) {
			display <span class="Statement">=</span> defaultDisplay( elem.nodeName );
		}
		<span class="Statement">if</span> ( display <span class="Statement">===</span> <span class="Constant">&quot;inline&quot;</span> <span class="Statement">&amp;&amp;</span>
				jQuery.css( elem, <span class="Constant">&quot;float&quot;</span> ) <span class="Statement">===</span> <span class="Constant">&quot;none&quot;</span> ) {

			style.display <span class="Statement">=</span> <span class="Constant">&quot;inline-block&quot;</span>;
		}
	}

	<span class="Statement">if</span> ( opts.overflow ) {
		style.overflow <span class="Statement">=</span> <span class="Constant">&quot;hidden&quot;</span>;
		anim.always(<span class="Type">function</span>() {
			style.overflow <span class="Statement">=</span> opts.overflow[ <span class="Constant">0</span> ];
			style.overflowX <span class="Statement">=</span> opts.overflow[ <span class="Constant">1</span> ];
			style.overflowY <span class="Statement">=</span> opts.overflow[ <span class="Constant">2</span> ];
		});
	}

<span class="Comment">	// show/hide pass</span>
	<span class="Statement">for</span> ( prop <span class="Statement">in</span> props ) {
		value <span class="Statement">=</span> props[ prop ];
		<span class="Statement">if</span> ( rfxtypes.exec( value ) ) {
			<span class="Statement">delete</span> props[ prop ];
			toggle <span class="Statement">=</span> toggle <span class="Statement">||</span> value <span class="Statement">===</span> <span class="Constant">&quot;toggle&quot;</span>;
			<span class="Statement">if</span> ( value <span class="Statement">===</span> ( hidden <span class="Statement">?</span> <span class="Constant">&quot;hide&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;show&quot;</span> ) ) {

<span class="Comment">				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden</span>
				<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Constant">&quot;show&quot;</span> <span class="Statement">&amp;&amp;</span> dataShow <span class="Statement">&amp;&amp;</span> dataShow[ prop ] <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					hidden <span class="Statement">=</span> <span class="Constant">true</span>;
				} <span class="Statement">else</span> {
					<span class="Statement">continue</span>;
				}
			}
			orig[ prop ] <span class="Statement">=</span> dataShow <span class="Statement">&amp;&amp;</span> dataShow[ prop ] <span class="Statement">||</span> jQuery.style( elem, prop );
		}
	}

	<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.isEmptyObject( orig ) ) {
		<span class="Statement">if</span> ( dataShow ) {
			<span class="Statement">if</span> ( <span class="Constant">&quot;hidden&quot;</span> <span class="Statement">in</span> dataShow ) {
				hidden <span class="Statement">=</span> dataShow.hidden;
			}
		} <span class="Statement">else</span> {
			dataShow <span class="Statement">=</span> data_priv.access( elem, <span class="Constant">&quot;fxshow&quot;</span>, {} );
		}

<span class="Comment">		// store state if its toggle - enables .stop().toggle() to &quot;reverse&quot;</span>
		<span class="Statement">if</span> ( toggle ) {
			dataShow.hidden <span class="Statement">=</span> <span class="Statement">!</span>hidden;
		}
		<span class="Statement">if</span> ( hidden ) {
			jQuery( elem ).show();
		} <span class="Statement">else</span> {
			anim.done(<span class="Type">function</span>() {
				jQuery( elem ).hide();
			});
		}
		anim.done(<span class="Type">function</span>() {
			<span class="Type">var</span> prop;

			data_priv.remove( elem, <span class="Constant">&quot;fxshow&quot;</span> );
			<span class="Statement">for</span> ( prop <span class="Statement">in</span> orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		<span class="Statement">for</span> ( prop <span class="Statement">in</span> orig ) {
			tween <span class="Statement">=</span> createTween( hidden <span class="Statement">?</span> dataShow[ prop ] <span class="Statement">:</span> <span class="Constant">0</span>, prop, anim );

			<span class="Statement">if</span> ( <span class="Statement">!</span>( prop <span class="Statement">in</span> dataShow ) ) {
				dataShow[ prop ] <span class="Statement">=</span> tween.start;
				<span class="Statement">if</span> ( hidden ) {
					tween.end <span class="Statement">=</span> tween.start;
					tween.start <span class="Statement">=</span> prop <span class="Statement">===</span> <span class="Constant">&quot;width&quot;</span> <span class="Statement">||</span> prop <span class="Statement">===</span> <span class="Constant">&quot;height&quot;</span> <span class="Statement">?</span> <span class="Constant">1</span> <span class="Statement">:</span> <span class="Constant">0</span>;
				}
			}
		}
	}
}

<span class="Type">function</span> <span class="Identifier">propFilter</span>( props, specialEasing ) {
	<span class="Type">var</span> index, name, easing, value, hooks;

<span class="Comment">	// camelCase, specialEasing and expand cssHook pass</span>
	<span class="Statement">for</span> ( index <span class="Statement">in</span> props ) {
		name <span class="Statement">=</span> jQuery.camelCase( index );
		easing <span class="Statement">=</span> specialEasing[ name ];
		value <span class="Statement">=</span> props[ index ];
		<span class="Statement">if</span> ( jQuery.isArray( value ) ) {
			easing <span class="Statement">=</span> value[ <span class="Constant">1</span> ];
			value <span class="Statement">=</span> props[ index ] <span class="Statement">=</span> value[ <span class="Constant">0</span> ];
		}

		<span class="Statement">if</span> ( index <span class="Statement">!==</span> name ) {
			props[ name ] <span class="Statement">=</span> value;
			<span class="Statement">delete</span> props[ index ];
		}

		hooks <span class="Statement">=</span> jQuery.cssHooks[ name ];
		<span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;expand&quot;</span> <span class="Statement">in</span> hooks ) {
			value <span class="Statement">=</span> hooks.expand( value );
			<span class="Statement">delete</span> props[ name ];

<span class="Comment">			// not quite $.extend, this wont overwrite keys already present.</span>
<span class="Comment">			// also - reusing 'index' from above because we have the correct &quot;name&quot;</span>
			<span class="Statement">for</span> ( index <span class="Statement">in</span> value ) {
				<span class="Statement">if</span> ( <span class="Statement">!</span>( index <span class="Statement">in</span> props ) ) {
					props[ index ] <span class="Statement">=</span> value[ index ];
					specialEasing[ index ] <span class="Statement">=</span> easing;
				}
			}
		} <span class="Statement">else</span> {
			specialEasing[ name ] <span class="Statement">=</span> easing;
		}
	}
}

<span class="Type">function</span> <span class="Identifier">Animation</span>( elem, properties, options ) {
	<span class="Type">var</span> result,
		stopped,
		index <span class="Statement">=</span> <span class="Constant">0</span>,
		length <span class="Statement">=</span> animationPrefilters.length,
		deferred <span class="Statement">=</span> jQuery.Deferred().always( <span class="Type">function</span>() {
<span class="Comment">			// don't match elem in the :animated selector</span>
			<span class="Statement">delete</span> tick.elem;
		}),
		tick <span class="Statement">=</span> <span class="Type">function</span>() {
			<span class="Statement">if</span> ( stopped ) {
				<span class="Statement">return</span> <span class="Constant">false</span>;
			}
			<span class="Type">var</span> currentTime <span class="Statement">=</span> fxNow <span class="Statement">||</span> createFxNow(),
				remaining <span class="Statement">=</span> <span class="Special">Math</span>.max( <span class="Constant">0</span>, animation.startTime <span class="Statement">+</span> animation.duration <span class="Statement">-</span> currentTime ),
<span class="Comment">				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)</span>
				temp <span class="Statement">=</span> remaining <span class="Statement">/</span> animation.duration <span class="Statement">||</span> <span class="Constant">0</span>,
				percent <span class="Statement">=</span> <span class="Constant">1</span> <span class="Statement">-</span> temp,
				index <span class="Statement">=</span> <span class="Constant">0</span>,
				length <span class="Statement">=</span> animation.tweens.length;

			<span class="Statement">for</span> ( ; index <span class="Statement">&lt;</span> length ; index<span class="Statement">++</span> ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			<span class="Statement">if</span> ( percent <span class="Statement">&lt;</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> length ) {
				<span class="Statement">return</span> remaining;
			} <span class="Statement">else</span> {
				deferred.resolveWith( elem, [ animation ] );
				<span class="Statement">return</span> <span class="Constant">false</span>;
			}
		},
		animation <span class="Statement">=</span> deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( <span class="Constant">true</span>, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow <span class="Statement">||</span> createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: <span class="Type">function</span>( prop, end ) {
				<span class="Type">var</span> tween <span class="Statement">=</span> jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] <span class="Statement">||</span> animation.opts.easing );
				animation.tweens.push( tween );
				<span class="Statement">return</span> tween;
			},
			stop: <span class="Type">function</span>( gotoEnd ) {
				<span class="Type">var</span> index <span class="Statement">=</span> <span class="Constant">0</span>,
<span class="Comment">					// if we are going to the end, we want to run all the tweens</span>
<span class="Comment">					// otherwise we skip this part</span>
					length <span class="Statement">=</span> gotoEnd <span class="Statement">?</span> animation.tweens.length <span class="Statement">:</span> <span class="Constant">0</span>;
				<span class="Statement">if</span> ( stopped ) {
					<span class="Statement">return</span> <span class="Special">this</span>;
				}
				stopped <span class="Statement">=</span> <span class="Constant">true</span>;
				<span class="Statement">for</span> ( ; index <span class="Statement">&lt;</span> length ; index<span class="Statement">++</span> ) {
					animation.tweens[ index ].run( <span class="Constant">1</span> );
				}

<span class="Comment">				// resolve when we played the last frame</span>
<span class="Comment">				// otherwise, reject</span>
				<span class="Statement">if</span> ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} <span class="Statement">else</span> {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				<span class="Statement">return</span> <span class="Special">this</span>;
			}
		}),
		props <span class="Statement">=</span> animation.props;

	propFilter( props, animation.opts.specialEasing );

	<span class="Statement">for</span> ( ; index <span class="Statement">&lt;</span> length ; index<span class="Statement">++</span> ) {
		result <span class="Statement">=</span> animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		<span class="Statement">if</span> ( result ) {
			<span class="Statement">return</span> result;
		}
	}

	jQuery.map( props, createTween, animation );

	<span class="Statement">if</span> ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

<span class="Comment">	// attach callbacks from options</span>
	<span class="Statement">return</span> animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation <span class="Statement">=</span> jQuery.extend( Animation, {

	tweener: <span class="Type">function</span>( props, callback ) {
		<span class="Statement">if</span> ( jQuery.isFunction( props ) ) {
			callback <span class="Statement">=</span> props;
			props <span class="Statement">=</span> [ <span class="Constant">&quot;*&quot;</span> ];
		} <span class="Statement">else</span> {
			props <span class="Statement">=</span> props.split(<span class="Constant">&quot; &quot;</span>);
		}

		<span class="Type">var</span> prop,
			index <span class="Statement">=</span> <span class="Constant">0</span>,
			length <span class="Statement">=</span> props.length;

		<span class="Statement">for</span> ( ; index <span class="Statement">&lt;</span> length ; index<span class="Statement">++</span> ) {
			prop <span class="Statement">=</span> props[ index ];
			tweeners[ prop ] <span class="Statement">=</span> tweeners[ prop ] <span class="Statement">||</span> [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: <span class="Type">function</span>( callback, prepend ) {
		<span class="Statement">if</span> ( prepend ) {
			animationPrefilters.unshift( callback );
		} <span class="Statement">else</span> {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed <span class="Statement">=</span> <span class="Type">function</span>( speed, easing, fn ) {
	<span class="Type">var</span> opt <span class="Statement">=</span> speed <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> speed <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">?</span> jQuery.extend( {}, speed ) <span class="Statement">:</span> {
		complete: fn <span class="Statement">||</span> <span class="Statement">!</span>fn <span class="Statement">&amp;&amp;</span> easing <span class="Statement">||</span>
			jQuery.isFunction( speed ) <span class="Statement">&amp;&amp;</span> speed,
		duration: speed,
		easing: fn <span class="Statement">&amp;&amp;</span> easing <span class="Statement">||</span> easing <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.isFunction( easing ) <span class="Statement">&amp;&amp;</span> easing
	};

	opt.duration <span class="Statement">=</span> jQuery.fx.off <span class="Statement">?</span> <span class="Constant">0</span> <span class="Statement">:</span> <span class="Statement">typeof</span> opt.duration <span class="Statement">===</span> <span class="Constant">&quot;number&quot;</span> <span class="Statement">?</span> opt.duration <span class="Statement">:</span>
		opt.duration <span class="Statement">in</span> jQuery.fx.speeds <span class="Statement">?</span> jQuery.fx.speeds[ opt.duration ] <span class="Statement">:</span> jQuery.fx.speeds._default;

<span class="Comment">	// normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;</span>
	<span class="Statement">if</span> ( opt.queue <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">||</span> opt.queue <span class="Statement">===</span> <span class="Constant">true</span> ) {
		opt.queue <span class="Statement">=</span> <span class="Constant">&quot;fx&quot;</span>;
	}

<span class="Comment">	// Queueing</span>
	opt.old <span class="Statement">=</span> opt.complete;

	opt.complete <span class="Statement">=</span> <span class="Type">function</span>() {
		<span class="Statement">if</span> ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( <span class="Special">this</span> );
		}

		<span class="Statement">if</span> ( opt.queue ) {
			jQuery.dequeue( <span class="Special">this</span>, opt.queue );
		}
	};

	<span class="Statement">return</span> opt;
};

jQuery.fn.extend({
	fadeTo: <span class="Type">function</span>( speed, to, easing, callback ) {

<span class="Comment">		// show any hidden elements after setting opacity to 0</span>
		<span class="Statement">return</span> <span class="Special">this</span>.filter( isHidden ).css( <span class="Constant">&quot;opacity&quot;</span>, <span class="Constant">0</span> ).show()

<span class="Comment">			// animate to the value specified</span>
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: <span class="Type">function</span>( prop, speed, easing, callback ) {
		<span class="Type">var</span> empty <span class="Statement">=</span> jQuery.isEmptyObject( prop ),
			optall <span class="Statement">=</span> jQuery.speed( speed, easing, callback ),
			doAnimation <span class="Statement">=</span> <span class="Type">function</span>() {
<span class="Comment">				// Operate on a copy of prop so per-property easing won't be lost</span>
				<span class="Type">var</span> anim <span class="Statement">=</span> Animation( <span class="Special">this</span>, jQuery.extend( {}, prop ), optall );

<span class="Comment">				// Empty animations, or finishing resolves immediately</span>
				<span class="Statement">if</span> ( empty <span class="Statement">||</span> data_priv.get( <span class="Special">this</span>, <span class="Constant">&quot;finish&quot;</span> ) ) {
					anim.stop( <span class="Constant">true</span> );
				}
			};
			doAnimation.finish <span class="Statement">=</span> doAnimation;

		<span class="Statement">return</span> empty <span class="Statement">||</span> optall.queue <span class="Statement">===</span> <span class="Constant">false</span> <span class="Statement">?</span>
			<span class="Special">this</span>.each( doAnimation ) <span class="Statement">:</span>
			<span class="Special">this</span>.queue( optall.queue, doAnimation );
	},
	stop: <span class="Type">function</span>( type, clearQueue, gotoEnd ) {
		<span class="Type">var</span> stopQueue <span class="Statement">=</span> <span class="Type">function</span>( hooks ) {
			<span class="Type">var</span> stop <span class="Statement">=</span> hooks.stop;
			<span class="Statement">delete</span> hooks.stop;
			stop( gotoEnd );
		};

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> type <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
			gotoEnd <span class="Statement">=</span> clearQueue;
			clearQueue <span class="Statement">=</span> type;
			type <span class="Statement">=</span> <span class="Type">undefined</span>;
		}
		<span class="Statement">if</span> ( clearQueue <span class="Statement">&amp;&amp;</span> type <span class="Statement">!==</span> <span class="Constant">false</span> ) {
			<span class="Special">this</span>.queue( type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span>, [] );
		}

		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			<span class="Type">var</span> dequeue <span class="Statement">=</span> <span class="Constant">true</span>,
				index <span class="Statement">=</span> type <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">&amp;&amp;</span> type <span class="Statement">+</span> <span class="Constant">&quot;queueHooks&quot;</span>,
				timers <span class="Statement">=</span> jQuery.timers,
				data <span class="Statement">=</span> data_priv.get( <span class="Special">this</span> );

			<span class="Statement">if</span> ( index ) {
				<span class="Statement">if</span> ( data[ index ] <span class="Statement">&amp;&amp;</span> data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} <span class="Statement">else</span> {
				<span class="Statement">for</span> ( index <span class="Statement">in</span> data ) {
					<span class="Statement">if</span> ( data[ index ] <span class="Statement">&amp;&amp;</span> data[ index ].stop <span class="Statement">&amp;&amp;</span> rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			<span class="Statement">for</span> ( index <span class="Statement">=</span> timers.length; index<span class="Statement">--</span>; ) {
				<span class="Statement">if</span> ( timers[ index ].elem <span class="Statement">===</span> <span class="Special">this</span> <span class="Statement">&amp;&amp;</span> (type <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">||</span> timers[ index ].queue <span class="Statement">===</span> type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue <span class="Statement">=</span> <span class="Constant">false</span>;
					timers.splice( index, <span class="Constant">1</span> );
				}
			}

<span class="Comment">			// start the next in the queue if the last step wasn't forced</span>
<span class="Comment">			// timers currently will call their complete callbacks, which will dequeue</span>
<span class="Comment">			// but only if they were gotoEnd</span>
			<span class="Statement">if</span> ( dequeue <span class="Statement">||</span> <span class="Statement">!</span>gotoEnd ) {
				jQuery.dequeue( <span class="Special">this</span>, type );
			}
		});
	},
	finish: <span class="Type">function</span>( type ) {
		<span class="Statement">if</span> ( type <span class="Statement">!==</span> <span class="Constant">false</span> ) {
			type <span class="Statement">=</span> type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span>;
		}
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			<span class="Type">var</span> index,
				data <span class="Statement">=</span> data_priv.get( <span class="Special">this</span> ),
				queue <span class="Statement">=</span> data[ type <span class="Statement">+</span> <span class="Constant">&quot;queue&quot;</span> ],
				hooks <span class="Statement">=</span> data[ type <span class="Statement">+</span> <span class="Constant">&quot;queueHooks&quot;</span> ],
				timers <span class="Statement">=</span> jQuery.timers,
				length <span class="Statement">=</span> queue <span class="Statement">?</span> queue.length <span class="Statement">:</span> <span class="Constant">0</span>;

<span class="Comment">			// enable finishing flag on private data</span>
			data.finish <span class="Statement">=</span> <span class="Constant">true</span>;

<span class="Comment">			// empty the queue first</span>
			jQuery.queue( <span class="Special">this</span>, type, [] );

			<span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> hooks.stop ) {
				hooks.stop.call( <span class="Special">this</span>, <span class="Constant">true</span> );
			}

<span class="Comment">			// look for any active animations, and finish them</span>
			<span class="Statement">for</span> ( index <span class="Statement">=</span> timers.length; index<span class="Statement">--</span>; ) {
				<span class="Statement">if</span> ( timers[ index ].elem <span class="Statement">===</span> <span class="Special">this</span> <span class="Statement">&amp;&amp;</span> timers[ index ].queue <span class="Statement">===</span> type ) {
					timers[ index ].anim.stop( <span class="Constant">true</span> );
					timers.splice( index, <span class="Constant">1</span> );
				}
			}

<span class="Comment">			// look for any animations in the old queue and finish them</span>
			<span class="Statement">for</span> ( index <span class="Statement">=</span> <span class="Constant">0</span>; index <span class="Statement">&lt;</span> length; index<span class="Statement">++</span> ) {
				<span class="Statement">if</span> ( queue[ index ] <span class="Statement">&amp;&amp;</span> queue[ index ].finish ) {
					queue[ index ].finish.call( <span class="Special">this</span> );
				}
			}

<span class="Comment">			// turn off finishing flag</span>
			<span class="Statement">delete</span> data.finish;
		});
	}
});

jQuery.each([ <span class="Constant">&quot;toggle&quot;</span>, <span class="Constant">&quot;show&quot;</span>, <span class="Constant">&quot;hide&quot;</span> ], <span class="Type">function</span>( i, name ) {
	<span class="Type">var</span> cssFn <span class="Statement">=</span> jQuery.fn[ name ];
	jQuery.fn[ name ] <span class="Statement">=</span> <span class="Type">function</span>( speed, easing, callback ) {
		<span class="Statement">return</span> speed <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">||</span> <span class="Statement">typeof</span> speed <span class="Statement">===</span> <span class="Constant">&quot;boolean&quot;</span> <span class="Statement">?</span>
			cssFn.apply( <span class="Special">this</span>, arguments ) <span class="Statement">:</span>
			<span class="Special">this</span>.animate( genFx( name, <span class="Constant">true</span> ), speed, easing, callback );
	};
});

<span class="Comment">// Generate shortcuts for custom animations</span>
jQuery.each({
	slideDown: genFx(<span class="Constant">&quot;show&quot;</span>),
	slideUp: genFx(<span class="Constant">&quot;hide&quot;</span>),
	slideToggle: genFx(<span class="Constant">&quot;toggle&quot;</span>),
	fadeIn: { opacity: <span class="Constant">&quot;show&quot;</span> },
	fadeOut: { opacity: <span class="Constant">&quot;hide&quot;</span> },
	fadeToggle: { opacity: <span class="Constant">&quot;toggle&quot;</span> }
}, <span class="Type">function</span>( name, props ) {
	jQuery.fn[ name ] <span class="Statement">=</span> <span class="Type">function</span>( speed, easing, callback ) {
		<span class="Statement">return</span> <span class="Special">this</span>.animate( props, speed, easing, callback );
	};
});

jQuery.timers <span class="Statement">=</span> [];
jQuery.fx.tick <span class="Statement">=</span> <span class="Type">function</span>() {
	<span class="Type">var</span> timer,
		i <span class="Statement">=</span> <span class="Constant">0</span>,
		timers <span class="Statement">=</span> jQuery.timers;

	fxNow <span class="Statement">=</span> jQuery.now();

	<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> timers.length; i<span class="Statement">++</span> ) {
		timer <span class="Statement">=</span> timers[ i ];
<span class="Comment">		// Checks the timer has not already been removed</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>timer() <span class="Statement">&amp;&amp;</span> timers[ i ] <span class="Statement">===</span> timer ) {
			timers.splice( i<span class="Statement">--</span>, <span class="Constant">1</span> );
		}
	}

	<span class="Statement">if</span> ( <span class="Statement">!</span>timers.length ) {
		jQuery.fx.stop();
	}
	fxNow <span class="Statement">=</span> <span class="Type">undefined</span>;
};

jQuery.fx.timer <span class="Statement">=</span> <span class="Type">function</span>( timer ) {
	jQuery.timers.push( timer );
	<span class="Statement">if</span> ( timer() ) {
		jQuery.fx.start();
	} <span class="Statement">else</span> {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval <span class="Statement">=</span> <span class="Constant">13</span>;

jQuery.fx.start <span class="Statement">=</span> <span class="Type">function</span>() {
	<span class="Statement">if</span> ( <span class="Statement">!</span>timerId ) {
		timerId <span class="Statement">=</span> setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop <span class="Statement">=</span> <span class="Type">function</span>() {
	clearInterval( timerId );
	timerId <span class="Statement">=</span> <span class="Type">null</span>;
};

jQuery.fx.speeds <span class="Statement">=</span> {
	slow: <span class="Constant">600</span>,
	fast: <span class="Constant">200</span>,
<span class="Comment">	// Default speed</span>
	_default: <span class="Constant">400</span>
};


<span class="Comment">// Based off of the plugin by Clint Helfers, with permission.</span>
<span class="Comment">// <a href="http://blindsignals.com/index.php/2009/07/jquery-delay/">http://blindsignals.com/index.php/2009/07/jquery-delay/</a></span>
jQuery.fn.delay <span class="Statement">=</span> <span class="Type">function</span>( time, type ) {
	time <span class="Statement">=</span> jQuery.fx <span class="Statement">?</span> jQuery.fx.speeds[ time ] <span class="Statement">||</span> time <span class="Statement">:</span> time;
	type <span class="Statement">=</span> type <span class="Statement">||</span> <span class="Constant">&quot;fx&quot;</span>;

	<span class="Statement">return</span> <span class="Special">this</span>.queue( type, <span class="Type">function</span>( next, hooks ) {
		<span class="Type">var</span> timeout <span class="Statement">=</span> setTimeout( next, time );
		hooks.stop <span class="Statement">=</span> <span class="Type">function</span>() {
			clearTimeout( timeout );
		};
	});
};


(<span class="Type">function</span>() {
	<span class="Type">var</span> input <span class="Statement">=</span> <span class="Special">document</span>.createElement( <span class="Constant">&quot;input&quot;</span> ),
		select <span class="Statement">=</span> <span class="Special">document</span>.createElement( <span class="Constant">&quot;select&quot;</span> ),
		opt <span class="Statement">=</span> select.appendChild( <span class="Special">document</span>.createElement( <span class="Constant">&quot;option&quot;</span> ) );

	input.type <span class="Statement">=</span> <span class="Constant">&quot;checkbox&quot;</span>;

<span class="Comment">	// Support: iOS 5.1, Android 4.x, Android 2.3</span>
<span class="Comment">	// Check the default checkbox/radio value (&quot;&quot; on old WebKit; &quot;on&quot; elsewhere)</span>
	support.checkOn <span class="Statement">=</span> input.value <span class="Statement">!==</span> <span class="Constant">&quot;&quot;</span>;

<span class="Comment">	// Must access the parent to make an option select properly</span>
<span class="Comment">	// Support: IE9, IE10</span>
	support.optSelected <span class="Statement">=</span> opt.selected;

<span class="Comment">	// Make sure that the options inside disabled selects aren't marked as disabled</span>
<span class="Comment">	// (WebKit marks them as disabled)</span>
	select.disabled <span class="Statement">=</span> <span class="Constant">true</span>;
	support.optDisabled <span class="Statement">=</span> <span class="Statement">!</span>opt.disabled;

<span class="Comment">	// Check if an input maintains its value after becoming a radio</span>
<span class="Comment">	// Support: IE9, IE10</span>
	input <span class="Statement">=</span> <span class="Special">document</span>.createElement( <span class="Constant">&quot;input&quot;</span> );
	input.value <span class="Statement">=</span> <span class="Constant">&quot;t&quot;</span>;
	input.type <span class="Statement">=</span> <span class="Constant">&quot;radio&quot;</span>;
	support.radioValue <span class="Statement">=</span> input.value <span class="Statement">===</span> <span class="Constant">&quot;t&quot;</span>;
})();


<span class="Type">var</span> nodeHook, boolHook,
	attrHandle <span class="Statement">=</span> jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: <span class="Type">function</span>( name, value ) {
		<span class="Statement">return</span> access( <span class="Special">this</span>, jQuery.attr, name, value, arguments.length <span class="Statement">&gt;</span> <span class="Constant">1</span> );
	},

	removeAttr: <span class="Type">function</span>( name ) {
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			jQuery.removeAttr( <span class="Special">this</span>, name );
		});
	}
});

jQuery.extend({
	attr: <span class="Type">function</span>( elem, name, value ) {
		<span class="Type">var</span> hooks, ret,
			nType <span class="Statement">=</span> elem.nodeType;

<span class="Comment">		// don't get/set attributes on text, comment and attribute nodes</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>elem <span class="Statement">||</span> nType <span class="Statement">===</span> <span class="Constant">3</span> <span class="Statement">||</span> nType <span class="Statement">===</span> <span class="Constant">8</span> <span class="Statement">||</span> nType <span class="Statement">===</span> <span class="Constant">2</span> ) {
			<span class="Statement">return</span>;
		}

<span class="Comment">		// Fallback to prop when attributes are not supported</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> elem.getAttribute <span class="Statement">===</span> strundefined ) {
			<span class="Statement">return</span> jQuery.prop( elem, name, value );
		}

<span class="Comment">		// All attributes are lowercase</span>
<span class="Comment">		// Grab necessary hook if one is defined</span>
		<span class="Statement">if</span> ( nType <span class="Statement">!==</span> <span class="Constant">1</span> <span class="Statement">||</span> <span class="Statement">!</span>jQuery.isXMLDoc( elem ) ) {
			name <span class="Statement">=</span> name.toLowerCase();
			hooks <span class="Statement">=</span> jQuery.attrHooks[ name ] <span class="Statement">||</span>
				( jQuery.expr.match.bool.test( name ) <span class="Statement">?</span> boolHook <span class="Statement">:</span> nodeHook );
		}

		<span class="Statement">if</span> ( value <span class="Statement">!==</span> <span class="Type">undefined</span> ) {

			<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Type">null</span> ) {
				jQuery.removeAttr( elem, name );

			} <span class="Statement">else</span> <span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;set&quot;</span> <span class="Statement">in</span> hooks <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> hooks.set( elem, value, name )) <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
				<span class="Statement">return</span> ret;

			} <span class="Statement">else</span> {
				elem.setAttribute( name, value <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span> );
				<span class="Statement">return</span> value;
			}

		} <span class="Statement">else</span> <span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;get&quot;</span> <span class="Statement">in</span> hooks <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> hooks.get( elem, name )) <span class="Statement">!==</span> <span class="Type">null</span> ) {
			<span class="Statement">return</span> ret;

		} <span class="Statement">else</span> {
			ret <span class="Statement">=</span> jQuery.find.attr( elem, name );

<span class="Comment">			// Non-existent attributes return null, we normalize to undefined</span>
			<span class="Statement">return</span> ret <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span>
				<span class="Type">undefined</span> <span class="Statement">:</span>
				ret;
		}
	},

	removeAttr: <span class="Type">function</span>( elem, value ) {
		<span class="Type">var</span> name, propName,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			attrNames <span class="Statement">=</span> value <span class="Statement">&amp;&amp;</span> value.match( rnotwhite );

		<span class="Statement">if</span> ( attrNames <span class="Statement">&amp;&amp;</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> ) {
			<span class="Statement">while</span> ( (name <span class="Statement">=</span> attrNames[i<span class="Statement">++</span>]) ) {
				propName <span class="Statement">=</span> jQuery.propFix[ name ] <span class="Statement">||</span> name;

<span class="Comment">				// Boolean attributes get special treatment (#10870)</span>
				<span class="Statement">if</span> ( jQuery.expr.match.bool.test( name ) ) {
<span class="Comment">					// Set corresponding property to false</span>
					elem[ propName ] <span class="Statement">=</span> <span class="Constant">false</span>;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: <span class="Type">function</span>( elem, value ) {
				<span class="Statement">if</span> ( <span class="Statement">!</span>support.radioValue <span class="Statement">&amp;&amp;</span> value <span class="Statement">===</span> <span class="Constant">&quot;radio&quot;</span> <span class="Statement">&amp;&amp;</span>
					jQuery.nodeName( elem, <span class="Constant">&quot;input&quot;</span> ) ) {
<span class="Comment">					// Setting the type on a radio button after the value resets the value in IE6-9</span>
<span class="Comment">					// Reset value to default in case type is set after value during creation</span>
					<span class="Type">var</span> val <span class="Statement">=</span> elem.value;
					elem.setAttribute( <span class="Constant">&quot;type&quot;</span>, value );
					<span class="Statement">if</span> ( val ) {
						elem.value <span class="Statement">=</span> val;
					}
					<span class="Statement">return</span> value;
				}
			}
		}
	}
});

<span class="Comment">// Hooks for boolean attributes</span>
boolHook <span class="Statement">=</span> {
	set: <span class="Type">function</span>( elem, value, name ) {
		<span class="Statement">if</span> ( value <span class="Statement">===</span> <span class="Constant">false</span> ) {
<span class="Comment">			// Remove boolean attributes when set to false</span>
			jQuery.removeAttr( elem, name );
		} <span class="Statement">else</span> {
			elem.setAttribute( name, name );
		}
		<span class="Statement">return</span> name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( <span class="Constant">/</span><span class="Special">\w</span><span class="Special">+</span><span class="Constant">/g</span> ), <span class="Type">function</span>( i, name ) {
	<span class="Type">var</span> getter <span class="Statement">=</span> attrHandle[ name ] <span class="Statement">||</span> jQuery.find.attr;

	attrHandle[ name ] <span class="Statement">=</span> <span class="Type">function</span>( elem, name, isXML ) {
		<span class="Type">var</span> ret, handle;
		<span class="Statement">if</span> ( <span class="Statement">!</span>isXML ) {
<span class="Comment">			// Avoid an infinite loop by temporarily removing this function from the getter</span>
			handle <span class="Statement">=</span> attrHandle[ name ];
			attrHandle[ name ] <span class="Statement">=</span> ret;
			ret <span class="Statement">=</span> getter( elem, name, isXML ) <span class="Statement">!=</span> <span class="Type">null</span> <span class="Statement">?</span>
				name.toLowerCase() <span class="Statement">:</span>
				<span class="Type">null</span>;
			attrHandle[ name ] <span class="Statement">=</span> handle;
		}
		<span class="Statement">return</span> ret;
	};
});




<span class="Type">var</span> rfocusable <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">input</span><span class="Statement">|</span><span class="Constant">select</span><span class="Statement">|</span><span class="Constant">textarea</span><span class="Statement">|</span><span class="Constant">button)</span><span class="Special">$</span><span class="Constant">/i</span>;

jQuery.fn.extend({
	prop: <span class="Type">function</span>( name, value ) {
		<span class="Statement">return</span> access( <span class="Special">this</span>, jQuery.prop, name, value, arguments.length <span class="Statement">&gt;</span> <span class="Constant">1</span> );
	},

	removeProp: <span class="Type">function</span>( name ) {
		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			<span class="Statement">delete</span> <span class="Special">this</span>[ jQuery.propFix[ name ] <span class="Statement">||</span> name ];
		});
	}
});

jQuery.extend({
	propFix: {
		<span class="Constant">&quot;for&quot;</span>: <span class="Constant">&quot;htmlFor&quot;</span>,
		<span class="Constant">&quot;class&quot;</span>: <span class="Constant">&quot;className&quot;</span>
	},

	prop: <span class="Type">function</span>( elem, name, value ) {
		<span class="Type">var</span> ret, hooks, notxml,
			nType <span class="Statement">=</span> elem.nodeType;

<span class="Comment">		// don't get/set properties on text, comment and attribute nodes</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>elem <span class="Statement">||</span> nType <span class="Statement">===</span> <span class="Constant">3</span> <span class="Statement">||</span> nType <span class="Statement">===</span> <span class="Constant">8</span> <span class="Statement">||</span> nType <span class="Statement">===</span> <span class="Constant">2</span> ) {
			<span class="Statement">return</span>;
		}

		notxml <span class="Statement">=</span> nType <span class="Statement">!==</span> <span class="Constant">1</span> <span class="Statement">||</span> <span class="Statement">!</span>jQuery.isXMLDoc( elem );

		<span class="Statement">if</span> ( notxml ) {
<span class="Comment">			// Fix name and attach hooks</span>
			name <span class="Statement">=</span> jQuery.propFix[ name ] <span class="Statement">||</span> name;
			hooks <span class="Statement">=</span> jQuery.propHooks[ name ];
		}

		<span class="Statement">if</span> ( value <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
			<span class="Statement">return</span> hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;set&quot;</span> <span class="Statement">in</span> hooks <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> hooks.set( elem, value, name )) <span class="Statement">!==</span> <span class="Type">undefined</span> <span class="Statement">?</span>
				ret <span class="Statement">:</span>
				( elem[ name ] <span class="Statement">=</span> value );

		} <span class="Statement">else</span> {
			<span class="Statement">return</span> hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;get&quot;</span> <span class="Statement">in</span> hooks <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> hooks.get( elem, name )) <span class="Statement">!==</span> <span class="Type">null</span> <span class="Statement">?</span>
				ret <span class="Statement">:</span>
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: <span class="Type">function</span>( elem ) {
				<span class="Statement">return</span> elem.hasAttribute( <span class="Constant">&quot;tabindex&quot;</span> ) <span class="Statement">||</span> rfocusable.test( elem.nodeName ) <span class="Statement">||</span> elem.href <span class="Statement">?</span>
					elem.tabIndex <span class="Statement">:</span>
					<span class="Statement">-</span><span class="Constant">1</span>;
			}
		}
	}
});

<span class="Comment">// Support: IE9+</span>
<span class="Comment">// Selectedness for an option in an optgroup can be inaccurate</span>
<span class="Statement">if</span> ( <span class="Statement">!</span>support.optSelected ) {
	jQuery.propHooks.selected <span class="Statement">=</span> {
		get: <span class="Type">function</span>( elem ) {
			<span class="Type">var</span> parent <span class="Statement">=</span> elem.parentNode;
			<span class="Statement">if</span> ( parent <span class="Statement">&amp;&amp;</span> parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			<span class="Statement">return</span> <span class="Type">null</span>;
		}
	};
}

jQuery.each([
	<span class="Constant">&quot;tabIndex&quot;</span>,
	<span class="Constant">&quot;readOnly&quot;</span>,
	<span class="Constant">&quot;maxLength&quot;</span>,
	<span class="Constant">&quot;cellSpacing&quot;</span>,
	<span class="Constant">&quot;cellPadding&quot;</span>,
	<span class="Constant">&quot;rowSpan&quot;</span>,
	<span class="Constant">&quot;colSpan&quot;</span>,
	<span class="Constant">&quot;useMap&quot;</span>,
	<span class="Constant">&quot;frameBorder&quot;</span>,
	<span class="Constant">&quot;contentEditable&quot;</span>
], <span class="Type">function</span>() {
	jQuery.propFix[ <span class="Special">this</span>.toLowerCase() ] <span class="Statement">=</span> <span class="Special">this</span>;
});




<span class="Type">var</span> rclass <span class="Statement">=</span> <span class="Constant">/</span><span class="Constant">[\t\r\n\f]</span><span class="Constant">/g</span>;

jQuery.fn.extend({
	addClass: <span class="Type">function</span>( value ) {
		<span class="Type">var</span> classes, elem, cur, clazz, j, finalValue,
			proceed <span class="Statement">=</span> <span class="Statement">typeof</span> value <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> value,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			len <span class="Statement">=</span> <span class="Special">this</span>.length;

		<span class="Statement">if</span> ( jQuery.isFunction( value ) ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( j ) {
				jQuery( <span class="Special">this</span> ).addClass( value.call( <span class="Special">this</span>, j, <span class="Special">this</span>.className ) );
			});
		}

		<span class="Statement">if</span> ( proceed ) {
<span class="Comment">			// The disjunction here is for better compressibility (see removeClass)</span>
			classes <span class="Statement">=</span> ( value <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).match( rnotwhite ) <span class="Statement">||</span> [];

			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
				elem <span class="Statement">=</span> <span class="Special">this</span>[ i ];
				cur <span class="Statement">=</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> ( elem.className <span class="Statement">?</span>
					( <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> elem.className <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ).replace( rclass, <span class="Constant">&quot; &quot;</span> ) <span class="Statement">:</span>
					<span class="Constant">&quot; &quot;</span>
				);

				<span class="Statement">if</span> ( cur ) {
					j <span class="Statement">=</span> <span class="Constant">0</span>;
					<span class="Statement">while</span> ( (clazz <span class="Statement">=</span> classes[j<span class="Statement">++</span>]) ) {
						<span class="Statement">if</span> ( cur.indexOf( <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> clazz <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ) <span class="Statement">&lt;</span> <span class="Constant">0</span> ) {
							cur <span class="Statement">+=</span> clazz <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span>;
						}
					}

<span class="Comment">					// only assign if different to avoid unneeded rendering.</span>
					finalValue <span class="Statement">=</span> jQuery.trim( cur );
					<span class="Statement">if</span> ( elem.className <span class="Statement">!==</span> finalValue ) {
						elem.className <span class="Statement">=</span> finalValue;
					}
				}
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>;
	},

	removeClass: <span class="Type">function</span>( value ) {
		<span class="Type">var</span> classes, elem, cur, clazz, j, finalValue,
			proceed <span class="Statement">=</span> <span class="Special">arguments</span>.length <span class="Statement">===</span> <span class="Constant">0</span> <span class="Statement">||</span> <span class="Statement">typeof</span> value <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> value,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			len <span class="Statement">=</span> <span class="Special">this</span>.length;

		<span class="Statement">if</span> ( jQuery.isFunction( value ) ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( j ) {
				jQuery( <span class="Special">this</span> ).removeClass( value.call( <span class="Special">this</span>, j, <span class="Special">this</span>.className ) );
			});
		}
		<span class="Statement">if</span> ( proceed ) {
			classes <span class="Statement">=</span> ( value <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).match( rnotwhite ) <span class="Statement">||</span> [];

			<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> len; i<span class="Statement">++</span> ) {
				elem <span class="Statement">=</span> <span class="Special">this</span>[ i ];
<span class="Comment">				// This expression is here for better compressibility (see addClass)</span>
				cur <span class="Statement">=</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> ( elem.className <span class="Statement">?</span>
					( <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> elem.className <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ).replace( rclass, <span class="Constant">&quot; &quot;</span> ) <span class="Statement">:</span>
					<span class="Constant">&quot;&quot;</span>
				);

				<span class="Statement">if</span> ( cur ) {
					j <span class="Statement">=</span> <span class="Constant">0</span>;
					<span class="Statement">while</span> ( (clazz <span class="Statement">=</span> classes[j<span class="Statement">++</span>]) ) {
<span class="Comment">						// Remove *all* instances</span>
						<span class="Statement">while</span> ( cur.indexOf( <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> clazz <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> ) <span class="Statement">&gt;=</span> <span class="Constant">0</span> ) {
							cur <span class="Statement">=</span> cur.replace( <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> clazz <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span>, <span class="Constant">&quot; &quot;</span> );
						}
					}

<span class="Comment">					// only assign if different to avoid unneeded rendering.</span>
					finalValue <span class="Statement">=</span> value <span class="Statement">?</span> jQuery.trim( cur ) <span class="Statement">:</span> <span class="Constant">&quot;&quot;</span>;
					<span class="Statement">if</span> ( elem.className <span class="Statement">!==</span> finalValue ) {
						elem.className <span class="Statement">=</span> finalValue;
					}
				}
			}
		}

		<span class="Statement">return</span> <span class="Special">this</span>;
	},

	toggleClass: <span class="Type">function</span>( value, stateVal ) {
		<span class="Type">var</span> type <span class="Statement">=</span> <span class="Statement">typeof</span> value;

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> stateVal <span class="Statement">===</span> <span class="Constant">&quot;boolean&quot;</span> <span class="Statement">&amp;&amp;</span> type <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
			<span class="Statement">return</span> stateVal <span class="Statement">?</span> <span class="Special">this</span>.addClass( value ) <span class="Statement">:</span> <span class="Special">this</span>.removeClass( value );
		}

		<span class="Statement">if</span> ( jQuery.isFunction( value ) ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( i ) {
				jQuery( <span class="Special">this</span> ).toggleClass( value.call(<span class="Special">this</span>, i, <span class="Special">this</span>.className, stateVal), stateVal );
			});
		}

		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> ) {
<span class="Comment">				// toggle individual class names</span>
				<span class="Type">var</span> className,
					i <span class="Statement">=</span> <span class="Constant">0</span>,
					self <span class="Statement">=</span> jQuery( <span class="Special">this</span> ),
					classNames <span class="Statement">=</span> value.match( rnotwhite ) <span class="Statement">||</span> [];

				<span class="Statement">while</span> ( (className <span class="Statement">=</span> classNames[ i<span class="Statement">++</span> ]) ) {
<span class="Comment">					// check each className given, space separated list</span>
					<span class="Statement">if</span> ( self.hasClass( className ) ) {
						self.removeClass( className );
					} <span class="Statement">else</span> {
						self.addClass( className );
					}
				}

<span class="Comment">			// Toggle whole class name</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( type <span class="Statement">===</span> strundefined <span class="Statement">||</span> type <span class="Statement">===</span> <span class="Constant">&quot;boolean&quot;</span> ) {
				<span class="Statement">if</span> ( <span class="Special">this</span>.className ) {
<span class="Comment">					// store className if set</span>
					data_priv.set( <span class="Special">this</span>, <span class="Constant">&quot;__className__&quot;</span>, <span class="Special">this</span>.className );
				}

<span class="Comment">				// If the element has a class name or if we're passed &quot;false&quot;,</span>
<span class="Comment">				// then remove the whole classname (if there was one, the above saved it).</span>
<span class="Comment">				// Otherwise bring back whatever was previously saved (if anything),</span>
<span class="Comment">				// falling back to the empty string if nothing was stored.</span>
				<span class="Special">this</span>.className <span class="Statement">=</span> <span class="Special">this</span>.className <span class="Statement">||</span> value <span class="Statement">===</span> <span class="Constant">false</span> <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> data_priv.get( <span class="Special">this</span>, <span class="Constant">&quot;__className__&quot;</span> ) <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span>;
			}
		});
	},

	hasClass: <span class="Type">function</span>( selector ) {
		<span class="Type">var</span> className <span class="Statement">=</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> selector <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span>,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			l <span class="Statement">=</span> <span class="Special">this</span>.length;
		<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> l; i<span class="Statement">++</span> ) {
			<span class="Statement">if</span> ( <span class="Special">this</span>[i].nodeType <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">&amp;&amp;</span> (<span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> <span class="Special">this</span>[i].className <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span>).replace(rclass, <span class="Constant">&quot; &quot;</span>).indexOf( className ) <span class="Statement">&gt;=</span> <span class="Constant">0</span> ) {
				<span class="Statement">return</span> <span class="Constant">true</span>;
			}
		}

		<span class="Statement">return</span> <span class="Constant">false</span>;
	}
});




<span class="Type">var</span> rreturn <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">\r</span><span class="Constant">/g</span>;

jQuery.fn.extend({
	val: <span class="Type">function</span>( value ) {
		<span class="Type">var</span> hooks, ret, isFunction,
			elem <span class="Statement">=</span> <span class="Special">this</span>[<span class="Constant">0</span>];

		<span class="Statement">if</span> ( <span class="Statement">!</span>arguments.length ) {
			<span class="Statement">if</span> ( elem ) {
				hooks <span class="Statement">=</span> jQuery.valHooks[ elem.type ] <span class="Statement">||</span> jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				<span class="Statement">if</span> ( hooks <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;get&quot;</span> <span class="Statement">in</span> hooks <span class="Statement">&amp;&amp;</span> (ret <span class="Statement">=</span> hooks.get( elem, <span class="Constant">&quot;value&quot;</span> )) <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
					<span class="Statement">return</span> ret;
				}

				ret <span class="Statement">=</span> elem.value;

				<span class="Statement">return</span> <span class="Statement">typeof</span> ret <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">?</span>
<span class="Comment">					// handle most common string cases</span>
					ret.replace(rreturn, <span class="Constant">&quot;&quot;</span>) <span class="Statement">:</span>
<span class="Comment">					// handle cases where value is null/undef or number</span>
					ret <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> ret;
			}

			<span class="Statement">return</span>;
		}

		isFunction <span class="Statement">=</span> jQuery.isFunction( value );

		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( i ) {
			<span class="Type">var</span> val;

			<span class="Statement">if</span> ( <span class="Special">this</span>.nodeType <span class="Statement">!==</span> <span class="Constant">1</span> ) {
				<span class="Statement">return</span>;
			}

			<span class="Statement">if</span> ( isFunction ) {
				val <span class="Statement">=</span> value.call( <span class="Special">this</span>, i, jQuery( <span class="Special">this</span> ).val() );
			} <span class="Statement">else</span> {
				val <span class="Statement">=</span> value;
			}

<span class="Comment">			// Treat null/undefined as &quot;&quot;; convert numbers to string</span>
			<span class="Statement">if</span> ( val <span class="Statement">==</span> <span class="Type">null</span> ) {
				val <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;

			} <span class="Statement">else</span> <span class="Statement">if</span> ( <span class="Statement">typeof</span> val <span class="Statement">===</span> <span class="Constant">&quot;number&quot;</span> ) {
				val <span class="Statement">+=</span> <span class="Constant">&quot;&quot;</span>;

			} <span class="Statement">else</span> <span class="Statement">if</span> ( jQuery.isArray( val ) ) {
				val <span class="Statement">=</span> jQuery.map( val, <span class="Type">function</span>( value ) {
					<span class="Statement">return</span> value <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> value <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span>;
				});
			}

			hooks <span class="Statement">=</span> jQuery.valHooks[ <span class="Special">this</span>.type ] <span class="Statement">||</span> jQuery.valHooks[ <span class="Special">this</span>.nodeName.toLowerCase() ];

<span class="Comment">			// If set returns undefined, fall back to normal setting</span>
			<span class="Statement">if</span> ( <span class="Statement">!</span>hooks <span class="Statement">||</span> <span class="Statement">!</span>(<span class="Constant">&quot;set&quot;</span> <span class="Statement">in</span> hooks) <span class="Statement">||</span> hooks.set( <span class="Special">this</span>, val, <span class="Constant">&quot;value&quot;</span> ) <span class="Statement">===</span> <span class="Type">undefined</span> ) {
				<span class="Special">this</span>.value <span class="Statement">=</span> val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		select: {
			get: <span class="Type">function</span>( elem ) {
				<span class="Type">var</span> value, option,
					options <span class="Statement">=</span> elem.options,
					index <span class="Statement">=</span> elem.selectedIndex,
					one <span class="Statement">=</span> elem.type <span class="Statement">===</span> <span class="Constant">&quot;select-one&quot;</span> <span class="Statement">||</span> index <span class="Statement">&lt;</span> <span class="Constant">0</span>,
					values <span class="Statement">=</span> one <span class="Statement">?</span> <span class="Type">null</span> <span class="Statement">:</span> [],
					max <span class="Statement">=</span> one <span class="Statement">?</span> index <span class="Statement">+</span> <span class="Constant">1</span> <span class="Statement">:</span> options.length,
					i <span class="Statement">=</span> index <span class="Statement">&lt;</span> <span class="Constant">0</span> <span class="Statement">?</span>
						max <span class="Statement">:</span>
						one <span class="Statement">?</span> index <span class="Statement">:</span> <span class="Constant">0</span>;

<span class="Comment">				// Loop through all the selected options</span>
				<span class="Statement">for</span> ( ; i <span class="Statement">&lt;</span> max; i<span class="Statement">++</span> ) {
					option <span class="Statement">=</span> options[ i ];

<span class="Comment">					// IE6-9 doesn't update selected after form reset (#2551)</span>
					<span class="Statement">if</span> ( ( option.selected <span class="Statement">||</span> i <span class="Statement">===</span> index ) <span class="Statement">&amp;&amp;</span>
<span class="Comment">							// Don't return options that are disabled or in a disabled optgroup</span>
							( support.optDisabled <span class="Statement">?</span> <span class="Statement">!</span>option.disabled <span class="Statement">:</span> option.getAttribute( <span class="Constant">&quot;disabled&quot;</span> ) <span class="Statement">===</span> <span class="Type">null</span> ) <span class="Statement">&amp;&amp;</span>
							( <span class="Statement">!</span>option.parentNode.disabled <span class="Statement">||</span> <span class="Statement">!</span>jQuery.nodeName( option.parentNode, <span class="Constant">&quot;optgroup&quot;</span> ) ) ) {

<span class="Comment">						// Get the specific value for the option</span>
						value <span class="Statement">=</span> jQuery( option ).val();

<span class="Comment">						// We don't need an array for one selects</span>
						<span class="Statement">if</span> ( one ) {
							<span class="Statement">return</span> value;
						}

<span class="Comment">						// Multi-Selects return an array</span>
						values.push( value );
					}
				}

				<span class="Statement">return</span> values;
			},

			set: <span class="Type">function</span>( elem, value ) {
				<span class="Type">var</span> optionSet, option,
					options <span class="Statement">=</span> elem.options,
					values <span class="Statement">=</span> jQuery.makeArray( value ),
					i <span class="Statement">=</span> options.length;

				<span class="Statement">while</span> ( i<span class="Statement">--</span> ) {
					option <span class="Statement">=</span> options[ i ];
					<span class="Statement">if</span> ( (option.selected <span class="Statement">=</span> jQuery.inArray( jQuery(option).val(), values ) <span class="Statement">&gt;=</span> <span class="Constant">0</span>) ) {
						optionSet <span class="Statement">=</span> <span class="Constant">true</span>;
					}
				}

<span class="Comment">				// force browsers to behave consistently when non-matching value is set</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>optionSet ) {
					elem.selectedIndex <span class="Statement">=</span> <span class="Statement">-</span><span class="Constant">1</span>;
				}
				<span class="Statement">return</span> values;
			}
		}
	}
});

<span class="Comment">// Radios and checkboxes getter/setter</span>
jQuery.each([ <span class="Constant">&quot;radio&quot;</span>, <span class="Constant">&quot;checkbox&quot;</span> ], <span class="Type">function</span>() {
	jQuery.valHooks[ <span class="Special">this</span> ] <span class="Statement">=</span> {
		set: <span class="Type">function</span>( elem, value ) {
			<span class="Statement">if</span> ( jQuery.isArray( value ) ) {
				<span class="Statement">return</span> ( elem.checked <span class="Statement">=</span> jQuery.inArray( jQuery(elem).val(), value ) <span class="Statement">&gt;=</span> <span class="Constant">0</span> );
			}
		}
	};
	<span class="Statement">if</span> ( <span class="Statement">!</span>support.checkOn ) {
		jQuery.valHooks[ <span class="Special">this</span> ].get <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
<span class="Comment">			// Support: Webkit</span>
<span class="Comment">			// &quot;&quot; is returned instead of &quot;on&quot; if a value isn't specified</span>
			<span class="Statement">return</span> elem.getAttribute(<span class="Constant">&quot;value&quot;</span>) <span class="Statement">===</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">&quot;on&quot;</span> <span class="Statement">:</span> elem.value;
		};
	}
});




<span class="Comment">// Return jQuery for attributes-only inclusion</span>


jQuery.each( (<span class="Constant">&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot;</span> <span class="Statement">+</span>
	<span class="Constant">&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot;</span> <span class="Statement">+</span>
	<span class="Constant">&quot;change select submit keydown keypress keyup error contextmenu&quot;</span>).split(<span class="Constant">&quot; &quot;</span>), <span class="Type">function</span>( i, name ) {

<span class="Comment">	// Handle event binding</span>
	jQuery.fn[ name ] <span class="Statement">=</span> <span class="Type">function</span>( data, fn ) {
		<span class="Statement">return</span> <span class="Special">arguments</span>.length <span class="Statement">&gt;</span> <span class="Constant">0</span> <span class="Statement">?</span>
			<span class="Special">this</span>.on( name, <span class="Type">null</span>, data, fn ) <span class="Statement">:</span>
			<span class="Special">this</span>.trigger( name );
	};
});

jQuery.fn.extend({
	hover: <span class="Type">function</span>( fnOver, fnOut ) {
		<span class="Statement">return</span> <span class="Special">this</span>.mouseenter( fnOver ).mouseleave( fnOut <span class="Statement">||</span> fnOver );
	},

	bind: <span class="Type">function</span>( types, data, fn ) {
		<span class="Statement">return</span> <span class="Special">this</span>.on( types, <span class="Type">null</span>, data, fn );
	},
	unbind: <span class="Type">function</span>( types, fn ) {
		<span class="Statement">return</span> <span class="Special">this</span>.off( types, <span class="Type">null</span>, fn );
	},

	delegate: <span class="Type">function</span>( selector, types, data, fn ) {
		<span class="Statement">return</span> <span class="Special">this</span>.on( types, selector, data, fn );
	},
	undelegate: <span class="Type">function</span>( selector, types, fn ) {
<span class="Comment">		// ( namespace ) or ( selector, types [, fn] )</span>
		<span class="Statement">return</span> <span class="Special">arguments</span>.length <span class="Statement">===</span> <span class="Constant">1</span> <span class="Statement">?</span> <span class="Special">this</span>.off( selector, <span class="Constant">&quot;**&quot;</span> ) <span class="Statement">:</span> <span class="Special">this</span>.off( types, selector <span class="Statement">||</span> <span class="Constant">&quot;**&quot;</span>, fn );
	}
});


<span class="Type">var</span> nonce <span class="Statement">=</span> jQuery.now();

<span class="Type">var</span> rquery <span class="Statement">=</span> (<span class="Constant">/</span><span class="Special">\?</span><span class="Constant">/</span>);



<span class="Comment">// Support: Android 2.3</span>
<span class="Comment">// Workaround failure to string-cast null input</span>
jQuery.parseJSON <span class="Statement">=</span> <span class="Type">function</span>( data ) {
	<span class="Statement">return</span> <span class="Special">JSON</span>.parse( data <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span> );
};


<span class="Comment">// Cross-browser xml parsing</span>
jQuery.parseXML <span class="Statement">=</span> <span class="Type">function</span>( data ) {
	<span class="Type">var</span> xml, tmp;
	<span class="Statement">if</span> ( <span class="Statement">!</span>data <span class="Statement">||</span> <span class="Statement">typeof</span> data <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
		<span class="Statement">return</span> <span class="Type">null</span>;
	}

<span class="Comment">	// Support: IE9</span>
	<span class="Statement">try</span> {
		tmp <span class="Statement">=</span> <span class="Statement">new</span> DOMParser();
		xml <span class="Statement">=</span> tmp.parseFromString( data, <span class="Constant">&quot;text/xml&quot;</span> );
	} <span class="Statement">catch</span> ( e ) {
		xml <span class="Statement">=</span> <span class="Type">undefined</span>;
	}

	<span class="Statement">if</span> ( <span class="Statement">!</span>xml <span class="Statement">||</span> xml.getElementsByTagName( <span class="Constant">&quot;parsererror&quot;</span> ).length ) {
		jQuery.error( <span class="Constant">&quot;Invalid XML: &quot;</span> <span class="Statement">+</span> data );
	}
	<span class="Statement">return</span> xml;
};


<span class="Type">var</span>
<span class="Comment">	// Document location</span>
	ajaxLocParts,
	ajaxLocation,

	rhash <span class="Statement">=</span> <span class="Constant">/#.</span><span class="Special">*</span><span class="Special">$</span><span class="Constant">/</span>,
	rts <span class="Statement">=</span> <span class="Constant">/</span><span class="Constant">(</span><span class="Constant">[?&amp;]</span><span class="Constant">)</span><span class="Constant">_=</span><span class="Constant">[^&amp;]</span><span class="Special">*</span><span class="Constant">/</span>,
	rheaders <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(.</span><span class="Special">*?</span><span class="Constant">)</span><span class="Constant">:</span><span class="Constant">[ \t]</span><span class="Special">*</span><span class="Constant">(</span><span class="Constant">[^\r\n]</span><span class="Special">*</span><span class="Constant">)</span><span class="Special">$</span><span class="Constant">/mg</span>,
<span class="Comment">	// #7653, #8125, #8152: local protocol detection</span>
	rlocalProtocol <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">about</span><span class="Statement">|</span><span class="Constant">app</span><span class="Statement">|</span><span class="Constant">app-storage</span><span class="Statement">|</span><span class="Constant">.</span><span class="Special">+</span><span class="Constant">-extension</span><span class="Statement">|</span><span class="Constant">file</span><span class="Statement">|</span><span class="Constant">res</span><span class="Statement">|</span><span class="Constant">widget)</span><span class="Constant">:</span><span class="Special">$</span><span class="Constant">/</span>,
	rnoContent <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">GET</span><span class="Statement">|</span><span class="Constant">HEAD)</span><span class="Special">$</span><span class="Constant">/</span>,
	rprotocol <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Special">\/\/</span><span class="Constant">/</span>,
	rurl <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Constant">[\w.+-]</span><span class="Special">+</span><span class="Constant">:)(</span><span class="Special">?:</span><span class="Special">\/\/</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">[^\/?#]</span><span class="Special">*</span><span class="Constant">@</span><span class="Statement">|</span><span class="Constant">)(</span><span class="Constant">[^\/?#:]</span><span class="Special">*</span><span class="Constant">)(</span><span class="Special">?:</span><span class="Constant">:(</span><span class="Special">\d</span><span class="Special">+</span><span class="Constant">)</span><span class="Statement">|</span><span class="Constant">)</span><span class="Statement">|</span><span class="Constant">)/</span>,

	<span class="Comment">/* Prefilters</span>
<span class="Comment">	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)</span>
<span class="Comment">	 * 2) These are called:</span>
<span class="Comment">	 *    - BEFORE asking for a transport</span>
<span class="Comment">	 *    - AFTER param serialization (s.data is a string if s.processData is true)</span>
<span class="Comment">	 * 3) key is the dataType</span>
<span class="Comment">	 * 4) the catchall symbol &quot;*&quot; can be used</span>
<span class="Comment">	 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed</span>
<span class="Comment">	 */</span>
	prefilters <span class="Statement">=</span> {},

	<span class="Comment">/* Transports bindings</span>
<span class="Comment">	 * 1) key is the dataType</span>
<span class="Comment">	 * 2) the catchall symbol &quot;*&quot; can be used</span>
<span class="Comment">	 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed</span>
<span class="Comment">	 */</span>
	transports <span class="Statement">=</span> {},

<span class="Comment">	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression</span>
	allTypes <span class="Statement">=</span> <span class="Constant">&quot;*/&quot;</span>.concat(<span class="Constant">&quot;*&quot;</span>);

<span class="Comment">// #8138, IE may throw an exception when accessing</span>
<span class="Comment">// a field from window.location if document.domain has been set</span>
<span class="Statement">try</span> {
	ajaxLocation <span class="Statement">=</span> location.href;
} <span class="Statement">catch</span>( e ) {
<span class="Comment">	// Use the href attribute of an A element</span>
<span class="Comment">	// since IE will modify it given document.location</span>
	ajaxLocation <span class="Statement">=</span> <span class="Special">document</span>.createElement( <span class="Constant">&quot;a&quot;</span> );
	ajaxLocation.href <span class="Statement">=</span> <span class="Constant">&quot;&quot;</span>;
	ajaxLocation <span class="Statement">=</span> ajaxLocation.href;
}

<span class="Comment">// Segment location into parts</span>
ajaxLocParts <span class="Statement">=</span> rurl.exec( ajaxLocation.toLowerCase() ) <span class="Statement">||</span> [];

<span class="Comment">// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport</span>
<span class="Type">function</span> <span class="Identifier">addToPrefiltersOrTransports</span>( structure ) {

<span class="Comment">	// dataTypeExpression is optional and defaults to &quot;*&quot;</span>
	<span class="Statement">return</span> <span class="Type">function</span>( dataTypeExpression, func ) {

		<span class="Statement">if</span> ( <span class="Statement">typeof</span> dataTypeExpression <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
			func <span class="Statement">=</span> dataTypeExpression;
			dataTypeExpression <span class="Statement">=</span> <span class="Constant">&quot;*&quot;</span>;
		}

		<span class="Type">var</span> dataType,
			i <span class="Statement">=</span> <span class="Constant">0</span>,
			dataTypes <span class="Statement">=</span> dataTypeExpression.toLowerCase().match( rnotwhite ) <span class="Statement">||</span> [];

		<span class="Statement">if</span> ( jQuery.isFunction( func ) ) {
<span class="Comment">			// For each dataType in the dataTypeExpression</span>
			<span class="Statement">while</span> ( (dataType <span class="Statement">=</span> dataTypes[i<span class="Statement">++</span>]) ) {
<span class="Comment">				// Prepend if requested</span>
				<span class="Statement">if</span> ( dataType[<span class="Constant">0</span>] <span class="Statement">===</span> <span class="Constant">&quot;+&quot;</span> ) {
					dataType <span class="Statement">=</span> dataType.slice( <span class="Constant">1</span> ) <span class="Statement">||</span> <span class="Constant">&quot;*&quot;</span>;
					(structure[ dataType ] <span class="Statement">=</span> structure[ dataType ] <span class="Statement">||</span> []).unshift( func );

<span class="Comment">				// Otherwise append</span>
				} <span class="Statement">else</span> {
					(structure[ dataType ] <span class="Statement">=</span> structure[ dataType ] <span class="Statement">||</span> []).push( func );
				}
			}
		}
	};
}

<span class="Comment">// Base inspection function for prefilters and transports</span>
<span class="Type">function</span> <span class="Identifier">inspectPrefiltersOrTransports</span>( structure, options, originalOptions, jqXHR ) {

	<span class="Type">var</span> inspected <span class="Statement">=</span> {},
		seekingTransport <span class="Statement">=</span> ( structure <span class="Statement">===</span> transports );

	<span class="Type">function</span> <span class="Identifier">inspect</span>( dataType ) {
		<span class="Type">var</span> selected;
		inspected[ dataType ] <span class="Statement">=</span> <span class="Constant">true</span>;
		jQuery.each( structure[ dataType ] <span class="Statement">||</span> [], <span class="Type">function</span>( _, prefilterOrFactory ) {
			<span class="Type">var</span> dataTypeOrTransport <span class="Statement">=</span> prefilterOrFactory( options, originalOptions, jqXHR );
			<span class="Statement">if</span> ( <span class="Statement">typeof</span> dataTypeOrTransport <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>seekingTransport <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				<span class="Statement">return</span> <span class="Constant">false</span>;
			} <span class="Statement">else</span> <span class="Statement">if</span> ( seekingTransport ) {
				<span class="Statement">return</span> <span class="Statement">!</span>( selected <span class="Statement">=</span> dataTypeOrTransport );
			}
		});
		<span class="Statement">return</span> selected;
	}

	<span class="Statement">return</span> inspect( options.dataTypes[ <span class="Constant">0</span> ] ) <span class="Statement">||</span> <span class="Statement">!</span>inspected[ <span class="Constant">&quot;*&quot;</span> ] <span class="Statement">&amp;&amp;</span> inspect( <span class="Constant">&quot;*&quot;</span> );
}

<span class="Comment">// A special extend for ajax options</span>
<span class="Comment">// that takes &quot;flat&quot; options (not to be deep extended)</span>
<span class="Comment">// Fixes #9887</span>
<span class="Type">function</span> <span class="Identifier">ajaxExtend</span>( target, src ) {
	<span class="Type">var</span> key, deep,
		flatOptions <span class="Statement">=</span> jQuery.ajaxSettings.flatOptions <span class="Statement">||</span> {};

	<span class="Statement">for</span> ( key <span class="Statement">in</span> src ) {
		<span class="Statement">if</span> ( src[ key ] <span class="Statement">!==</span> <span class="Type">undefined</span> ) {
			( flatOptions[ key ] <span class="Statement">?</span> target <span class="Statement">:</span> ( deep <span class="Statement">||</span> (deep <span class="Statement">=</span> {}) ) )[ key ] <span class="Statement">=</span> src[ key ];
		}
	}
	<span class="Statement">if</span> ( deep ) {
		jQuery.extend( <span class="Constant">true</span>, target, deep );
	}

	<span class="Statement">return</span> target;
}

<span class="Comment">/* Handles responses to an ajax request:</span>
<span class="Comment"> * - finds the right dataType (mediates between content-type and expected dataType)</span>
<span class="Comment"> * - returns the corresponding response</span>
<span class="Comment"> */</span>
<span class="Type">function</span> <span class="Identifier">ajaxHandleResponses</span>( s, jqXHR, responses ) {

	<span class="Type">var</span> ct, type, finalDataType, firstDataType,
		contents <span class="Statement">=</span> s.contents,
		dataTypes <span class="Statement">=</span> s.dataTypes;

<span class="Comment">	// Remove auto dataType and get content-type in the process</span>
	<span class="Statement">while</span> ( dataTypes[ <span class="Constant">0</span> ] <span class="Statement">===</span> <span class="Constant">&quot;*&quot;</span> ) {
		dataTypes.shift();
		<span class="Statement">if</span> ( ct <span class="Statement">===</span> <span class="Type">undefined</span> ) {
			ct <span class="Statement">=</span> s.mimeType <span class="Statement">||</span> jqXHR.getResponseHeader(<span class="Constant">&quot;Content-Type&quot;</span>);
		}
	}

<span class="Comment">	// Check if we're dealing with a known content-type</span>
	<span class="Statement">if</span> ( ct ) {
		<span class="Statement">for</span> ( type <span class="Statement">in</span> contents ) {
			<span class="Statement">if</span> ( contents[ type ] <span class="Statement">&amp;&amp;</span> contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				<span class="Statement">break</span>;
			}
		}
	}

<span class="Comment">	// Check to see if we have a response for the expected dataType</span>
	<span class="Statement">if</span> ( dataTypes[ <span class="Constant">0</span> ] <span class="Statement">in</span> responses ) {
		finalDataType <span class="Statement">=</span> dataTypes[ <span class="Constant">0</span> ];
	} <span class="Statement">else</span> {
<span class="Comment">		// Try convertible dataTypes</span>
		<span class="Statement">for</span> ( type <span class="Statement">in</span> responses ) {
			<span class="Statement">if</span> ( <span class="Statement">!</span>dataTypes[ <span class="Constant">0</span> ] <span class="Statement">||</span> s.converters[ type <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> dataTypes[<span class="Constant">0</span>] ] ) {
				finalDataType <span class="Statement">=</span> type;
				<span class="Statement">break</span>;
			}
			<span class="Statement">if</span> ( <span class="Statement">!</span>firstDataType ) {
				firstDataType <span class="Statement">=</span> type;
			}
		}
<span class="Comment">		// Or just use first one</span>
		finalDataType <span class="Statement">=</span> finalDataType <span class="Statement">||</span> firstDataType;
	}

<span class="Comment">	// If we found a dataType</span>
<span class="Comment">	// We add the dataType to the list if needed</span>
<span class="Comment">	// and return the corresponding response</span>
	<span class="Statement">if</span> ( finalDataType ) {
		<span class="Statement">if</span> ( finalDataType <span class="Statement">!==</span> dataTypes[ <span class="Constant">0</span> ] ) {
			dataTypes.unshift( finalDataType );
		}
		<span class="Statement">return</span> responses[ finalDataType ];
	}
}

<span class="Comment">/* Chain conversions given the request and the original response</span>
<span class="Comment"> * Also sets the responseXXX fields on the jqXHR instance</span>
<span class="Comment"> */</span>
<span class="Type">function</span> <span class="Identifier">ajaxConvert</span>( s, response, jqXHR, isSuccess ) {
	<span class="Type">var</span> conv2, current, conv, tmp, prev,
		converters <span class="Statement">=</span> {},
<span class="Comment">		// Work with a copy of dataTypes in case we need to modify it for conversion</span>
		dataTypes <span class="Statement">=</span> s.dataTypes.slice();

<span class="Comment">	// Create converters map with lowercased keys</span>
	<span class="Statement">if</span> ( dataTypes[ <span class="Constant">1</span> ] ) {
		<span class="Statement">for</span> ( conv <span class="Statement">in</span> s.converters ) {
			converters[ conv.toLowerCase() ] <span class="Statement">=</span> s.converters[ conv ];
		}
	}

	current <span class="Statement">=</span> dataTypes.shift();

<span class="Comment">	// Convert to each sequential dataType</span>
	<span class="Statement">while</span> ( current ) {

		<span class="Statement">if</span> ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] <span class="Statement">=</span> response;
		}

<span class="Comment">		// Apply the dataFilter if provided</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>prev <span class="Statement">&amp;&amp;</span> isSuccess <span class="Statement">&amp;&amp;</span> s.dataFilter ) {
			response <span class="Statement">=</span> s.dataFilter( response, s.dataType );
		}

		prev <span class="Statement">=</span> current;
		current <span class="Statement">=</span> dataTypes.shift();

		<span class="Statement">if</span> ( current ) {

<span class="Comment">		// There's only work to do if current dataType is non-auto</span>
			<span class="Statement">if</span> ( current <span class="Statement">===</span> <span class="Constant">&quot;*&quot;</span> ) {

				current <span class="Statement">=</span> prev;

<span class="Comment">			// Convert response if prev dataType is non-auto and differs from current</span>
			} <span class="Statement">else</span> <span class="Statement">if</span> ( prev <span class="Statement">!==</span> <span class="Constant">&quot;*&quot;</span> <span class="Statement">&amp;&amp;</span> prev <span class="Statement">!==</span> current ) {

<span class="Comment">				// Seek a direct converter</span>
				conv <span class="Statement">=</span> converters[ prev <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> current ] <span class="Statement">||</span> converters[ <span class="Constant">&quot;* &quot;</span> <span class="Statement">+</span> current ];

<span class="Comment">				// If none found, seek a pair</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>conv ) {
					<span class="Statement">for</span> ( conv2 <span class="Statement">in</span> converters ) {

<span class="Comment">						// If conv2 outputs current</span>
						tmp <span class="Statement">=</span> conv2.split( <span class="Constant">&quot; &quot;</span> );
						<span class="Statement">if</span> ( tmp[ <span class="Constant">1</span> ] <span class="Statement">===</span> current ) {

<span class="Comment">							// If prev can be converted to accepted input</span>
							conv <span class="Statement">=</span> converters[ prev <span class="Statement">+</span> <span class="Constant">&quot; &quot;</span> <span class="Statement">+</span> tmp[ <span class="Constant">0</span> ] ] <span class="Statement">||</span>
								converters[ <span class="Constant">&quot;* &quot;</span> <span class="Statement">+</span> tmp[ <span class="Constant">0</span> ] ];
							<span class="Statement">if</span> ( conv ) {
<span class="Comment">								// Condense equivalence converters</span>
								<span class="Statement">if</span> ( conv <span class="Statement">===</span> <span class="Constant">true</span> ) {
									conv <span class="Statement">=</span> converters[ conv2 ];

<span class="Comment">								// Otherwise, insert the intermediate dataType</span>
								} <span class="Statement">else</span> <span class="Statement">if</span> ( converters[ conv2 ] <span class="Statement">!==</span> <span class="Constant">true</span> ) {
									current <span class="Statement">=</span> tmp[ <span class="Constant">0</span> ];
									dataTypes.unshift( tmp[ <span class="Constant">1</span> ] );
								}
								<span class="Statement">break</span>;
							}
						}
					}
				}

<span class="Comment">				// Apply converter (if not an equivalence)</span>
				<span class="Statement">if</span> ( conv <span class="Statement">!==</span> <span class="Constant">true</span> ) {

<span class="Comment">					// Unless errors are allowed to bubble, catch and return them</span>
					<span class="Statement">if</span> ( conv <span class="Statement">&amp;&amp;</span> s[ <span class="Constant">&quot;throws&quot;</span> ] ) {
						response <span class="Statement">=</span> conv( response );
					} <span class="Statement">else</span> {
						<span class="Statement">try</span> {
							response <span class="Statement">=</span> conv( response );
						} <span class="Statement">catch</span> ( e ) {
							<span class="Statement">return</span> { state: <span class="Constant">&quot;parsererror&quot;</span>, error: conv <span class="Statement">?</span> e <span class="Statement">:</span> <span class="Constant">&quot;No conversion from &quot;</span> <span class="Statement">+</span> prev <span class="Statement">+</span> <span class="Constant">&quot; to &quot;</span> <span class="Statement">+</span> current };
						}
					}
				}
			}
		}
	}

	<span class="Statement">return</span> { state: <span class="Constant">&quot;success&quot;</span>, data: response };
}

jQuery.extend({

<span class="Comment">	// Counter for holding the number of active queries</span>
	active: <span class="Constant">0</span>,

<span class="Comment">	// Last-Modified header cache for next request</span>
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: <span class="Constant">&quot;GET&quot;</span>,
		isLocal: rlocalProtocol.test( ajaxLocParts[ <span class="Constant">1</span> ] ),
		global: <span class="Constant">true</span>,
		processData: <span class="Constant">true</span>,
		async: <span class="Constant">true</span>,
		contentType: <span class="Constant">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,
		<span class="Comment">/*</span>
<span class="Comment">		timeout: 0,</span>
<span class="Comment">		data: null,</span>
<span class="Comment">		dataType: null,</span>
<span class="Comment">		username: null,</span>
<span class="Comment">		password: null,</span>
<span class="Comment">		cache: null,</span>
<span class="Comment">		throws: false,</span>
<span class="Comment">		traditional: false,</span>
<span class="Comment">		headers: {},</span>
<span class="Comment">		*/</span>

		accepts: {
			<span class="Constant">&quot;*&quot;</span>: allTypes,
			text: <span class="Constant">&quot;text/plain&quot;</span>,
			html: <span class="Constant">&quot;text/html&quot;</span>,
			xml: <span class="Constant">&quot;application/xml, text/xml&quot;</span>,
			json: <span class="Constant">&quot;application/json, text/javascript&quot;</span>
		},

		contents: {
			xml: <span class="Constant">/xml/</span>,
			html: <span class="Constant">/html/</span>,
			json: <span class="Constant">/json/</span>
		},

		responseFields: {
			xml: <span class="Constant">&quot;responseXML&quot;</span>,
			text: <span class="Constant">&quot;responseText&quot;</span>,
			json: <span class="Constant">&quot;responseJSON&quot;</span>
		},

<span class="Comment">		// Data converters</span>
<span class="Comment">		// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space</span>
		converters: {

<span class="Comment">			// Convert anything to text</span>
			<span class="Constant">&quot;* text&quot;</span>: <span class="Special">String</span>,

<span class="Comment">			// Text to html (true = no transformation)</span>
			<span class="Constant">&quot;text html&quot;</span>: <span class="Constant">true</span>,

<span class="Comment">			// Evaluate text as a json expression</span>
			<span class="Constant">&quot;text json&quot;</span>: jQuery.parseJSON,

<span class="Comment">			// Parse text as xml</span>
			<span class="Constant">&quot;text xml&quot;</span>: jQuery.parseXML
		},

<span class="Comment">		// For options that shouldn't be deep extended:</span>
<span class="Comment">		// you can add your own custom options here if</span>
<span class="Comment">		// and when you create one that shouldn't be</span>
<span class="Comment">		// deep extended (see ajaxExtend)</span>
		flatOptions: {
			url: <span class="Constant">true</span>,
			context: <span class="Constant">true</span>
		}
	},

<span class="Comment">	// Creates a full fledged settings object into target</span>
<span class="Comment">	// with both ajaxSettings and settings fields.</span>
<span class="Comment">	// If target is omitted, writes into ajaxSettings.</span>
	ajaxSetup: <span class="Type">function</span>( target, settings ) {
		<span class="Statement">return</span> settings <span class="Statement">?</span>

<span class="Comment">			// Building a settings object</span>
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) <span class="Statement">:</span>

<span class="Comment">			// Extending ajaxSettings</span>
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

<span class="Comment">	// Main method</span>
	ajax: <span class="Type">function</span>( url, options ) {

<span class="Comment">		// If url is an object, simulate pre-1.5 signature</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> url <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
			options <span class="Statement">=</span> url;
			url <span class="Statement">=</span> <span class="Type">undefined</span>;
		}

<span class="Comment">		// Force options to be an object</span>
		options <span class="Statement">=</span> options <span class="Statement">||</span> {};

		<span class="Type">var</span> transport,
<span class="Comment">			// URL without anti-cache param</span>
			cacheURL,
<span class="Comment">			// Response headers</span>
			responseHeadersString,
			responseHeaders,
<span class="Comment">			// timeout handle</span>
			timeoutTimer,
<span class="Comment">			// Cross-domain detection vars</span>
			parts,
<span class="Comment">			// To know if global events are to be dispatched</span>
			fireGlobals,
<span class="Comment">			// Loop variable</span>
			i,
<span class="Comment">			// Create the final options object</span>
			s <span class="Statement">=</span> jQuery.ajaxSetup( {}, options ),
<span class="Comment">			// Callbacks context</span>
			callbackContext <span class="Statement">=</span> s.context <span class="Statement">||</span> s,
<span class="Comment">			// Context for global events is callbackContext if it is a DOM node or jQuery collection</span>
			globalEventContext <span class="Statement">=</span> s.context <span class="Statement">&amp;&amp;</span> ( callbackContext.nodeType <span class="Statement">||</span> callbackContext.jquery ) <span class="Statement">?</span>
				jQuery( callbackContext ) <span class="Statement">:</span>
				jQuery.event,
<span class="Comment">			// Deferreds</span>
			deferred <span class="Statement">=</span> jQuery.Deferred(),
			completeDeferred <span class="Statement">=</span> jQuery.Callbacks(<span class="Constant">&quot;once memory&quot;</span>),
<span class="Comment">			// Status-dependent callbacks</span>
			statusCode <span class="Statement">=</span> s.statusCode <span class="Statement">||</span> {},
<span class="Comment">			// Headers (they are sent all at once)</span>
			requestHeaders <span class="Statement">=</span> {},
			requestHeadersNames <span class="Statement">=</span> {},
<span class="Comment">			// The jqXHR state</span>
			state <span class="Statement">=</span> <span class="Constant">0</span>,
<span class="Comment">			// Default abort message</span>
			strAbort <span class="Statement">=</span> <span class="Constant">&quot;canceled&quot;</span>,
<span class="Comment">			// Fake xhr</span>
			jqXHR <span class="Statement">=</span> {
				readyState: <span class="Constant">0</span>,

<span class="Comment">				// Builds headers hashtable if needed</span>
				getResponseHeader: <span class="Type">function</span>( key ) {
					<span class="Type">var</span> match;
					<span class="Statement">if</span> ( state <span class="Statement">===</span> <span class="Constant">2</span> ) {
						<span class="Statement">if</span> ( <span class="Statement">!</span>responseHeaders ) {
							responseHeaders <span class="Statement">=</span> {};
							<span class="Statement">while</span> ( (match <span class="Statement">=</span> rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[<span class="Constant">1</span>].toLowerCase() ] <span class="Statement">=</span> match[ <span class="Constant">2</span> ];
							}
						}
						match <span class="Statement">=</span> responseHeaders[ key.toLowerCase() ];
					}
					<span class="Statement">return</span> match <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Type">null</span> <span class="Statement">:</span> match;
				},

<span class="Comment">				// Raw string</span>
				getAllResponseHeaders: <span class="Type">function</span>() {
					<span class="Statement">return</span> state <span class="Statement">===</span> <span class="Constant">2</span> <span class="Statement">?</span> responseHeadersString <span class="Statement">:</span> <span class="Type">null</span>;
				},

<span class="Comment">				// Caches the header</span>
				setRequestHeader: <span class="Type">function</span>( name, value ) {
					<span class="Type">var</span> lname <span class="Statement">=</span> name.toLowerCase();
					<span class="Statement">if</span> ( <span class="Statement">!</span>state ) {
						name <span class="Statement">=</span> requestHeadersNames[ lname ] <span class="Statement">=</span> requestHeadersNames[ lname ] <span class="Statement">||</span> name;
						requestHeaders[ name ] <span class="Statement">=</span> value;
					}
					<span class="Statement">return</span> <span class="Special">this</span>;
				},

<span class="Comment">				// Overrides response content-type header</span>
				overrideMimeType: <span class="Type">function</span>( type ) {
					<span class="Statement">if</span> ( <span class="Statement">!</span>state ) {
						s.mimeType <span class="Statement">=</span> type;
					}
					<span class="Statement">return</span> <span class="Special">this</span>;
				},

<span class="Comment">				// Status-dependent callbacks</span>
				statusCode: <span class="Type">function</span>( map ) {
					<span class="Type">var</span> code;
					<span class="Statement">if</span> ( map ) {
						<span class="Statement">if</span> ( state <span class="Statement">&lt;</span> <span class="Constant">2</span> ) {
							<span class="Statement">for</span> ( code <span class="Statement">in</span> map ) {
<span class="Comment">								// Lazy-add the new callback in a way that preserves old ones</span>
								statusCode[ code ] <span class="Statement">=</span> [ statusCode[ code ], map[ code ] ];
							}
						} <span class="Statement">else</span> {
<span class="Comment">							// Execute the appropriate callbacks</span>
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					<span class="Statement">return</span> <span class="Special">this</span>;
				},

<span class="Comment">				// Cancel the request</span>
				abort: <span class="Type">function</span>( statusText ) {
					<span class="Type">var</span> finalText <span class="Statement">=</span> statusText <span class="Statement">||</span> strAbort;
					<span class="Statement">if</span> ( transport ) {
						transport.abort( finalText );
					}
					done( <span class="Constant">0</span>, finalText );
					<span class="Statement">return</span> <span class="Special">this</span>;
				}
			};

<span class="Comment">		// Attach deferreds</span>
		deferred.promise( jqXHR ).complete <span class="Statement">=</span> completeDeferred.add;
		jqXHR.success <span class="Statement">=</span> jqXHR.done;
		jqXHR.error <span class="Statement">=</span> jqXHR.fail;

<span class="Comment">		// Remove hash character (#7531: and string promotion)</span>
<span class="Comment">		// Add protocol if not provided (prefilters might expect it)</span>
<span class="Comment">		// Handle falsy url in the settings object (#10093: consistency with old signature)</span>
<span class="Comment">		// We also use the url parameter if available</span>
		s.url <span class="Statement">=</span> ( ( url <span class="Statement">||</span> s.url <span class="Statement">||</span> ajaxLocation ) <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span> ).replace( rhash, <span class="Constant">&quot;&quot;</span> )
			.replace( rprotocol, ajaxLocParts[ <span class="Constant">1</span> ] <span class="Statement">+</span> <span class="Constant">&quot;//&quot;</span> );

<span class="Comment">		// Alias method option to type as per ticket #12004</span>
		s.type <span class="Statement">=</span> options.method <span class="Statement">||</span> options.type <span class="Statement">||</span> s.method <span class="Statement">||</span> s.type;

<span class="Comment">		// Extract dataTypes list</span>
		s.dataTypes <span class="Statement">=</span> jQuery.trim( s.dataType <span class="Statement">||</span> <span class="Constant">&quot;*&quot;</span> ).toLowerCase().match( rnotwhite ) <span class="Statement">||</span> [ <span class="Constant">&quot;&quot;</span> ];

<span class="Comment">		// A cross-domain request is in order when we have a protocol:host:port mismatch</span>
		<span class="Statement">if</span> ( s.crossDomain <span class="Statement">==</span> <span class="Type">null</span> ) {
			parts <span class="Statement">=</span> rurl.exec( s.url.toLowerCase() );
			s.crossDomain <span class="Statement">=</span> <span class="Statement">!!</span>( parts <span class="Statement">&amp;&amp;</span>
				( parts[ <span class="Constant">1</span> ] <span class="Statement">!==</span> ajaxLocParts[ <span class="Constant">1</span> ] <span class="Statement">||</span> parts[ <span class="Constant">2</span> ] <span class="Statement">!==</span> ajaxLocParts[ <span class="Constant">2</span> ] <span class="Statement">||</span>
					( parts[ <span class="Constant">3</span> ] <span class="Statement">||</span> ( parts[ <span class="Constant">1</span> ] <span class="Statement">===</span> <span class="Constant">&quot;http:&quot;</span> <span class="Statement">?</span> <span class="Constant">&quot;80&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;443&quot;</span> ) ) <span class="Statement">!==</span>
						( ajaxLocParts[ <span class="Constant">3</span> ] <span class="Statement">||</span> ( ajaxLocParts[ <span class="Constant">1</span> ] <span class="Statement">===</span> <span class="Constant">&quot;http:&quot;</span> <span class="Statement">?</span> <span class="Constant">&quot;80&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;443&quot;</span> ) ) )
			);
		}

<span class="Comment">		// Convert data if not already a string</span>
		<span class="Statement">if</span> ( s.data <span class="Statement">&amp;&amp;</span> s.processData <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> s.data <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
			s.data <span class="Statement">=</span> jQuery.param( s.data, s.traditional );
		}

<span class="Comment">		// Apply prefilters</span>
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

<span class="Comment">		// If request was aborted inside a prefilter, stop there</span>
		<span class="Statement">if</span> ( state <span class="Statement">===</span> <span class="Constant">2</span> ) {
			<span class="Statement">return</span> jqXHR;
		}

<span class="Comment">		// We can fire global events as of now if asked to</span>
		fireGlobals <span class="Statement">=</span> s.global;

<span class="Comment">		// Watch for a new set of requests</span>
		<span class="Statement">if</span> ( fireGlobals <span class="Statement">&amp;&amp;</span> jQuery.active<span class="Statement">++</span> <span class="Statement">===</span> <span class="Constant">0</span> ) {
			jQuery.event.trigger(<span class="Constant">&quot;ajaxStart&quot;</span>);
		}

<span class="Comment">		// Uppercase the type</span>
		s.type <span class="Statement">=</span> s.type.toUpperCase();

<span class="Comment">		// Determine if request has content</span>
		s.hasContent <span class="Statement">=</span> <span class="Statement">!</span>rnoContent.test( s.type );

<span class="Comment">		// Save the URL in case we're toying with the If-Modified-Since</span>
<span class="Comment">		// and/or If-None-Match header later on</span>
		cacheURL <span class="Statement">=</span> s.url;

<span class="Comment">		// More options handling for requests with no content</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>s.hasContent ) {

<span class="Comment">			// If data is available, append data to url</span>
			<span class="Statement">if</span> ( s.data ) {
				cacheURL <span class="Statement">=</span> ( s.url <span class="Statement">+=</span> ( rquery.test( cacheURL ) <span class="Statement">?</span> <span class="Constant">&quot;&amp;&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;?&quot;</span> ) <span class="Statement">+</span> s.data );
<span class="Comment">				// #9682: remove data so that it's not used in an eventual retry</span>
				<span class="Statement">delete</span> s.data;
			}

<span class="Comment">			// Add anti-cache in url if needed</span>
			<span class="Statement">if</span> ( s.cache <span class="Statement">===</span> <span class="Constant">false</span> ) {
				s.url <span class="Statement">=</span> rts.test( cacheURL ) <span class="Statement">?</span>

<span class="Comment">					// If there is already a '_' parameter, set its value</span>
					cacheURL.replace( rts, <span class="Constant">&quot;$1_=&quot;</span> <span class="Statement">+</span> nonce<span class="Statement">++</span> ) <span class="Statement">:</span>

<span class="Comment">					// Otherwise add one to the end</span>
					cacheURL <span class="Statement">+</span> ( rquery.test( cacheURL ) <span class="Statement">?</span> <span class="Constant">&quot;&amp;&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;?&quot;</span> ) <span class="Statement">+</span> <span class="Constant">&quot;_=&quot;</span> <span class="Statement">+</span> nonce<span class="Statement">++</span>;
			}
		}

<span class="Comment">		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span>
		<span class="Statement">if</span> ( s.ifModified ) {
			<span class="Statement">if</span> ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( <span class="Constant">&quot;If-Modified-Since&quot;</span>, jQuery.lastModified[ cacheURL ] );
			}
			<span class="Statement">if</span> ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( <span class="Constant">&quot;If-None-Match&quot;</span>, jQuery.etag[ cacheURL ] );
			}
		}

<span class="Comment">		// Set the correct header, if data is being sent</span>
		<span class="Statement">if</span> ( s.data <span class="Statement">&amp;&amp;</span> s.hasContent <span class="Statement">&amp;&amp;</span> s.contentType <span class="Statement">!==</span> <span class="Constant">false</span> <span class="Statement">||</span> options.contentType ) {
			jqXHR.setRequestHeader( <span class="Constant">&quot;Content-Type&quot;</span>, s.contentType );
		}

<span class="Comment">		// Set the Accepts header for the server, depending on the dataType</span>
		jqXHR.setRequestHeader(
			<span class="Constant">&quot;Accept&quot;</span>,
			s.dataTypes[ <span class="Constant">0</span> ] <span class="Statement">&amp;&amp;</span> s.accepts[ s.dataTypes[<span class="Constant">0</span>] ] <span class="Statement">?</span>
				s.accepts[ s.dataTypes[<span class="Constant">0</span>] ] <span class="Statement">+</span> ( s.dataTypes[ <span class="Constant">0</span> ] <span class="Statement">!==</span> <span class="Constant">&quot;*&quot;</span> <span class="Statement">?</span> <span class="Constant">&quot;, &quot;</span> <span class="Statement">+</span> allTypes <span class="Statement">+</span> <span class="Constant">&quot;; q=0.01&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;&quot;</span> ) <span class="Statement">:</span>
				s.accepts[ <span class="Constant">&quot;*&quot;</span> ]
		);

<span class="Comment">		// Check for headers option</span>
		<span class="Statement">for</span> ( i <span class="Statement">in</span> s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

<span class="Comment">		// Allow custom headers/mimetypes and early abort</span>
		<span class="Statement">if</span> ( s.beforeSend <span class="Statement">&amp;&amp;</span> ( s.beforeSend.call( callbackContext, jqXHR, s ) <span class="Statement">===</span> <span class="Constant">false</span> <span class="Statement">||</span> state <span class="Statement">===</span> <span class="Constant">2</span> ) ) {
<span class="Comment">			// Abort if not done already and return</span>
			<span class="Statement">return</span> jqXHR.abort();
		}

<span class="Comment">		// aborting is no longer a cancellation</span>
		strAbort <span class="Statement">=</span> <span class="Constant">&quot;abort&quot;</span>;

<span class="Comment">		// Install callbacks on deferreds</span>
		<span class="Statement">for</span> ( i <span class="Statement">in</span> { success: <span class="Constant">1</span>, error: <span class="Constant">1</span>, complete: <span class="Constant">1</span> } ) {
			jqXHR[ i ]( s[ i ] );
		}

<span class="Comment">		// Get transport</span>
		transport <span class="Statement">=</span> inspectPrefiltersOrTransports( transports, s, options, jqXHR );

<span class="Comment">		// If no transport, we auto-abort</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>transport ) {
			done( <span class="Statement">-</span><span class="Constant">1</span>, <span class="Constant">&quot;No Transport&quot;</span> );
		} <span class="Statement">else</span> {
			jqXHR.readyState <span class="Statement">=</span> <span class="Constant">1</span>;

<span class="Comment">			// Send global event</span>
			<span class="Statement">if</span> ( fireGlobals ) {
				globalEventContext.trigger( <span class="Constant">&quot;ajaxSend&quot;</span>, [ jqXHR, s ] );
			}
<span class="Comment">			// Timeout</span>
			<span class="Statement">if</span> ( s.async <span class="Statement">&amp;&amp;</span> s.timeout <span class="Statement">&gt;</span> <span class="Constant">0</span> ) {
				timeoutTimer <span class="Statement">=</span> setTimeout(<span class="Type">function</span>() {
					jqXHR.abort(<span class="Constant">&quot;timeout&quot;</span>);
				}, s.timeout );
			}

			<span class="Statement">try</span> {
				state <span class="Statement">=</span> <span class="Constant">1</span>;
				transport.send( requestHeaders, done );
			} <span class="Statement">catch</span> ( e ) {
<span class="Comment">				// Propagate exception as error if not done</span>
				<span class="Statement">if</span> ( state <span class="Statement">&lt;</span> <span class="Constant">2</span> ) {
					done( <span class="Statement">-</span><span class="Constant">1</span>, e );
<span class="Comment">				// Simply rethrow otherwise</span>
				} <span class="Statement">else</span> {
					<span class="Statement">throw</span> e;
				}
			}
		}

<span class="Comment">		// Callback for when everything is done</span>
		<span class="Type">function</span> <span class="Identifier">done</span>( status, nativeStatusText, responses, headers ) {
			<span class="Type">var</span> isSuccess, success, error, response, modified,
				statusText <span class="Statement">=</span> nativeStatusText;

<span class="Comment">			// Called once</span>
			<span class="Statement">if</span> ( state <span class="Statement">===</span> <span class="Constant">2</span> ) {
				<span class="Statement">return</span>;
			}

<span class="Comment">			// State is &quot;done&quot; now</span>
			state <span class="Statement">=</span> <span class="Constant">2</span>;

<span class="Comment">			// Clear timeout if it exists</span>
			<span class="Statement">if</span> ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

<span class="Comment">			// Dereference transport for early garbage collection</span>
<span class="Comment">			// (no matter how long the jqXHR object will be used)</span>
			transport <span class="Statement">=</span> <span class="Type">undefined</span>;

<span class="Comment">			// Cache response headers</span>
			responseHeadersString <span class="Statement">=</span> headers <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span>;

<span class="Comment">			// Set readyState</span>
			jqXHR.readyState <span class="Statement">=</span> status <span class="Statement">&gt;</span> <span class="Constant">0</span> <span class="Statement">?</span> <span class="Constant">4</span> <span class="Statement">:</span> <span class="Constant">0</span>;

<span class="Comment">			// Determine if successful</span>
			isSuccess <span class="Statement">=</span> status <span class="Statement">&gt;=</span> <span class="Constant">200</span> <span class="Statement">&amp;&amp;</span> status <span class="Statement">&lt;</span> <span class="Constant">300</span> <span class="Statement">||</span> status <span class="Statement">===</span> <span class="Constant">304</span>;

<span class="Comment">			// Get response data</span>
			<span class="Statement">if</span> ( responses ) {
				response <span class="Statement">=</span> ajaxHandleResponses( s, jqXHR, responses );
			}

<span class="Comment">			// Convert no matter what (that way responseXXX fields are always set)</span>
			response <span class="Statement">=</span> ajaxConvert( s, response, jqXHR, isSuccess );

<span class="Comment">			// If successful, handle type chaining</span>
			<span class="Statement">if</span> ( isSuccess ) {

<span class="Comment">				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span>
				<span class="Statement">if</span> ( s.ifModified ) {
					modified <span class="Statement">=</span> jqXHR.getResponseHeader(<span class="Constant">&quot;Last-Modified&quot;</span>);
					<span class="Statement">if</span> ( modified ) {
						jQuery.lastModified[ cacheURL ] <span class="Statement">=</span> modified;
					}
					modified <span class="Statement">=</span> jqXHR.getResponseHeader(<span class="Constant">&quot;etag&quot;</span>);
					<span class="Statement">if</span> ( modified ) {
						jQuery.etag[ cacheURL ] <span class="Statement">=</span> modified;
					}
				}

<span class="Comment">				// if no content</span>
				<span class="Statement">if</span> ( status <span class="Statement">===</span> <span class="Constant">204</span> <span class="Statement">||</span> s.type <span class="Statement">===</span> <span class="Constant">&quot;HEAD&quot;</span> ) {
					statusText <span class="Statement">=</span> <span class="Constant">&quot;nocontent&quot;</span>;

<span class="Comment">				// if not modified</span>
				} <span class="Statement">else</span> <span class="Statement">if</span> ( status <span class="Statement">===</span> <span class="Constant">304</span> ) {
					statusText <span class="Statement">=</span> <span class="Constant">&quot;notmodified&quot;</span>;

<span class="Comment">				// If we have data, let's convert it</span>
				} <span class="Statement">else</span> {
					statusText <span class="Statement">=</span> response.state;
					success <span class="Statement">=</span> response.data;
					error <span class="Statement">=</span> response.error;
					isSuccess <span class="Statement">=</span> <span class="Statement">!</span>error;
				}
			} <span class="Statement">else</span> {
<span class="Comment">				// We extract error from statusText</span>
<span class="Comment">				// then normalize statusText and status for non-aborts</span>
				error <span class="Statement">=</span> statusText;
				<span class="Statement">if</span> ( status <span class="Statement">||</span> <span class="Statement">!</span>statusText ) {
					statusText <span class="Statement">=</span> <span class="Constant">&quot;error&quot;</span>;
					<span class="Statement">if</span> ( status <span class="Statement">&lt;</span> <span class="Constant">0</span> ) {
						status <span class="Statement">=</span> <span class="Constant">0</span>;
					}
				}
			}

<span class="Comment">			// Set data for the fake xhr object</span>
			jqXHR.status <span class="Statement">=</span> status;
			jqXHR.statusText <span class="Statement">=</span> ( nativeStatusText <span class="Statement">||</span> statusText ) <span class="Statement">+</span> <span class="Constant">&quot;&quot;</span>;

<span class="Comment">			// Success/Error</span>
			<span class="Statement">if</span> ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} <span class="Statement">else</span> {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

<span class="Comment">			// Status-dependent callbacks</span>
			jqXHR.statusCode( statusCode );
			statusCode <span class="Statement">=</span> <span class="Type">undefined</span>;

			<span class="Statement">if</span> ( fireGlobals ) {
				globalEventContext.trigger( isSuccess <span class="Statement">?</span> <span class="Constant">&quot;ajaxSuccess&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;ajaxError&quot;</span>,
					[ jqXHR, s, isSuccess <span class="Statement">?</span> success <span class="Statement">:</span> error ] );
			}

<span class="Comment">			// Complete</span>
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			<span class="Statement">if</span> ( fireGlobals ) {
				globalEventContext.trigger( <span class="Constant">&quot;ajaxComplete&quot;</span>, [ jqXHR, s ] );
<span class="Comment">				// Handle the global AJAX counter</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>( <span class="Statement">--</span>jQuery.active ) ) {
					jQuery.event.trigger(<span class="Constant">&quot;ajaxStop&quot;</span>);
				}
			}
		}

		<span class="Statement">return</span> jqXHR;
	},

	getJSON: <span class="Type">function</span>( url, data, callback ) {
		<span class="Statement">return</span> jQuery.get( url, data, callback, <span class="Constant">&quot;json&quot;</span> );
	},

	getScript: <span class="Type">function</span>( url, callback ) {
		<span class="Statement">return</span> jQuery.get( url, <span class="Type">undefined</span>, callback, <span class="Constant">&quot;script&quot;</span> );
	}
});

jQuery.each( [ <span class="Constant">&quot;get&quot;</span>, <span class="Constant">&quot;post&quot;</span> ], <span class="Type">function</span>( i, method ) {
	jQuery[ method ] <span class="Statement">=</span> <span class="Type">function</span>( url, data, callback, type ) {
<span class="Comment">		// shift arguments if data argument was omitted</span>
		<span class="Statement">if</span> ( jQuery.isFunction( data ) ) {
			type <span class="Statement">=</span> type <span class="Statement">||</span> callback;
			callback <span class="Statement">=</span> data;
			data <span class="Statement">=</span> <span class="Type">undefined</span>;
		}

		<span class="Statement">return</span> jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

<span class="Comment">// Attach a bunch of functions for handling common AJAX events</span>
jQuery.each( [ <span class="Constant">&quot;ajaxStart&quot;</span>, <span class="Constant">&quot;ajaxStop&quot;</span>, <span class="Constant">&quot;ajaxComplete&quot;</span>, <span class="Constant">&quot;ajaxError&quot;</span>, <span class="Constant">&quot;ajaxSuccess&quot;</span>, <span class="Constant">&quot;ajaxSend&quot;</span> ], <span class="Type">function</span>( i, type ) {
	jQuery.fn[ type ] <span class="Statement">=</span> <span class="Type">function</span>( fn ) {
		<span class="Statement">return</span> <span class="Special">this</span>.on( type, fn );
	};
});


jQuery._evalUrl <span class="Statement">=</span> <span class="Type">function</span>( url ) {
	<span class="Statement">return</span> jQuery.ajax({
		url: url,
		type: <span class="Constant">&quot;GET&quot;</span>,
		dataType: <span class="Constant">&quot;script&quot;</span>,
		async: <span class="Constant">false</span>,
		global: <span class="Constant">false</span>,
		<span class="Constant">&quot;throws&quot;</span>: <span class="Constant">true</span>
	});
};


jQuery.fn.extend({
	wrapAll: <span class="Type">function</span>( html ) {
		<span class="Type">var</span> wrap;

		<span class="Statement">if</span> ( jQuery.isFunction( html ) ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( i ) {
				jQuery( <span class="Special">this</span> ).wrapAll( html.call(<span class="Special">this</span>, i) );
			});
		}

		<span class="Statement">if</span> ( <span class="Special">this</span>[ <span class="Constant">0</span> ] ) {

<span class="Comment">			// The elements to wrap the target around</span>
			wrap <span class="Statement">=</span> jQuery( html, <span class="Special">this</span>[ <span class="Constant">0</span> ].ownerDocument ).eq( <span class="Constant">0</span> ).clone( <span class="Constant">true</span> );

			<span class="Statement">if</span> ( <span class="Special">this</span>[ <span class="Constant">0</span> ].parentNode ) {
				wrap.insertBefore( <span class="Special">this</span>[ <span class="Constant">0</span> ] );
			}

			wrap.map(<span class="Type">function</span>() {
				<span class="Type">var</span> elem <span class="Statement">=</span> <span class="Special">this</span>;

				<span class="Statement">while</span> ( elem.firstElementChild ) {
					elem <span class="Statement">=</span> elem.firstElementChild;
				}

				<span class="Statement">return</span> elem;
			}).append( <span class="Special">this</span> );
		}

		<span class="Statement">return</span> <span class="Special">this</span>;
	},

	wrapInner: <span class="Type">function</span>( html ) {
		<span class="Statement">if</span> ( jQuery.isFunction( html ) ) {
			<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( i ) {
				jQuery( <span class="Special">this</span> ).wrapInner( html.call(<span class="Special">this</span>, i) );
			});
		}

		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>() {
			<span class="Type">var</span> self <span class="Statement">=</span> jQuery( <span class="Special">this</span> ),
				contents <span class="Statement">=</span> self.contents();

			<span class="Statement">if</span> ( contents.length ) {
				contents.wrapAll( html );

			} <span class="Statement">else</span> {
				self.append( html );
			}
		});
	},

	wrap: <span class="Type">function</span>( html ) {
		<span class="Type">var</span> isFunction <span class="Statement">=</span> jQuery.isFunction( html );

		<span class="Statement">return</span> <span class="Special">this</span>.each(<span class="Type">function</span>( i ) {
			jQuery( <span class="Special">this</span> ).wrapAll( isFunction <span class="Statement">?</span> html.call(<span class="Special">this</span>, i) <span class="Statement">:</span> html );
		});
	},

	unwrap: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.parent().each(<span class="Type">function</span>() {
			<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.nodeName( <span class="Special">this</span>, <span class="Constant">&quot;body&quot;</span> ) ) {
				jQuery( <span class="Special">this</span> ).replaceWith( <span class="Special">this</span>.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
<span class="Comment">	// Support: Opera &lt;= 12.12</span>
<span class="Comment">	// Opera reports offsetWidths and offsetHeights less than zero on some elements</span>
	<span class="Statement">return</span> elem.offsetWidth <span class="Statement">&lt;=</span> <span class="Constant">0</span> <span class="Statement">&amp;&amp;</span> elem.offsetHeight <span class="Statement">&lt;=</span> <span class="Constant">0</span>;
};
jQuery.expr.filters.visible <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
	<span class="Statement">return</span> <span class="Statement">!</span>jQuery.expr.filters.hidden( elem );
};




<span class="Type">var</span> r20 <span class="Statement">=</span> <span class="Constant">/%20/g</span>,
	rbracket <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">\[\]</span><span class="Special">$</span><span class="Constant">/</span>,
	rCRLF <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">\r</span><span class="Special">?</span><span class="Special">\n</span><span class="Constant">/g</span>,
	rsubmitterTypes <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">submit</span><span class="Statement">|</span><span class="Constant">button</span><span class="Statement">|</span><span class="Constant">image</span><span class="Statement">|</span><span class="Constant">reset</span><span class="Statement">|</span><span class="Constant">file)</span><span class="Special">$</span><span class="Constant">/i</span>,
	rsubmittable <span class="Statement">=</span> <span class="Constant">/</span><span class="Special">^</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">input</span><span class="Statement">|</span><span class="Constant">select</span><span class="Statement">|</span><span class="Constant">textarea</span><span class="Statement">|</span><span class="Constant">keygen)</span><span class="Constant">/i</span>;

<span class="Type">function</span> <span class="Identifier">buildParams</span>( prefix, obj, traditional, add ) {
	<span class="Type">var</span> name;

	<span class="Statement">if</span> ( jQuery.isArray( obj ) ) {
<span class="Comment">		// Serialize array item.</span>
		jQuery.each( obj, <span class="Type">function</span>( i, v ) {
			<span class="Statement">if</span> ( traditional <span class="Statement">||</span> rbracket.test( prefix ) ) {
<span class="Comment">				// Treat each array item as a scalar.</span>
				add( prefix, v );

			} <span class="Statement">else</span> {
<span class="Comment">				// Item is non-scalar (array or object), encode its numeric index.</span>
				buildParams( prefix <span class="Statement">+</span> <span class="Constant">&quot;[&quot;</span> <span class="Statement">+</span> ( <span class="Statement">typeof</span> v <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> <span class="Statement">?</span> i <span class="Statement">:</span> <span class="Constant">&quot;&quot;</span> ) <span class="Statement">+</span> <span class="Constant">&quot;]&quot;</span>, v, traditional, add );
			}
		});

	} <span class="Statement">else</span> <span class="Statement">if</span> ( <span class="Statement">!</span>traditional <span class="Statement">&amp;&amp;</span> jQuery.type( obj ) <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
<span class="Comment">		// Serialize object item.</span>
		<span class="Statement">for</span> ( name <span class="Statement">in</span> obj ) {
			buildParams( prefix <span class="Statement">+</span> <span class="Constant">&quot;[&quot;</span> <span class="Statement">+</span> name <span class="Statement">+</span> <span class="Constant">&quot;]&quot;</span>, obj[ name ], traditional, add );
		}

	} <span class="Statement">else</span> {
<span class="Comment">		// Serialize scalar item.</span>
		add( prefix, obj );
	}
}

<span class="Comment">// Serialize an array of form elements or a set of</span>
<span class="Comment">// key/values into a query string</span>
jQuery.param <span class="Statement">=</span> <span class="Type">function</span>( a, traditional ) {
	<span class="Type">var</span> prefix,
		s <span class="Statement">=</span> [],
		add <span class="Statement">=</span> <span class="Type">function</span>( key, value ) {
<span class="Comment">			// If value is a function, invoke it and return its value</span>
			value <span class="Statement">=</span> jQuery.isFunction( value ) <span class="Statement">?</span> value() <span class="Statement">:</span> ( value <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span> <span class="Constant">&quot;&quot;</span> <span class="Statement">:</span> value );
			s[ s.length ] <span class="Statement">=</span> <span class="Special">encodeURIComponent</span>( key ) <span class="Statement">+</span> <span class="Constant">&quot;=&quot;</span> <span class="Statement">+</span> <span class="Special">encodeURIComponent</span>( value );
		};

<span class="Comment">	// Set traditional to true for jQuery &lt;= 1.3.2 behavior.</span>
	<span class="Statement">if</span> ( traditional <span class="Statement">===</span> <span class="Type">undefined</span> ) {
		traditional <span class="Statement">=</span> jQuery.ajaxSettings <span class="Statement">&amp;&amp;</span> jQuery.ajaxSettings.traditional;
	}

<span class="Comment">	// If an array was passed in, assume that it is an array of form elements.</span>
	<span class="Statement">if</span> ( jQuery.isArray( a ) <span class="Statement">||</span> ( a.jquery <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery.isPlainObject( a ) ) ) {
<span class="Comment">		// Serialize the form elements</span>
		jQuery.each( a, <span class="Type">function</span>() {
			add( <span class="Special">this</span>.name, <span class="Special">this</span>.value );
		});

	} <span class="Statement">else</span> {
<span class="Comment">		// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older</span>
<span class="Comment">		// did it), otherwise encode params recursively.</span>
		<span class="Statement">for</span> ( prefix <span class="Statement">in</span> a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

<span class="Comment">	// Return the resulting serialization</span>
	<span class="Statement">return</span> s.join( <span class="Constant">&quot;&amp;&quot;</span> ).replace( r20, <span class="Constant">&quot;+&quot;</span> );
};

jQuery.fn.extend({
	serialize: <span class="Type">function</span>() {
		<span class="Statement">return</span> jQuery.param( <span class="Special">this</span>.serializeArray() );
	},
	serializeArray: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.map(<span class="Type">function</span>() {
<span class="Comment">			// Can add propHook for &quot;elements&quot; to filter or add form elements</span>
			<span class="Type">var</span> elements <span class="Statement">=</span> jQuery.prop( <span class="Special">this</span>, <span class="Constant">&quot;elements&quot;</span> );
			<span class="Statement">return</span> elements <span class="Statement">?</span> jQuery.makeArray( elements ) <span class="Statement">:</span> <span class="Special">this</span>;
		})
		.filter(<span class="Type">function</span>() {
			<span class="Type">var</span> type <span class="Statement">=</span> <span class="Special">this</span>.type;

<span class="Comment">			// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works</span>
			<span class="Statement">return</span> <span class="Special">this</span>.name <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>jQuery( <span class="Special">this</span> ).is( <span class="Constant">&quot;:disabled&quot;</span> ) <span class="Statement">&amp;&amp;</span>
				rsubmittable.test( <span class="Special">this</span>.nodeName ) <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>rsubmitterTypes.test( type ) <span class="Statement">&amp;&amp;</span>
				( <span class="Special">this</span>.checked <span class="Statement">||</span> <span class="Statement">!</span>rcheckableType.test( type ) );
		})
		.map(<span class="Type">function</span>( i, elem ) {
			<span class="Type">var</span> val <span class="Statement">=</span> jQuery( <span class="Special">this</span> ).val();

			<span class="Statement">return</span> val <span class="Statement">==</span> <span class="Type">null</span> <span class="Statement">?</span>
				<span class="Type">null</span> <span class="Statement">:</span>
				jQuery.isArray( val ) <span class="Statement">?</span>
					jQuery.map( val, <span class="Type">function</span>( val ) {
						<span class="Statement">return</span> { name: elem.name, value: val.replace( rCRLF, <span class="Constant">&quot;</span><span class="Special">\r\n</span><span class="Constant">&quot;</span> ) };
					}) <span class="Statement">:</span>
					{ name: elem.name, value: val.replace( rCRLF, <span class="Constant">&quot;</span><span class="Special">\r\n</span><span class="Constant">&quot;</span> ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr <span class="Statement">=</span> <span class="Type">function</span>() {
	<span class="Statement">try</span> {
		<span class="Statement">return</span> <span class="Statement">new</span> XMLHttpRequest();
	} <span class="Statement">catch</span>( e ) {}
};

<span class="Type">var</span> xhrId <span class="Statement">=</span> <span class="Constant">0</span>,
	xhrCallbacks <span class="Statement">=</span> {},
	xhrSuccessStatus <span class="Statement">=</span> {
<span class="Comment">		// file protocol always yields status code 0, assume 200</span>
		<span class="Constant">0</span>: <span class="Constant">200</span>,
<span class="Comment">		// Support: IE9</span>
<span class="Comment">		// #1450: sometimes IE returns 1223 when it should be 204</span>
		<span class="Constant">1223</span>: <span class="Constant">204</span>
	},
	xhrSupported <span class="Statement">=</span> jQuery.ajaxSettings.xhr();

<span class="Comment">// Support: IE9</span>
<span class="Comment">// Open requests must be manually aborted on unload (#5280)</span>
<span class="Statement">if</span> ( <span class="Special">window</span>.ActiveXObject ) {
	jQuery( <span class="Special">window</span> ).on( <span class="Constant">&quot;unload&quot;</span>, <span class="Type">function</span>() {
		<span class="Statement">for</span> ( <span class="Type">var</span> key <span class="Statement">in</span> xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors <span class="Statement">=</span> <span class="Statement">!!</span>xhrSupported <span class="Statement">&amp;&amp;</span> ( <span class="Constant">&quot;withCredentials&quot;</span> <span class="Statement">in</span> xhrSupported );
support.ajax <span class="Statement">=</span> xhrSupported <span class="Statement">=</span> <span class="Statement">!!</span>xhrSupported;

jQuery.ajaxTransport(<span class="Type">function</span>( options ) {
	<span class="Type">var</span> callback;

<span class="Comment">	// Cross domain only allowed if supported through XMLHttpRequest</span>
	<span class="Statement">if</span> ( support.cors <span class="Statement">||</span> xhrSupported <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>options.crossDomain ) {
		<span class="Statement">return</span> {
			send: <span class="Type">function</span>( headers, complete ) {
				<span class="Type">var</span> i,
					xhr <span class="Statement">=</span> options.xhr(),
					id <span class="Statement">=</span> <span class="Statement">++</span>xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

<span class="Comment">				// Apply custom fields if provided</span>
				<span class="Statement">if</span> ( options.xhrFields ) {
					<span class="Statement">for</span> ( i <span class="Statement">in</span> options.xhrFields ) {
						xhr[ i ] <span class="Statement">=</span> options.xhrFields[ i ];
					}
				}

<span class="Comment">				// Override mime type if needed</span>
				<span class="Statement">if</span> ( options.mimeType <span class="Statement">&amp;&amp;</span> xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

<span class="Comment">				// X-Requested-With header</span>
<span class="Comment">				// For cross-domain requests, seeing as conditions for a preflight are</span>
<span class="Comment">				// akin to a jigsaw puzzle, we simply never set it to be sure.</span>
<span class="Comment">				// (it can always be set on a per-request basis or even using ajaxSetup)</span>
<span class="Comment">				// For same-domain requests, won't change header if already provided.</span>
				<span class="Statement">if</span> ( <span class="Statement">!</span>options.crossDomain <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>headers[<span class="Constant">&quot;X-Requested-With&quot;</span>] ) {
					headers[<span class="Constant">&quot;X-Requested-With&quot;</span>] <span class="Statement">=</span> <span class="Constant">&quot;XMLHttpRequest&quot;</span>;
				}

<span class="Comment">				// Set headers</span>
				<span class="Statement">for</span> ( i <span class="Statement">in</span> headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

<span class="Comment">				// Callback</span>
				callback <span class="Statement">=</span> <span class="Type">function</span>( type ) {
					<span class="Statement">return</span> <span class="Type">function</span>() {
						<span class="Statement">if</span> ( callback ) {
							<span class="Statement">delete</span> xhrCallbacks[ id ];
							callback <span class="Statement">=</span> xhr.onload <span class="Statement">=</span> xhr.onerror <span class="Statement">=</span> <span class="Type">null</span>;

							<span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;abort&quot;</span> ) {
								xhr.abort();
							} <span class="Statement">else</span> <span class="Statement">if</span> ( type <span class="Statement">===</span> <span class="Constant">&quot;error&quot;</span> ) {
								complete(
<span class="Comment">									// file: protocol always yields status 0; see #8605, #14207</span>
									xhr.status,
									xhr.statusText
								);
							} <span class="Statement">else</span> {
								complete(
									xhrSuccessStatus[ xhr.status ] <span class="Statement">||</span> xhr.status,
									xhr.statusText,
<span class="Comment">									// Support: IE9</span>
<span class="Comment">									// Accessing binary-data responseText throws an exception</span>
<span class="Comment">									// (#11426)</span>
									<span class="Statement">typeof</span> xhr.responseText <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">?</span> {
										text: xhr.responseText
									} <span class="Statement">:</span> <span class="Type">undefined</span>,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

<span class="Comment">				// Listen to events</span>
				xhr.onload <span class="Statement">=</span> callback();
				xhr.onerror <span class="Statement">=</span> callback(<span class="Constant">&quot;error&quot;</span>);

<span class="Comment">				// Create the abort callback</span>
				callback <span class="Statement">=</span> xhrCallbacks[ id ] <span class="Statement">=</span> callback(<span class="Constant">&quot;abort&quot;</span>);

<span class="Comment">				// Do send the request</span>
<span class="Comment">				// This may raise an exception which is actually</span>
<span class="Comment">				// handled in jQuery.ajax (so no try/catch here)</span>
				xhr.send( options.hasContent <span class="Statement">&amp;&amp;</span> options.data <span class="Statement">||</span> <span class="Type">null</span> );
			},

			abort: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( callback ) {
					callback();
				}
			}
		};
	}
});




<span class="Comment">// Install script dataType</span>
jQuery.ajaxSetup({
	accepts: {
		script: <span class="Constant">&quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;</span>
	},
	contents: {
		script: <span class="Constant">/</span><span class="Constant">(</span><span class="Special">?:</span><span class="Constant">java</span><span class="Statement">|</span><span class="Constant">ecma)</span><span class="Constant">script/</span>
	},
	converters: {
		<span class="Constant">&quot;text script&quot;</span>: <span class="Type">function</span>( text ) {
			jQuery.globalEval( text );
			<span class="Statement">return</span> text;
		}
	}
});

<span class="Comment">// Handle cache's special case and crossDomain</span>
jQuery.ajaxPrefilter( <span class="Constant">&quot;script&quot;</span>, <span class="Type">function</span>( s ) {
	<span class="Statement">if</span> ( s.cache <span class="Statement">===</span> <span class="Type">undefined</span> ) {
		s.cache <span class="Statement">=</span> <span class="Constant">false</span>;
	}
	<span class="Statement">if</span> ( s.crossDomain ) {
		s.type <span class="Statement">=</span> <span class="Constant">&quot;GET&quot;</span>;
	}
});

<span class="Comment">// Bind script tag hack transport</span>
jQuery.ajaxTransport( <span class="Constant">&quot;script&quot;</span>, <span class="Type">function</span>( s ) {
<span class="Comment">	// This transport only deals with cross domain requests</span>
	<span class="Statement">if</span> ( s.crossDomain ) {
		<span class="Type">var</span> script, callback;
		<span class="Statement">return</span> {
			send: <span class="Type">function</span>( _, complete ) {
				script <span class="Statement">=</span> jQuery(<span class="Constant">&quot;&lt;script&gt;&quot;</span>).prop({
					async: <span class="Constant">true</span>,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					<span class="Constant">&quot;load error&quot;</span>,
					callback <span class="Statement">=</span> <span class="Type">function</span>( evt ) {
						script.remove();
						callback <span class="Statement">=</span> <span class="Type">null</span>;
						<span class="Statement">if</span> ( evt ) {
							complete( evt.type <span class="Statement">===</span> <span class="Constant">&quot;error&quot;</span> <span class="Statement">?</span> <span class="Constant">404</span> <span class="Statement">:</span> <span class="Constant">200</span>, evt.type );
						}
					}
				);
				<span class="Special">document</span>.head.appendChild( script[ <span class="Constant">0</span> ] );
			},
			abort: <span class="Type">function</span>() {
				<span class="Statement">if</span> ( callback ) {
					callback();
				}
			}
		};
	}
});




<span class="Type">var</span> oldCallbacks <span class="Statement">=</span> [],
	rjsonp <span class="Statement">=</span> <span class="Constant">/</span><span class="Constant">(=)</span><span class="Special">\?</span><span class="Constant">(</span><span class="Special">?=</span><span class="Constant">&amp;</span><span class="Statement">|</span><span class="Special">$</span><span class="Constant">)</span><span class="Statement">|</span><span class="Special">\?\?</span><span class="Constant">/</span>;

<span class="Comment">// Default jsonp settings</span>
jQuery.ajaxSetup({
	jsonp: <span class="Constant">&quot;callback&quot;</span>,
	jsonpCallback: <span class="Type">function</span>() {
		<span class="Type">var</span> callback <span class="Statement">=</span> oldCallbacks.pop() <span class="Statement">||</span> ( jQuery.expando <span class="Statement">+</span> <span class="Constant">&quot;_&quot;</span> <span class="Statement">+</span> ( nonce<span class="Statement">++</span> ) );
		<span class="Special">this</span>[ callback ] <span class="Statement">=</span> <span class="Constant">true</span>;
		<span class="Statement">return</span> callback;
	}
});

<span class="Comment">// Detect, normalize options and install callbacks for jsonp requests</span>
jQuery.ajaxPrefilter( <span class="Constant">&quot;json jsonp&quot;</span>, <span class="Type">function</span>( s, originalSettings, jqXHR ) {

	<span class="Type">var</span> callbackName, overwritten, responseContainer,
		jsonProp <span class="Statement">=</span> s.jsonp <span class="Statement">!==</span> <span class="Constant">false</span> <span class="Statement">&amp;&amp;</span> ( rjsonp.test( s.url ) <span class="Statement">?</span>
			<span class="Constant">&quot;url&quot;</span> <span class="Statement">:</span>
			<span class="Statement">typeof</span> s.data <span class="Statement">===</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> <span class="Statement">!</span>( s.contentType <span class="Statement">||</span> <span class="Constant">&quot;&quot;</span> ).indexOf(<span class="Constant">&quot;application/x-www-form-urlencoded&quot;</span>) <span class="Statement">&amp;&amp;</span> rjsonp.test( s.data ) <span class="Statement">&amp;&amp;</span> <span class="Constant">&quot;data&quot;</span>
		);

<span class="Comment">	// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set</span>
	<span class="Statement">if</span> ( jsonProp <span class="Statement">||</span> s.dataTypes[ <span class="Constant">0</span> ] <span class="Statement">===</span> <span class="Constant">&quot;jsonp&quot;</span> ) {

<span class="Comment">		// Get callback name, remembering preexisting value associated with it</span>
		callbackName <span class="Statement">=</span> s.jsonpCallback <span class="Statement">=</span> jQuery.isFunction( s.jsonpCallback ) <span class="Statement">?</span>
			s.jsonpCallback() <span class="Statement">:</span>
			s.jsonpCallback;

<span class="Comment">		// Insert callback into url or form data</span>
		<span class="Statement">if</span> ( jsonProp ) {
			s[ jsonProp ] <span class="Statement">=</span> s[ jsonProp ].replace( rjsonp, <span class="Constant">&quot;$1&quot;</span> <span class="Statement">+</span> callbackName );
		} <span class="Statement">else</span> <span class="Statement">if</span> ( s.jsonp <span class="Statement">!==</span> <span class="Constant">false</span> ) {
			s.url <span class="Statement">+=</span> ( rquery.test( s.url ) <span class="Statement">?</span> <span class="Constant">&quot;&amp;&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;?&quot;</span> ) <span class="Statement">+</span> s.jsonp <span class="Statement">+</span> <span class="Constant">&quot;=&quot;</span> <span class="Statement">+</span> callbackName;
		}

<span class="Comment">		// Use data converter to retrieve json after script execution</span>
		s.converters[<span class="Constant">&quot;script json&quot;</span>] <span class="Statement">=</span> <span class="Type">function</span>() {
			<span class="Statement">if</span> ( <span class="Statement">!</span>responseContainer ) {
				jQuery.error( callbackName <span class="Statement">+</span> <span class="Constant">&quot; was not called&quot;</span> );
			}
			<span class="Statement">return</span> responseContainer[ <span class="Constant">0</span> ];
		};

<span class="Comment">		// force json dataType</span>
		s.dataTypes[ <span class="Constant">0</span> ] <span class="Statement">=</span> <span class="Constant">&quot;json&quot;</span>;

<span class="Comment">		// Install callback</span>
		overwritten <span class="Statement">=</span> <span class="Special">window</span>[ callbackName ];
		<span class="Special">window</span>[ callbackName ] <span class="Statement">=</span> <span class="Type">function</span>() {
			responseContainer <span class="Statement">=</span> <span class="Special">arguments</span>;
		};

<span class="Comment">		// Clean-up function (fires after converters)</span>
		jqXHR.always(<span class="Type">function</span>() {
<span class="Comment">			// Restore preexisting value</span>
			<span class="Special">window</span>[ callbackName ] <span class="Statement">=</span> overwritten;

<span class="Comment">			// Save back as free</span>
			<span class="Statement">if</span> ( s[ callbackName ] ) {
<span class="Comment">				// make sure that re-using the options doesn't screw things around</span>
				s.jsonpCallback <span class="Statement">=</span> originalSettings.jsonpCallback;

<span class="Comment">				// save the callback name for future use</span>
				oldCallbacks.push( callbackName );
			}

<span class="Comment">			// Call if it was a function and we have a response</span>
			<span class="Statement">if</span> ( responseContainer <span class="Statement">&amp;&amp;</span> jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ <span class="Constant">0</span> ] );
			}

			responseContainer <span class="Statement">=</span> overwritten <span class="Statement">=</span> <span class="Type">undefined</span>;
		});

<span class="Comment">		// Delegate to script</span>
		<span class="Statement">return</span> <span class="Constant">&quot;script&quot;</span>;
	}
});




<span class="Comment">// data: string of html</span>
<span class="Comment">// context (optional): If specified, the fragment will be created in this context, defaults to document</span>
<span class="Comment">// keepScripts (optional): If true, will include scripts passed in the html string</span>
jQuery.parseHTML <span class="Statement">=</span> <span class="Type">function</span>( data, context, keepScripts ) {
	<span class="Statement">if</span> ( <span class="Statement">!</span>data <span class="Statement">||</span> <span class="Statement">typeof</span> data <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> ) {
		<span class="Statement">return</span> <span class="Type">null</span>;
	}
	<span class="Statement">if</span> ( <span class="Statement">typeof</span> context <span class="Statement">===</span> <span class="Constant">&quot;boolean&quot;</span> ) {
		keepScripts <span class="Statement">=</span> context;
		context <span class="Statement">=</span> <span class="Constant">false</span>;
	}
	context <span class="Statement">=</span> context <span class="Statement">||</span> <span class="Special">document</span>;

	<span class="Type">var</span> parsed <span class="Statement">=</span> rsingleTag.exec( data ),
		scripts <span class="Statement">=</span> <span class="Statement">!</span>keepScripts <span class="Statement">&amp;&amp;</span> [];

<span class="Comment">	// Single tag</span>
	<span class="Statement">if</span> ( parsed ) {
		<span class="Statement">return</span> [ context.createElement( parsed[<span class="Constant">1</span>] ) ];
	}

	parsed <span class="Statement">=</span> jQuery.buildFragment( [ data ], context, scripts );

	<span class="Statement">if</span> ( scripts <span class="Statement">&amp;&amp;</span> scripts.length ) {
		jQuery( scripts ).remove();
	}

	<span class="Statement">return</span> jQuery.merge( [], parsed.childNodes );
};


<span class="Comment">// Keep a copy of the old load method</span>
<span class="Type">var</span> _load <span class="Statement">=</span> jQuery.fn.load;

<span class="Comment">/**</span>
<span class="Comment"> * Load a url into a page</span>
<span class="Comment"> </span><span class="Comment">*/</span>
jQuery.fn.load <span class="Statement">=</span> <span class="Type">function</span>( url, params, callback ) {
	<span class="Statement">if</span> ( <span class="Statement">typeof</span> url <span class="Statement">!==</span> <span class="Constant">&quot;string&quot;</span> <span class="Statement">&amp;&amp;</span> _load ) {
		<span class="Statement">return</span> _load.apply( <span class="Special">this</span>, arguments );
	}

	<span class="Type">var</span> selector, type, response,
		self <span class="Statement">=</span> <span class="Special">this</span>,
		off <span class="Statement">=</span> url.indexOf(<span class="Constant">&quot; &quot;</span>);

	<span class="Statement">if</span> ( off <span class="Statement">&gt;=</span> <span class="Constant">0</span> ) {
		selector <span class="Statement">=</span> url.slice( off );
		url <span class="Statement">=</span> url.slice( <span class="Constant">0</span>, off );
	}

<span class="Comment">	// If it's a function</span>
	<span class="Statement">if</span> ( jQuery.isFunction( params ) ) {

<span class="Comment">		// We assume that it's the callback</span>
		callback <span class="Statement">=</span> params;
		params <span class="Statement">=</span> <span class="Type">undefined</span>;

<span class="Comment">	// Otherwise, build a param string</span>
	} <span class="Statement">else</span> <span class="Statement">if</span> ( params <span class="Statement">&amp;&amp;</span> <span class="Statement">typeof</span> params <span class="Statement">===</span> <span class="Constant">&quot;object&quot;</span> ) {
		type <span class="Statement">=</span> <span class="Constant">&quot;POST&quot;</span>;
	}

<span class="Comment">	// If we have elements to modify, make the request</span>
	<span class="Statement">if</span> ( self.length <span class="Statement">&gt;</span> <span class="Constant">0</span> ) {
		jQuery.ajax({
			url: url,

<span class="Comment">			// if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used</span>
			type: type,
			dataType: <span class="Constant">&quot;html&quot;</span>,
			data: params
		}).done(<span class="Type">function</span>( responseText ) {

<span class="Comment">			// Save response for use in complete callback</span>
			response <span class="Statement">=</span> <span class="Special">arguments</span>;

			self.html( selector <span class="Statement">?</span>

<span class="Comment">				// If a selector was specified, locate the right elements in a dummy div</span>
<span class="Comment">				// Exclude scripts to avoid IE 'Permission Denied' errors</span>
				jQuery(<span class="Constant">&quot;&lt;div&gt;&quot;</span>).append( jQuery.parseHTML( responseText ) ).find( selector ) <span class="Statement">:</span>

<span class="Comment">				// Otherwise use the full result</span>
				responseText );

		}).complete( callback <span class="Statement">&amp;&amp;</span> <span class="Type">function</span>( jqXHR, status ) {
			self.each( callback, response <span class="Statement">||</span> [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	<span class="Statement">return</span> <span class="Special">this</span>;
};




jQuery.expr.filters.animated <span class="Statement">=</span> <span class="Type">function</span>( elem ) {
	<span class="Statement">return</span> jQuery.grep(jQuery.timers, <span class="Type">function</span>( fn ) {
		<span class="Statement">return</span> elem <span class="Statement">===</span> fn.elem;
	}).length;
};




<span class="Type">var</span> docElem <span class="Statement">=</span> <span class="Special">window</span>.<span class="Special">document</span>.documentElement;

<span class="Comment">/**</span>
<span class="Comment"> * Gets a window from an element</span>
<span class="Comment"> </span><span class="Comment">*/</span>
<span class="Type">function</span> <span class="Identifier">getWindow</span>( elem ) {
	<span class="Statement">return</span> jQuery.isWindow( elem ) <span class="Statement">?</span> elem <span class="Statement">:</span> elem.nodeType <span class="Statement">===</span> <span class="Constant">9</span> <span class="Statement">&amp;&amp;</span> elem.defaultView;
}

jQuery.offset <span class="Statement">=</span> {
	setOffset: <span class="Type">function</span>( elem, options, i ) {
		<span class="Type">var</span> curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position <span class="Statement">=</span> jQuery.css( elem, <span class="Constant">&quot;position&quot;</span> ),
			curElem <span class="Statement">=</span> jQuery( elem ),
			props <span class="Statement">=</span> {};

<span class="Comment">		// Set position first, in-case top/left are set even on static elem</span>
		<span class="Statement">if</span> ( position <span class="Statement">===</span> <span class="Constant">&quot;static&quot;</span> ) {
			elem.style.position <span class="Statement">=</span> <span class="Constant">&quot;relative&quot;</span>;
		}

		curOffset <span class="Statement">=</span> curElem.offset();
		curCSSTop <span class="Statement">=</span> jQuery.css( elem, <span class="Constant">&quot;top&quot;</span> );
		curCSSLeft <span class="Statement">=</span> jQuery.css( elem, <span class="Constant">&quot;left&quot;</span> );
		calculatePosition <span class="Statement">=</span> ( position <span class="Statement">===</span> <span class="Constant">&quot;absolute&quot;</span> <span class="Statement">||</span> position <span class="Statement">===</span> <span class="Constant">&quot;fixed&quot;</span> ) <span class="Statement">&amp;&amp;</span>
			( curCSSTop <span class="Statement">+</span> curCSSLeft ).indexOf(<span class="Constant">&quot;auto&quot;</span>) <span class="Statement">&gt;</span> <span class="Statement">-</span><span class="Constant">1</span>;

<span class="Comment">		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed</span>
		<span class="Statement">if</span> ( calculatePosition ) {
			curPosition <span class="Statement">=</span> curElem.position();
			curTop <span class="Statement">=</span> curPosition.top;
			curLeft <span class="Statement">=</span> curPosition.left;

		} <span class="Statement">else</span> {
			curTop <span class="Statement">=</span> <span class="Special">parseFloat</span>( curCSSTop ) <span class="Statement">||</span> <span class="Constant">0</span>;
			curLeft <span class="Statement">=</span> <span class="Special">parseFloat</span>( curCSSLeft ) <span class="Statement">||</span> <span class="Constant">0</span>;
		}

		<span class="Statement">if</span> ( jQuery.isFunction( options ) ) {
			options <span class="Statement">=</span> options.call( elem, i, curOffset );
		}

		<span class="Statement">if</span> ( options.top <span class="Statement">!=</span> <span class="Type">null</span> ) {
			props.top <span class="Statement">=</span> ( options.top <span class="Statement">-</span> curOffset.top ) <span class="Statement">+</span> curTop;
		}
		<span class="Statement">if</span> ( options.left <span class="Statement">!=</span> <span class="Type">null</span> ) {
			props.left <span class="Statement">=</span> ( options.left <span class="Statement">-</span> curOffset.left ) <span class="Statement">+</span> curLeft;
		}

		<span class="Statement">if</span> ( <span class="Constant">&quot;using&quot;</span> <span class="Statement">in</span> options ) {
			options.using.call( elem, props );

		} <span class="Statement">else</span> {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: <span class="Type">function</span>( options ) {
		<span class="Statement">if</span> ( arguments.length ) {
			<span class="Statement">return</span> options <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">?</span>
				<span class="Special">this</span> <span class="Statement">:</span>
				<span class="Special">this</span>.each(<span class="Type">function</span>( i ) {
					jQuery.offset.setOffset( <span class="Special">this</span>, options, i );
				});
		}

		<span class="Type">var</span> docElem, win,
			elem <span class="Statement">=</span> <span class="Special">this</span>[ <span class="Constant">0</span> ],
			box <span class="Statement">=</span> { top: <span class="Constant">0</span>, left: <span class="Constant">0</span> },
			doc <span class="Statement">=</span> elem <span class="Statement">&amp;&amp;</span> elem.ownerDocument;

		<span class="Statement">if</span> ( <span class="Statement">!</span>doc ) {
			<span class="Statement">return</span>;
		}

		docElem <span class="Statement">=</span> doc.documentElement;

<span class="Comment">		// Make sure it's not a disconnected DOM node</span>
		<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.contains( docElem, elem ) ) {
			<span class="Statement">return</span> box;
		}

<span class="Comment">		// If we don't have gBCR, just use 0,0 rather than error</span>
<span class="Comment">		// BlackBerry 5, iOS 3 (original iPhone)</span>
		<span class="Statement">if</span> ( <span class="Statement">typeof</span> elem.getBoundingClientRect <span class="Statement">!==</span> strundefined ) {
			box <span class="Statement">=</span> elem.getBoundingClientRect();
		}
		win <span class="Statement">=</span> getWindow( doc );
		<span class="Statement">return</span> {
			top: box.top <span class="Statement">+</span> win.pageYOffset <span class="Statement">-</span> docElem.clientTop,
			left: box.left <span class="Statement">+</span> win.pageXOffset <span class="Statement">-</span> docElem.clientLeft
		};
	},

	position: <span class="Type">function</span>() {
		<span class="Statement">if</span> ( <span class="Statement">!</span><span class="Special">this</span>[ <span class="Constant">0</span> ] ) {
			<span class="Statement">return</span>;
		}

		<span class="Type">var</span> offsetParent, offset,
			elem <span class="Statement">=</span> <span class="Special">this</span>[ <span class="Constant">0</span> ],
			parentOffset <span class="Statement">=</span> { top: <span class="Constant">0</span>, left: <span class="Constant">0</span> };

<span class="Comment">		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent</span>
		<span class="Statement">if</span> ( jQuery.css( elem, <span class="Constant">&quot;position&quot;</span> ) <span class="Statement">===</span> <span class="Constant">&quot;fixed&quot;</span> ) {
<span class="Comment">			// We assume that getBoundingClientRect is available when computed position is fixed</span>
			offset <span class="Statement">=</span> elem.getBoundingClientRect();

		} <span class="Statement">else</span> {
<span class="Comment">			// Get *real* offsetParent</span>
			offsetParent <span class="Statement">=</span> <span class="Special">this</span>.offsetParent();

<span class="Comment">			// Get correct offsets</span>
			offset <span class="Statement">=</span> <span class="Special">this</span>.offset();
			<span class="Statement">if</span> ( <span class="Statement">!</span>jQuery.nodeName( offsetParent[ <span class="Constant">0</span> ], <span class="Constant">&quot;html&quot;</span> ) ) {
				parentOffset <span class="Statement">=</span> offsetParent.offset();
			}

<span class="Comment">			// Add offsetParent borders</span>
			parentOffset.top <span class="Statement">+=</span> jQuery.css( offsetParent[ <span class="Constant">0</span> ], <span class="Constant">&quot;borderTopWidth&quot;</span>, <span class="Constant">true</span> );
			parentOffset.left <span class="Statement">+=</span> jQuery.css( offsetParent[ <span class="Constant">0</span> ], <span class="Constant">&quot;borderLeftWidth&quot;</span>, <span class="Constant">true</span> );
		}

<span class="Comment">		// Subtract parent offsets and element margins</span>
		<span class="Statement">return</span> {
			top: offset.top <span class="Statement">-</span> parentOffset.top <span class="Statement">-</span> jQuery.css( elem, <span class="Constant">&quot;marginTop&quot;</span>, <span class="Constant">true</span> ),
			left: offset.left <span class="Statement">-</span> parentOffset.left <span class="Statement">-</span> jQuery.css( elem, <span class="Constant">&quot;marginLeft&quot;</span>, <span class="Constant">true</span> )
		};
	},

	offsetParent: <span class="Type">function</span>() {
		<span class="Statement">return</span> <span class="Special">this</span>.map(<span class="Type">function</span>() {
			<span class="Type">var</span> offsetParent <span class="Statement">=</span> <span class="Special">this</span>.offsetParent <span class="Statement">||</span> docElem;

			<span class="Statement">while</span> ( offsetParent <span class="Statement">&amp;&amp;</span> ( <span class="Statement">!</span>jQuery.nodeName( offsetParent, <span class="Constant">&quot;html&quot;</span> ) <span class="Statement">&amp;&amp;</span> jQuery.css( offsetParent, <span class="Constant">&quot;position&quot;</span> ) <span class="Statement">===</span> <span class="Constant">&quot;static&quot;</span> ) ) {
				offsetParent <span class="Statement">=</span> offsetParent.offsetParent;
			}

			<span class="Statement">return</span> offsetParent <span class="Statement">||</span> docElem;
		});
	}
});

<span class="Comment">// Create scrollLeft and scrollTop methods</span>
jQuery.each( { scrollLeft: <span class="Constant">&quot;pageXOffset&quot;</span>, scrollTop: <span class="Constant">&quot;pageYOffset&quot;</span> }, <span class="Type">function</span>( method, prop ) {
	<span class="Type">var</span> top <span class="Statement">=</span> <span class="Constant">&quot;pageYOffset&quot;</span> <span class="Statement">===</span> prop;

	jQuery.fn[ method ] <span class="Statement">=</span> <span class="Type">function</span>( val ) {
		<span class="Statement">return</span> access( <span class="Special">this</span>, <span class="Type">function</span>( elem, method, val ) {
			<span class="Type">var</span> win <span class="Statement">=</span> getWindow( elem );

			<span class="Statement">if</span> ( val <span class="Statement">===</span> <span class="Type">undefined</span> ) {
				<span class="Statement">return</span> win <span class="Statement">?</span> win[ prop ] <span class="Statement">:</span> elem[ method ];
			}

			<span class="Statement">if</span> ( win ) {
				win.scrollTo(
					<span class="Statement">!</span>top <span class="Statement">?</span> val <span class="Statement">:</span> <span class="Special">window</span>.pageXOffset,
					top <span class="Statement">?</span> val <span class="Statement">:</span> <span class="Special">window</span>.pageYOffset
				);

			} <span class="Statement">else</span> {
				elem[ method ] <span class="Statement">=</span> val;
			}
		}, method, val, arguments.length, <span class="Type">null</span> );
	};
});

<span class="Comment">// Add the top/left cssHooks using jQuery.fn.position</span>
<span class="Comment">// Webkit bug: <a href="https://bugs.webkit.org/show_bug.cgi?id=29084">https://bugs.webkit.org/show_bug.cgi?id=29084</a></span>
<span class="Comment">// getComputedStyle returns percent when specified for top/left/bottom/right</span>
<span class="Comment">// rather than make the css module depend on the offset module, we just check for it here</span>
jQuery.each( [ <span class="Constant">&quot;top&quot;</span>, <span class="Constant">&quot;left&quot;</span> ], <span class="Type">function</span>( i, prop ) {
	jQuery.cssHooks[ prop ] <span class="Statement">=</span> addGetHookIf( support.pixelPosition,
		<span class="Type">function</span>( elem, computed ) {
			<span class="Statement">if</span> ( computed ) {
				computed <span class="Statement">=</span> curCSS( elem, prop );
<span class="Comment">				// if curCSS returns percentage, fallback to offset</span>
				<span class="Statement">return</span> rnumnonpx.test( computed ) <span class="Statement">?</span>
					jQuery( elem ).position()[ prop ] <span class="Statement">+</span> <span class="Constant">&quot;px&quot;</span> <span class="Statement">:</span>
					computed;
			}
		}
	);
});


<span class="Comment">// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods</span>
jQuery.each( { Height: <span class="Constant">&quot;height&quot;</span>, Width: <span class="Constant">&quot;width&quot;</span> }, <span class="Type">function</span>( name, type ) {
	jQuery.each( { padding: <span class="Constant">&quot;inner&quot;</span> <span class="Statement">+</span> name, content: type, <span class="Constant">&quot;&quot;</span>: <span class="Constant">&quot;outer&quot;</span> <span class="Statement">+</span> name }, <span class="Type">function</span>( defaultExtra, funcName ) {
<span class="Comment">		// margin is only for outerHeight, outerWidth</span>
		jQuery.fn[ funcName ] <span class="Statement">=</span> <span class="Type">function</span>( margin, value ) {
			<span class="Type">var</span> chainable <span class="Statement">=</span> <span class="Special">arguments</span>.length <span class="Statement">&amp;&amp;</span> ( defaultExtra <span class="Statement">||</span> <span class="Statement">typeof</span> margin <span class="Statement">!==</span> <span class="Constant">&quot;boolean&quot;</span> ),
				extra <span class="Statement">=</span> defaultExtra <span class="Statement">||</span> ( margin <span class="Statement">===</span> <span class="Constant">true</span> <span class="Statement">||</span> value <span class="Statement">===</span> <span class="Constant">true</span> <span class="Statement">?</span> <span class="Constant">&quot;margin&quot;</span> <span class="Statement">:</span> <span class="Constant">&quot;border&quot;</span> );

			<span class="Statement">return</span> access( <span class="Special">this</span>, <span class="Type">function</span>( elem, type, value ) {
				<span class="Type">var</span> doc;

				<span class="Statement">if</span> ( jQuery.isWindow( elem ) ) {
<span class="Comment">					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there</span>
<span class="Comment">					// isn't a whole lot we can do. See pull request at this URL for discussion:</span>
<span class="Comment">					// <a href="https://github.com/jquery/jquery/pull/764">https://github.com/jquery/jquery/pull/764</a></span>
					<span class="Statement">return</span> elem.<span class="Special">document</span>.documentElement[ <span class="Constant">&quot;client&quot;</span> <span class="Statement">+</span> name ];
				}

<span class="Comment">				// Get document width or height</span>
				<span class="Statement">if</span> ( elem.nodeType <span class="Statement">===</span> <span class="Constant">9</span> ) {
					doc <span class="Statement">=</span> elem.documentElement;

<span class="Comment">					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],</span>
<span class="Comment">					// whichever is greatest</span>
					<span class="Statement">return</span> <span class="Special">Math</span>.max(
						elem.body[ <span class="Constant">&quot;scroll&quot;</span> <span class="Statement">+</span> name ], doc[ <span class="Constant">&quot;scroll&quot;</span> <span class="Statement">+</span> name ],
						elem.body[ <span class="Constant">&quot;offset&quot;</span> <span class="Statement">+</span> name ], doc[ <span class="Constant">&quot;offset&quot;</span> <span class="Statement">+</span> name ],
						doc[ <span class="Constant">&quot;client&quot;</span> <span class="Statement">+</span> name ]
					);
				}

				<span class="Statement">return</span> value <span class="Statement">===</span> <span class="Type">undefined</span> <span class="Statement">?</span>
<span class="Comment">					// Get width or height on the element, requesting but not forcing parseFloat</span>
					jQuery.css( elem, type, extra ) <span class="Statement">:</span>

<span class="Comment">					// Set width or height on the element</span>
					jQuery.style( elem, type, value, extra );
			}, type, chainable <span class="Statement">?</span> margin <span class="Statement">:</span> <span class="Type">undefined</span>, chainable, <span class="Type">null</span> );
		};
	});
});


<span class="Comment">// The number of elements contained in the matched element set</span>
jQuery.fn.size <span class="Statement">=</span> <span class="Type">function</span>() {
	<span class="Statement">return</span> <span class="Special">this</span>.length;
};

jQuery.fn.andSelf <span class="Statement">=</span> jQuery.fn.addBack;




<span class="Comment">// Register as a named AMD module, since jQuery can be concatenated with other</span>
<span class="Comment">// files that may use define, but not via a proper concatenation script that</span>
<span class="Comment">// understands anonymous AMD modules. A named AMD is safest and most robust</span>
<span class="Comment">// way to register. Lowercase jquery is used because AMD module names are</span>
<span class="Comment">// derived from file names, and jQuery is normally delivered in a lowercase</span>
<span class="Comment">// file name. Do this after creating the global so that if an AMD module wants</span>
<span class="Comment">// to call noConflict to hide this version of jQuery, it will work.</span>
<span class="Statement">if</span> ( <span class="Statement">typeof</span> define <span class="Statement">===</span> <span class="Constant">&quot;function&quot;</span> <span class="Statement">&amp;&amp;</span> define.amd ) {
	define( <span class="Constant">&quot;jquery&quot;</span>, [], <span class="Type">function</span>() {
		<span class="Statement">return</span> jQuery;
	});
}




<span class="Type">var</span>
<span class="Comment">	// Map over jQuery in case of overwrite</span>
	_jQuery <span class="Statement">=</span> <span class="Special">window</span>.jQuery,

<span class="Comment">	// Map over the $ in case of overwrite</span>
	_$ <span class="Statement">=</span> <span class="Special">window</span>.$;

jQuery.noConflict <span class="Statement">=</span> <span class="Type">function</span>( deep ) {
	<span class="Statement">if</span> ( <span class="Special">window</span>.$ <span class="Statement">===</span> jQuery ) {
		<span class="Special">window</span>.$ <span class="Statement">=</span> _$;
	}

	<span class="Statement">if</span> ( deep <span class="Statement">&amp;&amp;</span> <span class="Special">window</span>.jQuery <span class="Statement">===</span> jQuery ) {
		<span class="Special">window</span>.jQuery <span class="Statement">=</span> _jQuery;
	}

	<span class="Statement">return</span> jQuery;
};

<span class="Comment">// Expose jQuery and $ identifiers, even in</span>
<span class="Comment">// AMD (#7102#comment:10, <a href="https://github.com/jquery/jquery/pull/557)">https://github.com/jquery/jquery/pull/557)</a></span>
<span class="Comment">// and CommonJS for browser emulators (#13566)</span>
<span class="Statement">if</span> ( <span class="Statement">typeof</span> noGlobal <span class="Statement">===</span> strundefined ) {
	<span class="Special">window</span>.jQuery <span class="Statement">=</span> <span class="Special">window</span>.$ <span class="Statement">=</span> jQuery;
}




<span class="Statement">return</span> jQuery;

}));
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
